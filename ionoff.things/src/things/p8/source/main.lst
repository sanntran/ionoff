CCS PCH C Compiler, Version 4.114, 93460303               26-Jul-17 20:22

               Filename: D:\Projects\ionoff\ionoff.controller\p8\source\main.lst

               ROM used: 27910 bytes (85%)
                         Largest free fragment is 4858
               RAM used: 495 (24%) at main() level
                         699 (34%) worst case
               Stack:    20 worst case (11 in main + 9 for interrupts)

*
0000:  GOTO   6B60
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   00BA
0060:  BTFSS  F9D.0
0062:  GOTO   006C
0066:  BTFSC  F9E.0
0068:  GOTO   08A0
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include <main.h> 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #include <config.h> 
.................... // ConexiÃ³n entre el PIC18F4550 y el Modulo ENC28J60 (Se conecta directamente sin adaptador de voltajes). 
.................... // Se adjunta el datasheet del Modulo ENC28J60. 
....................  
.................... /* 
.................... // The connection to enc28j60 is now defined in enc28j60.c file 
....................  
.................... #define  PIN_ENC_MAC_SO    PIN_C7   // Connect from PIN MISO to ENC28J60. 
.................... #define  PIN_ENC_MAC_SI    PIN_C6   // Connect from PIN MOSI to ENC28J60. 
.................... #define  PIN_ENC_MAC_CLK   PIN_D1   // Connect from PIN SCK to ENC28J60. 
.................... #define  PIN_ENC_MAC_CS    PIN_C0   // Connect from PIN CS to ENC28J60. 
.................... #define  PIN_ENC_MAC_RST   PIN_C2   // Connect from PIN RST to ENC28J60. 
.................... #define  PIN_ENC_MAC_INT   PIN_B1   // Connect from PIN INT to ENC28J60. 
.................... #define  PIN_ENC_MAC_WOL   PIN_B3   // Connect from PIN WOL to ENC28J60. 
.................... #define  PIN_ENC_MAC_CS    PIN_D3   // Connect from PIN CS to ENC28J60. 
.................... #define  PIN_ENC_MAC_RST   PIN_D2   // Connect from PIN RST to ENC28J60. 
.................... */     
....................  
.................... //Protocolos a utilizar.                           ----------------------------- 
....................  
.................... #define  STACK_USE_MCPENC  TRUE 
.................... #define  STACK_USE_ARP     TRUE 
.................... #define  STACK_USE_ICMP    TRUE 
.................... #define  STACK_USE_TCP     TRUE 
....................  
.................... //Comment to disable LCD 
.................... //#define USE_PORTD_LCD TRUE 
....................  
.................... //Output pins------------------------------------------------------------------- 
.................... #define  OUT_8  PIN_A4 
.................... #define  OUT_7  PIN_A5 
.................... #define  OUT_6  PIN_E0 
.................... #define  OUT_5  PIN_E1 
.................... #define  OUT_4  PIN_E2 
.................... #define  OUT_3  PIN_C0 
.................... #define  OUT_2  PIN_C1 
.................... #define  OUT_1  PIN_C2 
.................... #define  OUT_TCP_STATE PIN_B4 
.................... #define  OUT_IAM_RUNNING PIN_D0 
....................  
.................... //Input pins------------------------------------------------------------------- 
.................... #define  IN_8  PIN_B2 
.................... #define  IN_7  PIN_B1 
.................... #define  IN_6  PIN_B0 
.................... #define  IN_5  PIN_D7 
.................... #define  IN_4  PIN_D6 
.................... #define  IN_3  PIN_D5 
.................... #define  IN_2  PIN_C5 
.................... #define  IN_1  PIN_C4 
.................... #define  IN_RESET  PIN_B3 
.................... #define  IN_16F_RUNNING PIN_D1 
....................  
.................... #define INPUT_SWITCH 1 
.................... #define INPUT_BUTTON 2 
....................  
.................... BYTE MY_INPUT_TYPE_BYTES[8]; 
.................... BYTE MY_SRV_IP_BYTES[4]; 
....................  
.................... typedef struct _EEP_ROM { 
....................  
....................    BYTE Flag; 
....................    BYTE SrvIps[4]; 
....................    BYTE Ips[4]; 
....................    BYTE Masks[4]; 
....................    BYTE Gates[4]; 
....................    BYTE Macs[4]; // MAC bytes from 3-6 
....................    BYTE InputTypes[8];    
.................... } EEP_ROM; 
....................  
.................... EEP_ROM MyEEPRom; 
....................  
....................  
.................... #FUSES HS                       //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES PLL12                    //Divide By 12(48MHz oscillator input) 
.................... #FUSES CPUDIV4                  //System Clock by 4 
.................... #FUSES NOUSBDIV                 //USB clock source comes from primary oscillator 
.................... #FUSES NOFCMEN                  //Fail-safe clock monitor disabled 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES BORV20                   //Brownout reset at 2.0V 
.................... #FUSES NOVREGEN                 //USB voltage regulator disabled 
.................... #FUSES NOPBADEN                 //PORTB pins are configured as digital I/O on RESET 
.................... #FUSES NOLPT1OSC                //Timer1 configured for higher power operation 
.................... //#FUSES NOMCLR                 //Master Clear pin used for I/O 
.................... #FUSES NOSTVREN                 //Stack full/underflow will not cause reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES ICPRT                    //ICPRT enabled 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
....................  
.................... #use delay(crystal=20000000,  clock=20000000) 
*
00E6:  MOVLW  02
00E8:  MOVWF  FEA
00EA:  MOVLW  A9
00EC:  MOVWF  FE9
00EE:  MOVF   FEF,W
00F0:  BZ    010C
00F2:  MOVLW  06
00F4:  MOVWF  01
00F6:  CLRF   00
00F8:  DECFSZ 00,F
00FA:  BRA    00F8
00FC:  DECFSZ 01,F
00FE:  BRA    00F6
0100:  MOVLW  7B
0102:  MOVWF  00
0104:  DECFSZ 00,F
0106:  BRA    0104
0108:  DECFSZ FEF,F
010A:  BRA    00F2
010C:  RETLW  00
....................  
....................  
....................  
....................  
.................... #ifdef USE_PORTD_LCD 
.................... #include "lcd18f.c" 
.................... #endif 
....................  
.................... #include "tcpip/stacktsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *               Microchip TCP/IP Stack FSM Implementation on PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.c 
....................  * Dependencies:    StackTsk.H 
....................  *                  ARPTsk.h 
....................  *                  MAC.h 
....................  *                  IP.h 
....................  *                  ICMP.h 
....................  *                  Tcp.h 
....................  *                  http.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/14/01  Original (Rev. 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Nilesh Rajbharti     12/5/02     Modified UDPProcess() and TCPProcess() 
....................  *                                  to include localIP as third param. 
....................  *                                  This was done to allow these functions 
....................  *                                  to calculate checksum correctly. 
....................  * Nilesh Rajbharti     7/26/04     Added code in StackTask() to not 
....................  *                                  clear statically IP address if link is 
....................  *                                  removed and DHCP module is disabled 
....................  *                                  at runtime. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A break; added to StackTask() after handling an ARP, else it would goto IP handler. 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 improvement that resets DHCP after unlink of ethernet 
....................  * Darren Rook (CCS)    06/29/04 A fix for 2.20 improvement (see above) if DHCP was dynamically disabled 
....................  * Darren Rook (CCS)    06/29/04 smStack no longer static 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    04/08/05 Task() and Init() execute any needed HTTP code 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #define STACK_USE_FTP_SERVER STACK_USE_FTP 
....................  
.................... #define STACK_INCLUDE 
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC18 SFR Definitions 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        pic18.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or later 
....................  * 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     11/14/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  ********************************************************************/ 
.................... #ifndef COMPILER_H 
.................... #define COMPILER_H 
....................  
.................... #if !defined(__PCH__) 
.................... #error "This version only works with CCS PCH or PCWH" 
.................... #endif 
....................  
.................... // ** I/O PORT REGISTERS 
....................  
.................... #byte PORTA    =  0xF80 
.................... #byte PORTB    =  0xF81 
.................... #byte PORTC    =  0xF82 
.................... #byte PORTD    =  0xF83 
.................... #byte PORTE    =  0xF84 
.................... #byte PORTF    =  0xF85 
....................  
.................... #bit PORTA_RA5 =  0xF80.5 
.................... #bit PORTA_RA4 =  0xF80.4 
.................... #bit PORTA_RA3 =  0xF80.3 
.................... #bit PORTA_RA2 =  0xF80.2 
.................... #bit PORTA_RA1 =  0xF80.1 
.................... #bit PORTA_RA0 =  0xF80.0 
....................  
.................... #bit PORTB_RB7 =  0xF81.7 
.................... #bit PORTB_RB6 =  0xF81.6 
.................... #bit PORTB_RB5 =  0xF81.5 
.................... #bit PORTB_RB4 =  0xF81.4 
.................... #bit PORTB_RB3 =  0xF81.3 
.................... #bit PORTB_RB2 =  0xF81.2 
.................... #bit PORTB_RB1 =  0xF81.1 
.................... #bit PORTB_RB0 =  0xF81.0 
....................  
.................... #bit PORTC_RC7 =  0xF82.7 
.................... #bit PORTC_RC6 =  0xF82.6 
.................... #bit PORTC_RC5 =  0xF82.5 
.................... #bit PORTC_RC4 =  0xF82.4 
.................... #bit PORTC_RC3 =  0xF82.3 
.................... #bit PORTC_RC2 =  0xF82.2 
.................... #bit PORTC_RC1 =  0xF82.1 
.................... #bit PORTC_RC0 =  0xF82.0 
....................  
.................... #bit PORTD_RD7 =  0xF83.7 
.................... #bit PORTD_RD6 =  0xF83.6 
.................... #bit PORTD_RD5 =  0xF83.5 
.................... #bit PORTD_RD4 =  0xF83.4 
.................... #bit PORTD_RD3 =  0xF83.3 
.................... #bit PORTD_RD2 =  0xF83.2 
.................... #bit PORTD_RD1 =  0xF83.1 
.................... #bit PORTD_RD0 =  0xF83.0 
....................  
.................... #bit PORTE_RE7 =  0xF84.7 
.................... #bit PORTE_RE6 =  0xF84.6 
.................... #bit PORTE_RE5 =  0xF84.5 
.................... #bit PORTE_RE4 =  0xF84.4 
.................... #bit PORTE_RE3 =  0xF84.3 
.................... #bit PORTE_RE2 =  0xF84.2 
.................... #bit PORTE_RE1 =  0xF84.1 
.................... #bit PORTE_RE0 =  0xF84.0 
....................  
.................... #bit PORTF_RF7 =  0xF85.7 
.................... #bit PORTF_RF6 =  0xF85.6 
.................... #bit PORTF_RF5 =  0xF85.5 
.................... #bit PORTF_RF4 =  0xF85.4 
.................... #bit PORTF_RF3 =  0xF85.3 
.................... #bit PORTF_RF2 =  0xF85.2 
.................... #bit PORTF_RF1 =  0xF85.1 
.................... #bit PORTF_RF0 =  0xF85.0 
....................  
....................  
.................... // *** TRIS REGISTERS 
....................  
.................... #byte TRISA    =  0xF92 
.................... #byte TRISB    =  0xF93 
.................... #byte TRISC    =  0xF94 
.................... #byte TRISD    =  0xF95 
.................... #byte TRISE    =  0xF96 
.................... #byte TRISF    =  0xF97 
....................  
.................... #bit TRISA_RA7 =  0xF92.7 
.................... #bit TRISA_RA6 =  0xF92.6 
.................... #bit TRISA_RA5 =  0xF92.5 
.................... #bit TRISA_RA4 =  0xF92.4 
.................... #bit TRISA_RA3 =  0xF92.3 
.................... #bit TRISA_RA2 =  0xF92.2 
.................... #bit TRISA_RA1 =  0xF92.1 
.................... #bit TRISA_RA0 =  0xF92.0 
....................  
.................... #bit TRISB_RB7 =  0xF93.7 
.................... #bit TRISB_RB6 =  0xF93.6 
.................... #bit TRISB_RB5 =  0xF93.5 
.................... #bit TRISB_RB4 =  0xF93.4 
.................... #bit TRISB_RB3 =  0xF93.3 
.................... #bit TRISB_RB2 =  0xF93.2 
.................... #bit TRISB_RB1 =  0xF93.1 
.................... #bit TRISB_RB0 =  0xF93.0 
....................  
.................... #bit TRISC_RC7 =  0xF94.7 
.................... #bit TRISC_RC6 =  0xF94.6 
.................... #bit TRISC_RC5 =  0xF94.5 
.................... #bit TRISC_RC4 =  0xF94.4 
.................... #bit TRISC_RC3 =  0xF94.3 
.................... #bit TRISC_RC2 =  0xF94.2 
.................... #bit TRISC_RC1 =  0xF94.1 
.................... #bit TRISC_RC0 =  0xF94.0 
....................  
.................... #bit TRISD_RD7 =  0xF95.7 
.................... #bit TRISD_RD6 =  0xF95.6 
.................... #bit TRISD_RD5 =  0xF95.5 
.................... #bit TRISD_RD4 =  0xF95.4 
.................... #bit TRISD_RD3 =  0xF95.3 
.................... #bit TRISD_RD2 =  0xF95.2 
.................... #bit TRISD_RD1 =  0xF95.1 
.................... #bit TRISD_RD0 =  0xF95.0 
....................  
.................... #bit TRISE_RE7 =  0xF96.7 
.................... #bit TRISE_RE6 =  0xF96.6 
.................... #bit TRISE_RE5 =  0xF96.5 
.................... #bit TRISE_RE4 =  0xF96.4 
.................... #bit TRISE_RE3 =  0xF96.3 
.................... #bit TRISE_RE2 =  0xF96.2 
.................... #bit TRISE_RE1 =  0xF96.1 
.................... #bit TRISE_RE0 =  0xF96.0 
....................  
.................... #bit TRISF_RF7 =  0xF97.7 
.................... #bit TRISF_RF6 =  0xF97.6 
.................... #bit TRISF_RF5 =  0xF97.5 
.................... #bit TRISF_RF4 =  0xF97.4 
.................... #bit TRISF_RF3 =  0xF97.3 
.................... #bit TRISF_RF2 =  0xF97.2 
.................... #bit TRISF_RF1 =  0xF97.1 
.................... #bit TRISF_RF0 =  0xF97.0 
....................  
....................  
.................... // *** LAT REGISTERS 
.................... #byte LATA    =  0xF89 
.................... #byte LATB    =  0xF8A 
.................... #byte LATC    =  0xF8B 
.................... #byte LATD    =  0xF8C 
.................... #byte LATE    =  0xF8D 
.................... #byte LATF    =  0xF8E 
....................  
.................... #bit LATA_RA7 =  0xF89.7 
.................... #bit LATA_RA6 =  0xF89.6 
.................... #bit LATA_RA5 =  0xF89.5 
.................... #bit LATA_RA4 =  0xF89.4 
.................... #bit LATA_RA3 =  0xF89.3 
.................... #bit LATA_RA2 =  0xF89.2 
.................... #bit LATA_RA1 =  0xF89.1 
.................... #bit LATA_RA0 =  0xF89.0 
....................  
.................... #bit LATB_RB7 =  0xF8A.7 
.................... #bit LATB_RB6 =  0xF8A.6 
.................... #bit LATB_RB5 =  0xF8A.5 
.................... #bit LATB_RB4 =  0xF8A.4 
.................... #bit LATB_RB3 =  0xF8A.3 
.................... #bit LATB_RB2 =  0xF8A.2 
.................... #bit LATB_RB1 =  0xF8A.1 
.................... #bit LATB_RB0 =  0xF8A.0 
....................  
.................... #bit LATC_RC7 =  0xF8B.7 
.................... #bit LATC_RC6 =  0xF8B.6 
.................... #bit LATC_RC5 =  0xF8B.5 
.................... #bit LATC_RC4 =  0xF8B.4 
.................... #bit LATC_RC3 =  0xF8B.3 
.................... #bit LATC_RC2 =  0xF8B.2 
.................... #bit LATC_RC1 =  0xF8B.1 
.................... #bit LATC_RC0 =  0xF8B.0 
....................  
.................... #bit LATD_RD7 =  0xF8C.7 
.................... #bit LATD_RD6 =  0xF8C.6 
.................... #bit LATD_RD5 =  0xF8C.5 
.................... #bit LATD_RD4 =  0xF8C.4 
.................... #bit LATD_RD3 =  0xF8C.3 
.................... #bit LATD_RD2 =  0xF8C.2 
.................... #bit LATD_RD1 =  0xF8C.1 
.................... #bit LATD_RD0 =  0xF8C.0 
....................  
.................... #bit LATE_RE7 =  0xF8D.7 
.................... #bit LATE_RE6 =  0xF8D.6 
.................... #bit LATE_RE5 =  0xF8D.5 
.................... #bit LATE_RE4 =  0xF8D.4 
.................... #bit LATE_RE3 =  0xF8D.3 
.................... #bit LATE_RE2 =  0xF8D.2 
.................... #bit LATE_RE1 =  0xF8D.1 
.................... #bit LATE_RE0 =  0xF8D.0 
....................  
.................... #bit LATF_RF7 =  0xF8E.7 
.................... #bit LATF_RF6 =  0xF8E.6 
.................... #bit LATF_RF5 =  0xF8E.5 
.................... #bit LATF_RF4 =  0xF8E.4 
.................... #bit LATF_RF3 =  0xF8E.3 
.................... #bit LATF_RF2 =  0xF8E.2 
.................... #bit LATF_RF1 =  0xF8E.1 
.................... #bit LATF_RF0 =  0xF8E.0 
....................  
....................  
.................... // ** OTHER SPECIAL FILE REGISTERS USED BY SLIP 
....................  
.................... #bit  PIE1_TXIE       =  0xF9D.4 
.................... #bit  PIE1_RCIE       =  0xF9D.5 
.................... #bit  PIR1_TXIF       =  0xF9E.4 
.................... #bit  PIR1_RCIF       =  0xF9E.5 
.................... #byte TXSTA           =  0xFAC 
.................... #byte RCSTA           =  0xFAB 
.................... #bit  RCSTA_CREN      =  0xFAB.4 
.................... #byte RCREG           =  0xFAE 
.................... #byte SPBRG           =  0xFAF 
.................... #byte TXREG           =  0xFAD 
....................  
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                         HARDWARE.H                                //// 
.................... ////                                                                   //// 
.................... //// Hardware I/O definitions and TCP/IP stack configuration settings. //// 
.................... ////                                                                   //// 
.................... //// These values will probably change with each application.          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... ////    Jan 15, 2004: MODEM_RESPONSE_TIMEOUT and MODEM_CONNECT_TIMEOUT //// 
.................... ////                  moved to here.                                   //// 
.................... ////                                                                   //// 
.................... ////    Jan 09, 2004: Initial Public Release                           //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF ___TCPIP_STACK_CONFIGURATION 
.................... #define ___TCPIP_STACK_CONFIGURATION 
....................  
.................... #ifndef STACK_USE_CCS_PICNET 
.................... #define STACK_USE_CCS_PICNET  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_CCS_PICENS 
.................... #define STACK_USE_CCS_PICENS  FALSE 
.................... #endif 
....................  
.................... /* 
....................  #use fast_io(A) 
....................  #use fast_io(B) 
....................  #use fast_io(C) 
....................  #if STACK_USE_CCS_PICNET || STACK_USE_CCS_PICEEC || STACK_USE_CCS_EWL3V 
....................  #use fast_io(F) 
....................  #endif 
....................  
....................  
....................  //// VARIOUS MODEM SETTINGS. 
....................  #DEFINE  MODEM_DCD         PIN_G3 
....................  #DEFINE  MODEM_RESET       PIN_G4 
....................  #define  MODEM_TX          PIN_G1 
....................  #define  MODEM_RX          PIN_G2 
....................  #DEFINE  MODEM_INIT_STR    "ATM1L3&K0"   //speaker on, volume high, no hw flow control 
....................  #DEFINE  MODEM_DIAL_STR    "ATDT" 
....................  #DEFINE  MODEM_BAUD_RATE   115200 
....................  
....................  #DEFINE  MODEM_RESPONSE_TIMEOUT  2000     //time to wait for a response to an AT command (in ms) 
....................  #DEFINE  MODEM_CONNECT_TIMEOUT   120000    //time to wait for modem to make a connection (in ms) 
....................  
....................  
....................  //// VARIOUS MAC/NIC SETTINGS. 
....................  #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................  #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................  #define PIN_ENC_MAC_CLK PIN_C3 
....................  #define PIN_ENC_MAC_CS  PIN_C0 
....................  #define PIN_ENC_MAC_RST PIN_C1 
....................  #define PIN_ENC_MAC_INT PIN_C6 
....................  #define PIN_ENC_MAC_WOL PIN_C7 
....................  #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................  #define mac_enc_spi_tris_init()//  TRISB=(TRISB | 0b11); TRISC = (TRISC & 0b11010111) | 0x10; TRISD=TRISD & 0xF4//was 0xFC 
....................  
....................  #if STACK_USE_CCS_PICNET 
....................  //Latch and Directional control SFR locations for the 3 control pins 
....................  #define NIC_RESET_LAT       LATE_RE7 
....................  #define NIC_IOW_LAT         LATE_RE6 
....................  #define NIC_IOR_LAT         LATE_RE5 
....................  #define NIC_RESET_TRIS      TRISE_RE7 
....................  #define NIC_IOW_TRIS        TRISE_RE6 
....................  #define NIC_IOR_TRIS        TRISE_RE5 
....................  
....................  //Latch and Directional control SFR locations for the 5bit address port 
....................  #define NIC_ADDR_LAT        LATE 
....................  #define NIC_ADDR_TRIS       TRISE 
....................  
....................  //Latch, Directional and I/O SFR locations for the 8bit data port 
....................  #define NIC_DATA_IO         PORTF 
....................  #define NIC_DATA_LAT        LATF 
....................  #define NIC_DATA_TRIS       TRISF 
....................  
....................  //This macro takes an address and properly outputs it on the latch register, and sets proper pins to output. 
....................  //Leaves other pins alone. 
....................  #define WRITE_NIC_ADDR(a)   NIC_ADDR_LAT = (NIC_ADDR_LAT & 0xE0)|a; \ 
....................                                 NIC_ADDR_TRIS = NIC_ADDR_TRIS & 0xE0 
....................  #elif STACK_USE_MCPENC 
....................  #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................  #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................  #define PIN_ENC_MAC_CLK PIN_C3 
....................  #define PIN_ENC_MAC_CS  PIN_D1 
....................  #define PIN_ENC_MAC_RST PIN_D0 
....................  #define PIN_ENC_MAC_INT PIN_B0 
....................  #define PIN_ENC_MAC_WOL PIN_B1 
....................  #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................  #define mac_enc_spi_tris_init()  TRISB=(TRISB | 0b11); TRISC = (TRISC & 0b11010111) | 0x10; TRISD=TRISD & 0xF4//was 0xFC 
....................  #elif STACK_USE_CCS_EWL5V 
....................  #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................  #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................  #define PIN_ENC_MAC_CLK PIN_C3 
....................  #define PIN_ENC_MAC_CS  PIN_A4 
....................  #define PIN_ENC_MAC_RST PIN_B5 
....................  #define PIN_ENC_MAC_INT PIN_B2 
....................  #define PIN_ENC_MAC_WOL PIN_B3 
....................  #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................  #define mac_enc_spi_tris_init()  TRISB=(TRISB | 0b00001100)&0b11011111; TRISC = (TRISC & 0b11010111) | 0x10; TRISA=TRISA & 0b11101111 
....................  #else 
....................  #error Please define your MAC/NIC I/O settings 
....................  #endif 
....................  */ 
....................  
.................... //// SET TCP_NO_WAIT_FOR_ACK TO FALSE IF TCP STACK SHOULD WAIT FOR ACK FROM 
.................... //// REMOTE HOST BEFORE TRANSMITTING ANOTHER PACKET.  THIS MAY REDUCE THROUGHPUT. 
.................... //// DEFAULT VALUE (TRUE) GETS LOADED IN TCP.H IF THIS LINE IS REMOVED. 
.................... #define TCP_NO_WAIT_FOR_ACK   FALSE 
....................  
.................... ///DEFAULT HARDCODED IP ADDRESSES. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THESE TO AN EEPROM. 
.................... ///  OR USE AUTO IP ASSIGNMENT (DHCP). 
.................... ///  NO TWO DEVICES ON A NETwORK CAN HAVE THE SAME IP ADDRESS 
.................... #define MY_DEFAULT_IP_ADDR_BYTE1        192   //IP ADDRESS 
.................... #define MY_DEFAULT_IP_ADDR_BYTE2        168   // This unit's IP address. 
.................... #define MY_DEFAULT_IP_ADDR_BYTE3        1 
.................... #define MY_DEFAULT_IP_ADDR_BYTE4        129 
....................  
.................... #define MY_DEFAULT_MASK_BYTE1           255 // NETMASK 
.................... #define MY_DEFAULT_MASK_BYTE2           255 // Netmask tells the IP / ARP stack which 
.................... #define MY_DEFAULT_MASK_BYTE3           255 // IP's are on your local network. 
.................... #define MY_DEFAULT_MASK_BYTE4           0 
....................  
.................... #define MY_DEFAULT_GATE_BYTE1           192  //GATEWAY IP ADDRESS 
.................... #define MY_DEFAULT_GATE_BYTE2           168  // Gateway acts as a conduit between two networks. 
.................... #define MY_DEFAULT_GATE_BYTE3           1 
.................... #define MY_DEFAULT_GATE_BYTE4           1 
....................  
.................... ///DEFAULT HARDCODED MAC ADDRESS. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THIS TO AN EEPROM, OR GENERATE 
.................... ///  A DYNAMIC ONE BASED UPON UNIT'S SERIAL NUMBER. 
.................... ///  NO TWO DEVICES ON THE SAME ETHERNET NETWORK CAN HAVE THE SAME MAC ADDRESS. 
.................... #define MY_DEFAULT_MAC_BYTE1            0x00 
.................... #define MY_DEFAULT_MAC_BYTE2            0x04 
.................... #define MY_DEFAULT_MAC_BYTE3            0xa3 
.................... #define MY_DEFAULT_MAC_BYTE4            0x00 
.................... #define MY_DEFAULT_MAC_BYTE5            0x00 
.................... #define MY_DEFAULT_MAC_BYTE6            0x00 
....................  
.................... ///Maximum sockets to be defined. 
.................... /// Note that each socket consumes 36 bytes of RAM. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... ///Avaialble UDP Socket 
.................... /// DCHP takes 1 socket. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... ///BUFFER SIZE DEFINITIONS 
.................... /// 
.................... /// For SLIP, there can only be one transmit and one receive buffer. 
.................... /// Both buffer must fit in one bank.  If bigger buffer is required, 
.................... /// you must manually locate tx and rx buffer in different bank 
.................... /// or modify your linker script file to support arrays bigger than 
.................... /// 256 bytes. 
.................... /// I think Microchip needs MAC_RX_BUFFER_SIZE to equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For PPP, there can only be one transmit and one receive buffer. 
.................... /// You can receive messages larger than the receive buffer if your 
.................... /// routines are fast enough.  You cannot transmit messages larger 
.................... /// than the TX buffer.  The larger the buffer you can make, the better. 
.................... /// BUG: MAC_RX_BUFFER_SIZE must equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For Ethernet, the Ethernet controler has many buffers that are 
.................... /// 1k in size.   Only one buffer is used for TX, rest are for RX. 
.................... /// Unlike SLIP and PPP, no RAM is used for these buffers. 
.................... #if STACK_USE_MAC 
.................... #define MAC_TX_BUFFER_SIZE          1024 //do not modify this line 
.................... #define MAC_TX_BUFFER_COUNT         1    //do not modify this line 
.................... #elif STACK_USE_PPP 
.................... #define MAC_TX_BUFFER_SIZE          1024 
.................... #define MAC_TX_BUFFER_COUNT         1 
.................... #elif STACK_USE_SLIP 
.................... #define MAC_TX_BUFFER_SIZE          250 
.................... #define MAC_TX_BUFFER_COUNT         1 
.................... #endif 
....................  
.................... #define MAC_RX_BUFFER_SIZE              MAC_TX_BUFFER_SIZE  //do not modify this line unless you are certain you know what you're doing 
....................  
.................... #endif 
....................  
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
59CC:  MOVLB  2
59CE:  CLRF   x2C
....................    sign = 0; 
59D0:  CLRF   x2A
....................    base = 10; 
59D2:  MOVLW  0A
59D4:  MOVWF  x2B
....................    result = 0; 
59D6:  CLRF   x29
....................  
....................    if (!s) 
59D8:  MOVF   x27,W
59DA:  IORWF  x28,W
59DC:  BNZ   59E4
....................       return 0; 
59DE:  MOVLW  00
59E0:  MOVWF  01
59E2:  BRA    5B6A
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
59E4:  MOVF   x2C,W
59E6:  INCF   x2C,F
59E8:  CLRF   03
59EA:  ADDWF  x27,W
59EC:  MOVWF  FE9
59EE:  MOVF   x28,W
59F0:  ADDWFC 03,W
59F2:  MOVWF  FEA
59F4:  MOVFF  FEF,22D
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
59F8:  MOVF   x2D,W
59FA:  SUBLW  2D
59FC:  BNZ   5A18
....................    { 
....................       sign = 1;         // Set the sign to negative 
59FE:  MOVLW  01
5A00:  MOVWF  x2A
....................       c = s[index++]; 
5A02:  MOVF   x2C,W
5A04:  INCF   x2C,F
5A06:  CLRF   03
5A08:  ADDWF  x27,W
5A0A:  MOVWF  FE9
5A0C:  MOVF   x28,W
5A0E:  ADDWFC 03,W
5A10:  MOVWF  FEA
5A12:  MOVFF  FEF,22D
....................    } 
....................    else if (c == '+') 
5A16:  BRA    5A32
5A18:  MOVF   x2D,W
5A1A:  SUBLW  2B
5A1C:  BNZ   5A32
....................    { 
....................       c = s[index++]; 
5A1E:  MOVF   x2C,W
5A20:  INCF   x2C,F
5A22:  CLRF   03
5A24:  ADDWF  x27,W
5A26:  MOVWF  FE9
5A28:  MOVF   x28,W
5A2A:  ADDWFC 03,W
5A2C:  MOVWF  FEA
5A2E:  MOVFF  FEF,22D
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
5A32:  MOVF   x2D,W
5A34:  SUBLW  2F
5A36:  BTFSC  FD8.0
5A38:  BRA    5B5A
5A3A:  MOVF   x2D,W
5A3C:  SUBLW  39
5A3E:  BTFSS  FD8.0
5A40:  BRA    5B5A
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
5A42:  MOVF   x2D,W
5A44:  SUBLW  30
5A46:  BNZ   5A8A
5A48:  CLRF   03
5A4A:  MOVF   x2C,W
5A4C:  ADDWF  x27,W
5A4E:  MOVWF  FE9
5A50:  MOVF   x28,W
5A52:  ADDWFC 03,W
5A54:  MOVWF  FEA
5A56:  MOVF   FEF,W
5A58:  SUBLW  78
5A5A:  BZ    5A70
5A5C:  CLRF   03
5A5E:  MOVF   x2C,W
5A60:  ADDWF  x27,W
5A62:  MOVWF  FE9
5A64:  MOVF   x28,W
5A66:  ADDWFC 03,W
5A68:  MOVWF  FEA
5A6A:  MOVF   FEF,W
5A6C:  SUBLW  58
5A6E:  BNZ   5A8A
....................       { 
....................          base = 16; 
5A70:  MOVLW  10
5A72:  MOVWF  x2B
....................          index++; 
5A74:  INCF   x2C,F
....................          c = s[index++]; 
5A76:  MOVF   x2C,W
5A78:  INCF   x2C,F
5A7A:  CLRF   03
5A7C:  ADDWF  x27,W
5A7E:  MOVWF  FE9
5A80:  MOVF   x28,W
5A82:  ADDWFC 03,W
5A84:  MOVWF  FEA
5A86:  MOVFF  FEF,22D
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
5A8A:  MOVF   x2B,W
5A8C:  SUBLW  0A
5A8E:  BNZ   5ACA
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
5A90:  MOVF   x2D,W
5A92:  SUBLW  2F
5A94:  BC    5AC8
5A96:  MOVF   x2D,W
5A98:  SUBLW  39
5A9A:  BNC   5AC8
....................             result = 10*result + (c - '0'); 
5A9C:  MOVLW  0A
5A9E:  MOVWF  x2E
5AA0:  MOVFF  229,22F
5AA4:  MOVLB  0
5AA6:  BRA    597C
5AA8:  MOVLW  30
5AAA:  MOVLB  2
5AAC:  SUBWF  x2D,W
5AAE:  ADDWF  01,W
5AB0:  MOVWF  x29
....................             c = s[index++]; 
5AB2:  MOVF   x2C,W
5AB4:  INCF   x2C,F
5AB6:  CLRF   03
5AB8:  ADDWF  x27,W
5ABA:  MOVWF  FE9
5ABC:  MOVF   x28,W
5ABE:  ADDWFC 03,W
5AC0:  MOVWF  FEA
5AC2:  MOVFF  FEF,22D
....................          } 
5AC6:  BRA    5A90
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
5AC8:  BRA    5B5A
5ACA:  MOVF   x2B,W
5ACC:  SUBLW  10
5ACE:  BNZ   5B5A
....................       { 
....................          c = toupper(c); 
5AD0:  MOVF   x2D,W
5AD2:  SUBLW  60
5AD4:  BC    5AE2
5AD6:  MOVF   x2D,W
5AD8:  SUBLW  7A
5ADA:  BNC   5AE2
5ADC:  MOVF   x2D,W
5ADE:  ANDLW  DF
5AE0:  BRA    5AE4
5AE2:  MOVF   x2D,W
5AE4:  MOVWF  x2D
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
5AE6:  MOVF   x2D,W
5AE8:  SUBLW  2F
5AEA:  BC    5AF2
5AEC:  MOVF   x2D,W
5AEE:  SUBLW  39
5AF0:  BC    5AFE
5AF2:  MOVF   x2D,W
5AF4:  SUBLW  40
5AF6:  BC    5B5A
5AF8:  MOVF   x2D,W
5AFA:  SUBLW  46
5AFC:  BNC   5B5A
....................             if (c >= '0' && c <= '9') 
5AFE:  MOVF   x2D,W
5B00:  SUBLW  2F
5B02:  BC    5B1C
5B04:  MOVF   x2D,W
5B06:  SUBLW  39
5B08:  BNC   5B1C
....................                result = (result << 4) + (c - '0'); 
5B0A:  SWAPF  x29,W
5B0C:  MOVWF  x2E
5B0E:  MOVLW  F0
5B10:  ANDWF  x2E,F
5B12:  MOVLW  30
5B14:  SUBWF  x2D,W
5B16:  ADDWF  x2E,W
5B18:  MOVWF  x29
....................             else 
5B1A:  BRA    5B2E
....................                result = (result << 4) + (c - 'A' + 10); 
5B1C:  SWAPF  x29,W
5B1E:  MOVWF  x2E
5B20:  MOVLW  F0
5B22:  ANDWF  x2E,F
5B24:  MOVLW  41
5B26:  SUBWF  x2D,W
5B28:  ADDLW  0A
5B2A:  ADDWF  x2E,W
5B2C:  MOVWF  x29
....................  
....................             c = s[index++]; 
5B2E:  MOVF   x2C,W
5B30:  INCF   x2C,F
5B32:  CLRF   03
5B34:  ADDWF  x27,W
5B36:  MOVWF  FE9
5B38:  MOVF   x28,W
5B3A:  ADDWFC 03,W
5B3C:  MOVWF  FEA
5B3E:  MOVFF  FEF,22D
....................             c = toupper(c); 
5B42:  MOVF   x2D,W
5B44:  SUBLW  60
5B46:  BC    5B54
5B48:  MOVF   x2D,W
5B4A:  SUBLW  7A
5B4C:  BNC   5B54
5B4E:  MOVF   x2D,W
5B50:  ANDLW  DF
5B52:  BRA    5B56
5B54:  MOVF   x2D,W
5B56:  MOVWF  x2D
....................          } 
5B58:  BRA    5AE6
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
5B5A:  DECFSZ x2A,W
5B5C:  BRA    5B66
5B5E:  MOVF   x2B,W
5B60:  SUBLW  0A
5B62:  BNZ   5B66
....................        result = -result; 
5B64:  NEGF   x29
....................  
....................    return(result); 
5B66:  MOVFF  229,01
.................... } 
5B6A:  MOVLB  0
5B6C:  RETLW  00
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
0690:  MOVFF  79,2AE
0694:  MOVFF  78,2AD
0698:  MOVFF  77,2AC
069C:  MOVFF  76,2AB
06A0:  MOVLW  41
06A2:  MOVLB  2
06A4:  MOVWF  xB2
06A6:  MOVLW  C6
06A8:  MOVWF  xB1
06AA:  MOVLW  4E
06AC:  MOVWF  xB0
06AE:  MOVLW  6D
06B0:  MOVWF  xAF
06B2:  MOVLB  0
06B4:  RCALL  05EE
06B6:  MOVLW  39
06B8:  MOVLB  2
06BA:  ADDWF  00,W
06BC:  MOVLB  0
06BE:  MOVWF  x76
06C0:  MOVLW  30
06C2:  MOVLB  2
06C4:  ADDWFC 01,W
06C6:  MOVLB  0
06C8:  MOVWF  x77
06CA:  MOVLW  00
06CC:  MOVLB  2
06CE:  ADDWFC 02,W
06D0:  MOVLB  0
06D2:  MOVWF  x78
06D4:  MOVLW  00
06D6:  MOVLB  2
06D8:  ADDWFC 03,W
06DA:  MOVLB  0
06DC:  MOVWF  x79
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
06DE:  MOVFF  78,00
06E2:  MOVFF  79,01
06E6:  CLRF   02
06E8:  CLRF   03
06EA:  MOVFF  79,2AD
06EE:  MOVFF  78,2AC
06F2:  MOVFF  79,2AF
06F6:  MOVFF  78,2AE
06FA:  MOVLW  7F
06FC:  MOVLB  2
06FE:  MOVWF  xB1
0700:  MOVLW  FF
0702:  MOVWF  xB0
0704:  MOVLB  0
0706:  RCALL  064A
0708:  MOVFF  00,01
070C:  MOVFF  03,02
.................... } 
0710:  RETLW  00
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
05DC:  MOVFF  2AE,79
05E0:  MOVFF  2AD,78
05E4:  MOVFF  2AC,77
05E8:  MOVFF  2AB,76
.................... } 
05EC:  RETLW  00
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Functions for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.C 
....................  * Dependencies:    compiler.h 
....................  *                  helpers.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     6/25/02  Rewritten CalcIPChecksum() to avoid 
....................  *                               multi-byte shift operation. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Howard Schlunder      2/9/05   Added hexatob(), btohexa_high(), and 
....................  *                        btohexa_low() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE hexatob(WORD_VAL AsciiChars) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           Two ascii bytes; each ranged '0'-'9', 'A'-'F', or 
....................  *                  'a'-'f' 
....................  * 
....................  * Output:          The resulting packed byte: 0x00-0xFF 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:         None 
....................  ********************************************************************/ 
.................... BYTE hexatob(WORD_VAL AsciiChars) { 
.................... 	// Convert lowercase to uppercase 
.................... 	if (AsciiChars.v[1] > 'F') 
.................... 		AsciiChars.v[1] -= 'a' - 'A'; 
.................... 	if (AsciiChars.v[0] > 'F') 
.................... 		AsciiChars.v[0] -= 'a' - 'A'; 
....................  
.................... 	// Convert 0-9, A-F to 0x0-0xF 
.................... 	if (AsciiChars.v[1] > '9') 
.................... 		AsciiChars.v[1] -= 'A' - 10; 
.................... 	else 
.................... 		AsciiChars.v[1] -= '0'; 
....................  
.................... 	if (AsciiChars.v[0] > '9') 
.................... 		AsciiChars.v[0] -= 'A' - 10; 
.................... 	else 
.................... 		AsciiChars.v[0] -= '0'; 
....................  
.................... 	// Concatenate 
.................... 	return (AsciiChars.v[1] << 4) | AsciiChars.v[0]; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_high(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *               or 'A'-'F' that corresponds to the upper 4 bits of 
....................  *               the input byte. 
....................  *               ex: b = 0xAE, btohexa_high() returns 'A' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:         None 
....................  ********************************************************************/ 
.................... BYTE btohexa_high(BYTE b) { 
.................... 	b >>= 4; 
.................... 	return (b > 0x9) ? b + 'A' - 10 : b + '0'; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_low(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *               or 'A'-'F' that corresponds to the lower 4 bits of 
....................  *               the input byte. 
....................  *               ex: b = 0xAE, btohexa_low() returns 'E' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:         None 
....................  ********************************************************************/ 
.................... BYTE btohexa_low(BYTE b) { 
.................... 	b &= 0x0F; 
.................... 	return (b > 9) ? b + 'A' - 10 : b + '0'; 
.................... } 
....................  
.................... WORD swaps(WORD_VAL v) { 
.................... 	WORD_VAL new; 
....................  
.................... 	new.v[0] = v.v[1]; 
*
1254:  MOVFF  29A,29B
.................... 	new.v[1] = v.v[0]; 
1258:  MOVFF  299,29C
....................  
.................... 	return (new.Val); 
125C:  MOVLB  2
125E:  MOVFF  29B,01
1262:  MOVFF  29C,02
.................... } 
1266:  MOVLB  0
1268:  RETLW  00
....................  
.................... DWORD swapl(DWORD_VAL v) { 
.................... 	DWORD_VAL new; 
....................  
.................... 	new.v[0] = v.v[3]; 
*
2486:  MOVFF  285,286
.................... 	new.v[1] = v.v[2]; 
248A:  MOVFF  284,287
.................... 	new.v[2] = v.v[1]; 
248E:  MOVFF  283,288
.................... 	new.v[3] = v.v[0]; 
2492:  MOVFF  282,289
....................  
.................... 	return (new.Val); 
2496:  MOVFF  286,00
249A:  MOVFF  287,01
249E:  MOVFF  288,02
24A2:  MOVFF  289,03
.................... } 
24A6:  RETLW  00
....................  
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count) { 
.................... 	WORD i; 
.................... 	WORD *val; 
....................  
.................... 	union { 
.................... 		DWORD Val; 
.................... 		struct { 
.................... 			WORD_VAL LSB; 
.................... 			WORD_VAL MSB; 
.................... 		} words; 
.................... 	} tempSum, sum; 
....................  
.................... 	sum.Val = 0; 
*
2166:  MOVLB  2
2168:  CLRF   x8B
216A:  CLRF   x8A
216C:  CLRF   x89
216E:  CLRF   x88
....................  
.................... 	i = count >> 1; 
2170:  BCF    FD8.0
2172:  RRCF   x7F,W
2174:  MOVWF  x81
2176:  RRCF   x7E,W
2178:  MOVWF  x80
.................... 	val = (WORD *) buffer; 
217A:  MOVFF  27D,283
217E:  MOVFF  27C,282
....................  
.................... 	while (i--) 
.................... 		sum.Val += *val++; 
2182:  MOVFF  281,03
2186:  MOVF   x80,W
2188:  BTFSC  FD8.2
218A:  DECF   x81,F
218C:  DECF   x80,F
218E:  IORWF  03,W
2190:  BZ    21C0
2192:  MOVFF  283,03
2196:  MOVFF  282,00
219A:  MOVLW  02
219C:  ADDWF  x82,F
219E:  BTFSC  FD8.0
21A0:  INCF   x83,F
21A2:  MOVFF  00,FE9
21A6:  MOVFF  03,FEA
21AA:  MOVFF  FEC,03
21AE:  MOVF   FED,F
21B0:  MOVF   FEF,W
21B2:  ADDWF  x88,F
21B4:  MOVF   03,W
21B6:  ADDWFC x89,F
21B8:  MOVLW  00
21BA:  ADDWFC x8A,F
21BC:  ADDWFC x8B,F
21BE:  BRA    2182
....................  
.................... 	if (count & 1) 
21C0:  MOVF   x7E,W
21C2:  ANDLW  01
21C4:  MOVWF  00
21C6:  CLRF   03
21C8:  MOVF   00,W
21CA:  IORWF  03,W
21CC:  BZ    21E2
.................... 		sum.Val += *(BYTE *) val; 
21CE:  MOVFF  282,FE9
21D2:  MOVFF  283,FEA
21D6:  MOVF   FEF,W
21D8:  ADDWF  x88,F
21DA:  MOVLW  00
21DC:  ADDWFC x89,F
21DE:  ADDWFC x8A,F
21E0:  ADDWFC x8B,F
....................  
.................... 	tempSum.Val = sum.Val; 
21E2:  MOVFF  28B,287
21E6:  MOVFF  28A,286
21EA:  MOVFF  289,285
21EE:  MOVFF  288,284
.................... 	i = tempSum.words.MSB.Val; 
21F2:  MOVFF  287,281
21F6:  MOVFF  286,280
....................  
.................... 	while (i != 0u) { 
21FA:  MOVF   x80,F
21FC:  BNZ   2202
21FE:  MOVF   x81,F
2200:  BZ    2248
.................... 		sum.words.MSB.Val = 0; 
2202:  CLRF   x8B
2204:  CLRF   x8A
.................... 		sum.Val = (DWORD) sum.words.LSB.Val + (DWORD) i; 
2206:  CLRF   x8F
2208:  CLRF   x8E
220A:  MOVFF  289,28D
220E:  MOVFF  288,28C
2212:  CLRF   02
2214:  CLRF   03
2216:  MOVF   x80,W
2218:  ADDWF  x88,W
221A:  MOVWF  x88
221C:  MOVF   x81,W
221E:  ADDWFC x89,W
2220:  MOVWF  x89
2222:  MOVF   02,W
2224:  ADDWFC x8E,W
2226:  MOVWF  x8A
2228:  MOVF   03,W
222A:  ADDWFC x8F,W
222C:  MOVWF  x8B
.................... 		tempSum.Val = sum.Val; 
222E:  MOVFF  28B,287
2232:  MOVFF  28A,286
2236:  MOVFF  289,285
223A:  MOVFF  288,284
.................... 		i = tempSum.words.MSB.Val; 
223E:  MOVFF  287,281
2242:  MOVFF  286,280
.................... 	} 
2246:  BRA    21FA
....................  
.................... 	return (~sum.words.LSB.Val); 
2248:  MOVFF  289,03
224C:  COMF   03,F
224E:  MOVF   x88,W
2250:  XORLW  FF
2252:  MOVWF  01
2254:  MOVFF  03,02
.................... } 
2258:  MOVLB  0
225A:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  MAC buffer pointer set to starting of buffer 
....................  * 
....................  * Input:           len     - Total number of bytes to calculate 
....................  *                          checksum for. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs checksum calculation in 
....................  *                  MAC buffer itself. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if !defined(MCHP_MAC) 
.................... WORD CalcIPBufferChecksum(WORD len) { 
.................... 	BOOL lbMSB; 
.................... 	WORD_VAL checkSum; 
.................... 	BYTE Checkbyte; 
....................  
.................... 	lbMSB = TRUE; 
.................... 	checkSum.Val = 0; 
....................  
.................... 	while (len--) { 
.................... 		Checkbyte = MACGet(); 
....................  
.................... 		if (!lbMSB) { 
.................... 			if ((checkSum.v[0] = Checkbyte + checkSum.v[0]) < Checkbyte) { 
.................... 				if (++checkSum.v[1] == 0) 
.................... 					checkSum.v[0]++; 
.................... 			} 
.................... 		} 
.................... 		else { 
.................... 			if ((checkSum.v[1] = Checkbyte + checkSum.v[1]) < Checkbyte) { 
.................... 				if (++checkSum.v[0] == 0) 
.................... 					checkSum.v[1]++; 
.................... 			} 
.................... 		} 
....................  
.................... 		lbMSB = !lbMSB; 
.................... 	} 
....................  
.................... 	checkSum.v[1] = ~checkSum.v[1]; 
.................... 	checkSum.v[0] = ~checkSum.v[0]; 
.................... 	return checkSum.Val; 
.................... } 
.................... #endif 
....................  
.................... char itoc(BOOLEAN b) { 
.................... 	if (b) { 
.................... 		return '1'; 
.................... 	} 
.................... 	return '0'; 
.................... } 
....................  
.................... #include "tcpip/tick.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.c 
....................  * Dependencies:    stackTSK.h 
....................  *                  Tick.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    01/16/04 Intermediate counter vars added 
....................  * R. Shelquist (CCS)   09/23/04 TickGet() temporarily disables Timer0 interrupt 
....................  ********************************************************************/ 
....................  
.................... #define TICK_INCLUDE 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               12 // 10 original value (MiE) 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... TICKTYPE TickCount = 0;  //increment every 100ms 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void) 
.................... { 
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16); 
*
010E:  MOVLW  83
0110:  MOVWF  FD5
....................     set_timer0(TICK_COUNTER); 
0112:  MOVLW  9A
0114:  MOVWF  FD7
0116:  MOVLW  46
0118:  MOVWF  FD6
....................  
....................     enable_interrupts(INT_TIMER0); 
011A:  BSF    FF2.5
....................     enable_interrupts(GLOBAL); 
011C:  MOVLW  C0
011E:  IORWF  FF2,F
.................... } 
0120:  RETLW  00
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void) 
.................... { 
....................     int16 ret; 
....................     disable_interrupts(INT_TIMER0); 
*
10B0:  BCF    FF2.5
....................     ret=TickCount; 
10B2:  MOVFF  7C,241
10B6:  MOVFF  7B,240
....................     enable_interrupts(INT_TIMER0); 
10BA:  BSF    FF2.5
....................     return ret; 
10BC:  MOVLB  2
10BE:  MOVFF  240,01
10C2:  MOVFF  241,02
.................... } 
10C6:  MOVLB  0
10C8:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int8 second_counter=0;  //increment this every 1s 
.................... int8 second_counter_intermediate=0; 
....................  
.................... #if STACK_USE_PPP 
....................  int8 ppp_second_counter=0; 
....................  int8 ppp_second_counter_intermediate=0; 
.................... #endif 
....................  
.................... #int_timer0 
.................... void Tick_Isr(void) 
.................... { 
....................         TickCount++;    //increment this every 100ms 
*
00BA:  INCF   x7B,F
00BC:  BTFSC  FD8.2
00BE:  INCF   x7C,F
....................  
....................         second_counter_intermediate++; 
00C0:  INCF   x7E,F
....................         if (second_counter_intermediate >= TICKS_PER_SECOND) { 
00C2:  MOVF   x7E,W
00C4:  SUBLW  0B
00C6:  BC    00CC
....................             second_counter++; //increment this ever 1s 
00C8:  INCF   x7D,F
....................             second_counter_intermediate=0; 
00CA:  CLRF   x7E
....................         } 
....................  
....................  
....................        #if STACK_USE_PPP 
....................         ppp_second_counter_intermediate++; 
....................         if (ppp_second_counter_intermediate >= TICKS_PER_SECOND) { 
....................             ppp_second_counter_intermediate=0; 
....................             ppp_second_counter++; 
....................         } 
....................        #endif 
....................  
....................  
....................     set_timer0(TICK_COUNTER); //set timer0 to properly interrupt every 100ms 
00CC:  MOVLW  9A
00CE:  MOVWF  FD7
00D0:  MOVLW  46
00D2:  MOVWF  FD6
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //#define debug_stack 
.................... //#define debug_stack  debug_printf 
.................... #define debug_stack(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................  
.................... #if STACK_USE_MAC 
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/enc28j60.c" 
.................... /********************************************************************* 
....................  * 
....................  *     MAC Module (Microchip ENC28J60) for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.c 
....................  * Dependencies:    ENC28J60.h 
....................  *                    MAC.h 
....................  *                    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                    Delay.h 
....................  * Processor:       PIC18 
....................  * Complier:        MCC18 v3.00 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder      6/28/04   Original 
....................  * Howard Schlunder      10/8/04   Cleanup 
....................  * Howard Schlunder      10/19/04 Small optimizations and more cleanup 
....................  * Howard Schlunder      11/29/04 Added Set/GetCLKOUT 
....................  * Howard Schlunder      12/23/05 Added B1 silicon errata workarounds 
....................  * Howard Schlunder      1/09/06   Added comments and minor mods 
....................  * Howard Schlunder      1/18/06 Added more silicon errata workarounds 
....................  * Howard Schlunder      2/20/06 Fixed TXSTART, RXSTOP 
....................  * Darren Rook          7/11/06  CCS Port 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
.................... ********************************************************************/ 
.................... #define THIS_IS_MAC_LAYER 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/Helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/MAC.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if STACK_USE_SLIP 
.................... #error Unexpected module is detected. 
.................... #error This file must be linked when SLIP module is not in use. 
.................... #endif 
....................  
.................... #define debug_mac 
.................... //#define debug_mac debug_printf 
....................  
....................  
....................    #ifndef PIN_ENC_MAC_SO 
....................     
....................       #define  PIN_ENC_MAC_SO    PIN_C7   // Connect from PIN MISO to ENC28J60. 
....................      
....................       #define  PIN_ENC_MAC_SI    PIN_C6   // Connect from PIN MOSI to ENC28J60. 
....................      
....................       #define  PIN_ENC_MAC_CLK   PIN_D4   // Connect from PIN SCK to ENC28J60. 
....................      
....................       #define  PIN_ENC_MAC_CS    PIN_D3   // Connect from PIN CS to ENC28J60. 
....................      
....................       #define  PIN_ENC_MAC_RST   PIN_D2   // Connect from PIN RST to ENC28J60. 
....................  
....................        
....................       //#define PIN_ENC_MAC_INT PIN_B0 
....................       //#define PIN_ENC_MAC_WOL PIN_B1 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  *0xF93=(*0xF93 | 0b11); *0xF94 = (*0xF94 & 0b11010111) | 0x10; *0xF95=*0xF95 & 0xFC 
....................      #endif 
....................  
....................  
.................... #define ENC_MAC_USE_SPI FALSE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................                                    // MiE: SPI Hard is not working on SPI2. Soft is working OK on SPI2 
.................... #define mac_enc_spi_tris_init()      
....................  
.................... #define SPISelectEthernet()     output_low(PIN_ENC_MAC_CS)  //changed by ccs 
.................... #define SPIUnselectEthernet()   output_high(PIN_ENC_MAC_CS) //changed by ccs 
....................  
.................... /** D E F I N I T I O N S ****************************************************/ 
.................... /* Hardware interface to NIC. */ 
.................... //#define MCP_RESET_TRIS   (TRISB_RB5)   //CCS wont use these 
.................... //#define MCP_RESET_IO   (LATB5)          //CCS wont use these 
.................... //#define MCP_CS_TRIS      (TRISB_RB3)   //CCS wont use these 
.................... //#define MCP_CS_IO      (LATB3)          //CCS wont use these 
.................... // The following SPI pins are used but are not configurable 
.................... //   RC3 is used for the SCK pin and is an output 
.................... //   RC4 is used for the SDI pin and is an input 
.................... //   RC5 is used for the SDO pin and is an output 
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt 
.................... //      flag (PIR1_SSPIF) be clear at all times.  If the SPI is shared with 
.................... //      other hardware, the other code should clear the PIR1_SSPIF when it is 
.................... //      done using the SPI. 
....................  
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is 
.................... // not compatible with most switches/routers.  If a dedicated network is used 
.................... // where the duplex of the remote node can be manually configured, you may 
.................... // change this configuration.  Otherwise, half duplex should always be used. 
.................... #define HALF_DUPLEX 
.................... //#define FULL_DUPLEX 
.................... //#define LEDB_DUPLEX 
....................  
.................... // Pseudo Functions 
.................... #define LOW(a)                (a & 0xFF) 
.................... #define HIGH(a)             ((a>>8) & 0xFF) 
....................  
.................... // NIC RAM definitions 
.................... #define RAMSIZE   8192ul 
.................... #define TXSTART (RAMSIZE-(MAC_TX_BUFFER_COUNT * (MAC_TX_BUFFER_SIZE + 8ul))) 
.................... #define RXSTART   (0ul)                  // Should be an even memory address 
.................... #define RXSTOP   ((TXSTART-2ul) | 0x0001ul)   // Odd for errata workaround 
.................... #define RXSIZE   (RXSTOP-RXSTART+1ul) 
....................  
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address) 
.................... #define  WCR (0b010<<5)         // Write Control Register command 
.................... #define  BFS (0b100<<5)         // Bit Field Set command 
.................... #define  BFC (0b101<<5)         // Bit Field Clear command 
.................... #define  RCR (0b000<<5)         // Read Control Register command 
.................... #define  RBM ((0b001<<5) | 0x1A)   // Read Buffer Memory command 
.................... #define  WBM ((0b011<<5) | 0x1A) // Write Buffer Memory command 
.................... #define  SR  ((0b111<<5) | 0x1F)   // System Reset command does not use an address. 
....................                         //   It requires 0x1F, however. 
....................  
.................... #define ETHER_IP   (0x00u) 
.................... #define ETHER_ARP   (0x06u) 
....................  
.................... #define MAXFRAMEC   (1500u+sizeof(ETHER_HEADER)+4u) 
....................  
.................... // A generic structure representing the Ethernet header starting all Ethernet 
.................... // frames 
00D4:  BCF    FF2.2
00D6:  GOTO   006C
.................... typedef struct _ETHER_HEADER 
.................... { 
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ETHER_HEADER; 
....................  
.................... // A header appended at the start of all RX frames by the hardware 
.................... typedef struct _ENC_PREAMBLE 
.................... { 
....................     int16         NextPacketPointer; 
....................     RXSTATUS      StatusVector; 
....................  
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ENC_PREAMBLE; 
....................  
.................... typedef struct _DATA_BUFFER 
.................... { 
....................    WORD_VAL StartAddress; 
....................    WORD_VAL EndAddress; 
....................    struct 
....................    { 
....................       unsigned char bFree : 1; 
....................       unsigned char bTransmitted : 1; 
....................    } Flags; 
.................... } DATA_BUFFER; 
....................  
.................... void MACSetDuplex(DUPLEX DuplexState); 
....................  
.................... // Prototypes of functions intended for MAC layer use only. 
.................... static void BankSel(WORD Register); 
.................... static REG ReadETHReg(BYTE Address); 
.................... static REG ReadMACReg(BYTE Address); 
.................... static void WriteReg(BYTE Address, BYTE Data); 
.................... static void BFCReg(BYTE Address, BYTE Data); 
.................... static void BFSReg(BYTE Address, BYTE Data); 
.................... static void SendSystemReset(void); 
.................... //static void GetRegs(void); 
.................... #ifdef MAC_POWER_ON_TEST 
.................... static BOOL TestMemory(void); 
.................... #endif 
....................  
.................... /* Internal and externally used MAC level variables */ 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... #endif 
....................  
.................... // Internal and externally used MAC level variables. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... BUFFER LastTXedBuffer; 
.................... #endif 
....................  
....................  
.................... // Internal MAC level variables and flags. 
.................... WORD_VAL NextPacketLocation; 
.................... WORD_VAL CurrentPacketLocation; 
.................... BOOL WasDiscarded; 
.................... BYTE ENCRevID; 
....................  
.................... //ENCSPIInit() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... void ENCSPIInit(void) 
.................... { 
....................    mac_enc_spi_tris_init();  //MCP_RESET_TRIS = 0; 
....................  #if ENC_MAC_USE_SPI 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4); 
....................  #else 
....................    output_low(PIN_ENC_MAC_CLK); 
*
0122:  BCF    F95.4
0124:  BCF    F8C.4
....................    output_float(PIN_ENC_MAC_SO); 
0126:  BSF    F94.7
....................  #endif 
....................    // 
....................    // Set up the SPI module on the PIC for communications with the ENC28J60 
....................    // 
....................    SPIUnselectEthernet(); 
0128:  BCF    F95.3
012A:  BSF    F8C.3
....................  
....................    // Deassert the nRESET pin on the ENC28J60.  The internal 
....................    // weak pull on the nRESET pin will get the job done anyway, 
....................    // so this isn't necessary, but it may provide extra noise immunity, 
....................    // should someone put their finger on the pin or otherwise cause a leakage 
....................    // path to ground on this pin. 
....................    output_high(PIN_ENC_MAC_RST);            //MCP_RESET_IO = 1; 
012C:  BCF    F95.2
012E:  BSF    F8C.2
.................... } 
0130:  RETLW  00
....................  
.................... //ENCSPIXfer() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... char ENCSPIXfer(char c) 
.................... { 
....................  #if ENC_MAC_USE_SPI 
....................    return(spi_read(c)); 
....................  #else 
....................    int8 i, in; 
....................    for (i=0;i<8;i++) { 
0132:  MOVLB  2
0134:  CLRF   xB9
0136:  MOVF   xB9,W
0138:  SUBLW  07
013A:  BNC   0164
....................       output_bit(PIN_ENC_MAC_SI, shift_left(&c, 1, 0)); 
013C:  BCF    FD8.0
013E:  RLCF   xB8,F
0140:  BC    0146
0142:  BCF    F8B.6
0144:  BRA    0148
0146:  BSF    F8B.6
0148:  BCF    F94.6
....................       output_high(PIN_ENC_MAC_CLK); 
014A:  BCF    F95.4
014C:  BSF    F8C.4
....................       shift_left(&in, 1, input(PIN_ENC_MAC_SO)); 
014E:  BSF    F94.7
0150:  BTFSC  F82.7
0152:  BRA    0158
0154:  BCF    FD8.0
0156:  BRA    015A
0158:  BSF    FD8.0
015A:  RLCF   xBA,F
....................       output_low(PIN_ENC_MAC_CLK); 
015C:  BCF    F95.4
015E:  BCF    F8C.4
....................    } 
0160:  INCF   xB9,F
0162:  BRA    0136
....................    return(in); 
0164:  MOVFF  2BA,01
....................  #endif 
.................... } 
0168:  MOVLB  0
016A:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACInit sets up the PIC's SPI module and all the 
....................  *               registers in the ENC28J60 so that normal operation can 
....................  *               begin. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACInit(void) 
.................... { 
....................    BYTE i; 
....................  
....................    ENCSPIInit(); 
*
03F2:  RCALL  0122
....................  
....................    // Wait for CLKRDY to become set. 
....................    // Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that 
....................    // means the part is in RESET or otherwise our SPI pin is being driven 
....................    // incorrectly.  Make sure it is working before proceeding. 
....................    do 
....................    { 
....................       i = ReadETHReg(ESTAT).Val; 
03F4:  MOVLW  1D
03F6:  MOVLB  2
03F8:  MOVWF  xA9
03FA:  MOVLB  0
03FC:  RCALL  016C
03FE:  MOVFF  01,2A8
....................    } while((i & 0x08) || (~i & ESTAT_CLKRDY)); 
0402:  MOVLB  2
0404:  BTFSS  xA8.3
0406:  BRA    040C
0408:  MOVLB  0
040A:  BRA    03F4
040C:  MOVF   xA8,W
040E:  XORLW  FF
0410:  ANDLW  01
0412:  BTFSC  FD8.2
0414:  BRA    041A
0416:  MOVLB  0
0418:  BRA    03F4
....................  
....................  
.................... #ifdef MAC_POWER_ON_TEST 
....................    // Do the memory test and enter a while always trap if a hardware error 
....................    // occured.  The LEDA and LEDB pins will be configured to blink 
....................    // periodically in an abnormal manner to indicate to the user that the 
....................    // error occured. 
....................    if( !TestMemory() ) 
....................    { 
....................       SetLEDConfig(0x0AA2);      // Set LEDs to blink periodically 
....................       while(1); 
....................    } 
.................... #endif 
....................  
....................    // RESET the entire ENC28J60, clearing all registers 
....................    SendSystemReset(); 
041A:  MOVLB  0
041C:  RCALL  0196
....................     delay_ms(1); 
041E:  MOVLW  01
0420:  MOVLB  2
0422:  MOVWF  xA9
0424:  MOVLB  0
0426:  RCALL  00E6
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................     // On Init, all transmit buffers are free. 
....................     for (i = 0; i < MAC_TX_BUFFER_COUNT; i++ ) 
....................     { 
....................         TxBuffers[i].StartAddress.Val = TXSTART + ((WORD)i * (MAC_TX_BUFFER_SIZE+8)); 
....................         TxBuffers[i].Flags.bFree = TRUE; 
....................     } 
.................... #endif 
....................     CurrentTxBuffer = 0; 
0428:  CLRF   x7A
....................  
....................    // Start up in Bank 0 and configure the receive buffer boundary pointers 
....................    // and the buffer write protect pointer (receive buffer read pointer) 
....................    WasDiscarded = TRUE; 
042A:  BSF    x83.0
....................    NextPacketLocation.Val = RXSTART; 
042C:  CLRF   x80
042E:  CLRF   x7F
....................    WriteReg(ERXSTL, LOW(RXSTART)); 
0430:  MOVLW  08
0432:  MOVLB  2
0434:  MOVWF  xB3
0436:  CLRF   xB4
0438:  MOVLB  0
043A:  RCALL  01AA
....................    WriteReg(ERXSTH, HIGH(RXSTART)); 
043C:  MOVLW  09
043E:  MOVLB  2
0440:  MOVWF  xB3
0442:  CLRF   xB4
0444:  MOVLB  0
0446:  RCALL  01AA
....................    WriteReg(ERXRDPTL, LOW(RXSTOP));   // Write low byte first 
0448:  MOVLW  0C
044A:  MOVLB  2
044C:  MOVWF  xB3
044E:  MOVLW  F7
0450:  MOVWF  xB4
0452:  MOVLB  0
0454:  RCALL  01AA
....................    WriteReg(ERXRDPTH, HIGH(RXSTOP));   // Write high byte last 
0456:  MOVLW  0D
0458:  MOVLB  2
045A:  MOVWF  xB3
045C:  MOVLW  1B
045E:  MOVWF  xB4
0460:  MOVLB  0
0462:  RCALL  01AA
.................... #if RXSTOP != 0x1FFF   // The RESET default ERXND is 0x1FFF 
....................    WriteReg(ERXNDL, LOW(RXSTOP)); 
0464:  MOVLW  0A
0466:  MOVLB  2
0468:  MOVWF  xB3
046A:  MOVLW  F7
046C:  MOVWF  xB4
046E:  MOVLB  0
0470:  RCALL  01AA
....................    WriteReg(ERXNDH, HIGH(RXSTOP)); 
0472:  MOVLW  0B
0474:  MOVLB  2
0476:  MOVWF  xB3
0478:  MOVLW  1B
047A:  MOVWF  xB4
047C:  MOVLB  0
047E:  RCALL  01AA
.................... #endif 
.................... #if TXSTART != 0      // The RESET default ETXST is 0 
....................    WriteReg(ETXSTL, LOW(TXSTART)); 
0480:  MOVLW  04
0482:  MOVLB  2
0484:  MOVWF  xB3
0486:  MOVLW  F8
0488:  MOVWF  xB4
048A:  MOVLB  0
048C:  RCALL  01AA
....................    WriteReg(ETXSTH, HIGH(TXSTART)); 
048E:  MOVLW  05
0490:  MOVLB  2
0492:  MOVWF  xB3
0494:  MOVLW  1B
0496:  MOVWF  xB4
0498:  MOVLB  0
049A:  RCALL  01AA
.................... #endif 
....................  
....................    // Enter Bank 1 and configure Receive Filters 
....................    // (No need to reconfigure - Unicast OR Broadcast with CRC checking is 
....................    // acceptable) 
....................    // Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode 
....................    //BankSel(ERXFCON); 
....................    //WriteReg((BYTE)ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN | ERXFCON_HTEN); 
....................  
....................    // Enter Bank 2 and configure the MAC 
....................    BankSel(MACON1); 
049C:  MOVLW  02
049E:  MOVLB  2
04A0:  MOVWF  xB1
04A2:  CLRF   xB0
04A4:  MOVLB  0
04A6:  RCALL  0204
....................  
....................    // Enable the receive portion of the MAC 
....................    WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN); 
04A8:  MOVLB  2
04AA:  CLRF   xB3
04AC:  MOVLW  0D
04AE:  MOVWF  xB4
04B0:  MOVLB  0
04B2:  RCALL  01AA
....................  
....................    // Pad packets to 60 bytes, add CRC, and check Type/Length field. 
....................    WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN); 
04B4:  MOVLW  02
04B6:  MOVLB  2
04B8:  MOVWF  xB3
04BA:  MOVLW  32
04BC:  MOVWF  xB4
04BE:  MOVLB  0
04C0:  RCALL  01AA
....................  
....................     // Allow infinite deferals if the medium is continuously busy 
....................     // (do not time out a transmission if the half duplex medium is 
....................     // completely saturated with other people's data) 
....................     WriteReg((BYTE)MACON4, MACON4_DEFER); 
04C2:  MOVLW  03
04C4:  MOVLB  2
04C6:  MOVWF  xB3
04C8:  MOVLW  40
04CA:  MOVWF  xB4
04CC:  MOVLB  0
04CE:  RCALL  01AA
....................  
....................    // Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter) 
....................    // 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
....................    // collisions will occur less often with a larger number. 
....................     WriteReg((BYTE)MACLCON2, 63); 
04D0:  MOVLW  09
04D2:  MOVLB  2
04D4:  MOVWF  xB3
04D6:  MOVLW  3F
04D8:  MOVWF  xB4
04DA:  MOVLB  0
04DC:  RCALL  01AA
....................  
....................    // Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
....................    // inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
....................    // later. 
....................    WriteReg((BYTE)MAIPGL, 0x12); 
04DE:  MOVLW  06
04E0:  MOVLB  2
04E2:  MOVWF  xB3
04E4:  MOVLW  12
04E6:  MOVWF  xB4
04E8:  MOVLB  0
04EA:  RCALL  01AA
....................    WriteReg((BYTE)MAIPGH, 0x0C); 
04EC:  MOVLW  07
04EE:  MOVLB  2
04F0:  MOVWF  xB3
04F2:  MOVLW  0C
04F4:  MOVWF  xB4
04F6:  MOVLB  0
04F8:  RCALL  01AA
....................  
....................    // Set the maximum packet size which the controller will accept 
....................    WriteReg((BYTE)MAMXFLL, LOW(MAXFRAMEC)); 
04FA:  MOVLW  0A
04FC:  MOVLB  2
04FE:  MOVWF  xB3
0500:  MOVLW  EE
0502:  MOVWF  xB4
0504:  MOVLB  0
0506:  RCALL  01AA
....................    WriteReg((BYTE)MAMXFLH, HIGH(MAXFRAMEC)); 
0508:  MOVLW  0B
050A:  MOVLB  2
050C:  MOVWF  xB3
050E:  MOVLW  05
0510:  MOVWF  xB4
0512:  MOVLB  0
0514:  RCALL  01AA
....................  
....................     // Enter Bank 3 and initialize physical MAC address registers 
....................    BankSel(MAADR1); 
0516:  MOVLW  03
0518:  MOVLB  2
051A:  MOVWF  xB1
051C:  MOVLW  04
051E:  MOVWF  xB0
0520:  MOVLB  0
0522:  RCALL  0204
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]); 
0524:  MOVLW  04
0526:  MOVLB  2
0528:  MOVWF  xB3
052A:  MOVFF  47,2B4
052E:  MOVLB  0
0530:  RCALL  01AA
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]); 
0532:  MOVLW  05
0534:  MOVLB  2
0536:  MOVWF  xB3
0538:  MOVFF  48,2B4
053C:  MOVLB  0
053E:  RCALL  01AA
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]); 
0540:  MOVLW  02
0542:  MOVLB  2
0544:  MOVWF  xB3
0546:  MOVFF  49,2B4
054A:  MOVLB  0
054C:  RCALL  01AA
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]); 
054E:  MOVLW  03
0550:  MOVLB  2
0552:  MOVWF  xB3
0554:  MOVFF  4A,2B4
0558:  MOVLB  0
055A:  RCALL  01AA
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]); 
055C:  MOVLB  2
055E:  CLRF   xB3
0560:  MOVFF  4B,2B4
0564:  MOVLB  0
0566:  RCALL  01AA
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]); 
0568:  MOVLW  01
056A:  MOVLB  2
056C:  MOVWF  xB3
056E:  MOVFF  4C,2B4
0572:  MOVLB  0
0574:  RCALL  01AA
....................  
....................    // Get the Rev ID so that we can implement the correct errata workarounds 
....................    ENCRevID = ReadETHReg((BYTE)EREVID).Val; 
0576:  MOVLW  12
0578:  MOVLB  2
057A:  MOVWF  xA9
057C:  MOVLB  0
057E:  RCALL  016C
0580:  MOVFF  01,84
....................  
....................    // Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a 
....................    // side effect. 
....................    WritePHYReg(PHCON2, PHCON2_HDLDIS); 
0584:  MOVLW  10
0586:  MOVLB  2
0588:  MOVWF  xAD
058A:  MOVLW  01
058C:  MOVWF  xAF
058E:  CLRF   xAE
0590:  MOVLB  0
0592:  RCALL  0260
....................  
....................    // Configure LEDA to display LINK status, LEDB to display TX/RX activity 
....................    SetLEDConfig(0x0472); 
0594:  MOVLW  14
0596:  MOVLB  2
0598:  MOVWF  xAD
059A:  MOVLW  04
059C:  MOVWF  xAF
059E:  MOVLW  72
05A0:  MOVWF  xAE
05A2:  MOVLB  0
05A4:  RCALL  0260
....................  
....................    // Set the MAC and PHY into the proper duplex state 
.................... #if defined(FULL_DUPLEX) 
....................    MACSetDuplex(FULL);      // Function exits with Bank 2 selected 
.................... #elif defined(HALF_DUPLEX) 
....................    MACSetDuplex(HALF);      // Function exits with Bank 2 selected 
05A6:  MOVLB  2
05A8:  CLRF   xA9
05AA:  MOVLB  0
05AC:  RCALL  0358
.................... #else 
....................    // Use the external LEDB polarity to determine weather full or half duplex 
....................    // communication mode should be set. 
....................    MACSetDuplex(USE_PHY);   // Function exits with Bank 2 selected 
.................... #endif 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
05AE:  MOVLW  1F
05B0:  MOVLB  2
05B2:  MOVWF  xB5
05B4:  MOVLW  04
05B6:  MOVWF  xB6
05B8:  MOVLB  0
05BA:  RCALL  01E6
.................... }//end MACInit 
05BC:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsLinked(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If the PHY reports that a link partner is present 
....................  *                    and the link has been up continuously since the last 
....................  *                    call to MACIsLinked() 
....................  *               FALSE: If the PHY reports no link partner, or the link went 
....................  *                     down momentarily since the last call to MACIsLinked() 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsLinked(void) 
.................... { 
....................    // LLSTAT is a latching low link status bit.  Therefore, if the link 
....................    // goes down and comes back up before a higher level stack program calls 
....................    // MACIsLinked(), MACIsLinked() will still return FALSE.  The next 
....................    // call to MACIsLinked() will return TRUE (unless the link goes down 
....................    // again). 
....................    return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT; 
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           HighPriority: TRUE: Check the hardware ECON1.TXRTS bit 
....................  *                          FALSE: Check if a TX buffer is free 
....................  * 
....................  * Output:          TRUE: If no Ethernet transmission is in progress 
....................  *               FALSE: If a previous transmission was started, and it has 
....................  *                     not completed yet.  While FALSE, the data in the 
....................  *                     transmit buffer and the TXST/TXND pointers must not 
....................  *                     be changed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the ECON1.TXRTS bit 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsTxReady(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
*
29CE:  CLRF   19
29D0:  BTFSC  FF2.7
29D2:  BSF    19.7
29D4:  BCF    FF2.7
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
29D6:  MOVLW  1F
29D8:  MOVLB  2
29DA:  MOVWF  xA9
29DC:  MOVLB  0
29DE:  CALL   016C
29E2:  BTFSC  19.7
29E4:  BSF    FF2.7
29E6:  MOVLW  00
29E8:  BTFSS  01.3
29EA:  MOVLW  01
29EC:  MOVWF  01
29EE:  BRA    29F0
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................  
....................    // Check if the current buffer can be modified.  It cannot be modified if 
....................    // the TX hardware is currently transmitting it. 
....................    if(CurrentTxBuffer == LastTXedBuffer) 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
....................    } 
....................  
....................    // Check if a buffer is available for a new packet 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          return TRUE; 
....................       } 
....................    } 
....................  
....................    return FALSE; 
.................... #endif 
.................... } 
29F0:  RETLW  00
....................  
.................... BUFFER MACGetTxBuffer(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
*
159C:  CLRF   19
159E:  BTFSC  FF2.7
15A0:  BSF    19.7
15A2:  BCF    FF2.7
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................       return !ReadETHReg(ECON1).ECON1bits.TXRTS ? 0 : INVALID_BUFFER; 
15A4:  MOVLW  1F
15A6:  MOVLB  2
15A8:  MOVWF  xA9
15AA:  MOVLB  0
15AC:  CALL   016C
15B0:  BTFSC  19.7
15B2:  BSF    FF2.7
15B4:  BTFSC  01.3
15B6:  BRA    15BC
15B8:  MOVLW  00
15BA:  BRA    15BE
15BC:  MOVLW  FF
15BE:  MOVWF  01
15C0:  BRA    15C2
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Find a free buffer.  Do not use buffer 0, it is reserved for 
....................    // high priority messages that don't need to be acknowledged 
....................    // before being discarded (TCP control packets, all ICMP 
....................    // packets, all UDP packets, etc.) 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       // If this buffer is free, then mark it as used and return with it 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          TxBuffers[i].Flags.bFree = FALSE; 
....................          TxBuffers[i].Flags.bTransmitted = FALSE; 
....................          return i; 
....................       } 
....................    } 
....................  
....................    return INVALID_BUFFER; 
.................... #endif 
.................... } 
15C2:  RETLW  00
....................  
....................  
.................... void MACDiscardTx(BUFFER buffer) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    if(buffer < sizeof(TxBuffers)/sizeof(TxBuffers[0])) 
....................    { 
....................        TxBuffers[buffer].Flags.bFree = TRUE; 
....................        CurrentTxBuffer = buffer; 
....................    } 
.................... #endif 
.................... } 
*
0004:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDiscardRx(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Marks the last received packet (obtained using 
....................  *               MACGetHeader())as being processed and frees the buffer 
....................  *               memory associated with it 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDiscardRx(void) 
.................... { 
....................    WORD_VAL NewRXRDLocation; 
....................  
....................    // Make sure the current packet was not already discarded 
....................    if( WasDiscarded ) 
*
1138:  BTFSS  x83.0
113A:  BRA    113E
....................       return; 
113C:  BRA    11D6
....................    WasDiscarded = TRUE; 
113E:  BSF    x83.0
....................  
....................    // Decrement the next packet pointer before writing it into 
....................    // the ERXRDPT registers.  This is a silicon errata workaround. 
....................    // RX buffer wrapping must be taken into account if the 
....................    // NextPacketLocation is precisely RXSTART. 
....................    NewRXRDLocation.Val = NextPacketLocation.Val - 1; 
1140:  MOVLW  01
1142:  SUBWF  x7F,W
1144:  MOVLB  2
1146:  MOVWF  x40
1148:  MOVLW  00
114A:  MOVLB  0
114C:  SUBWFB x80,W
114E:  MOVLB  2
1150:  MOVWF  x41
.................... #if RXSTART == 0 
....................    if(NewRXRDLocation.Val > RXSTOP) 
1152:  MOVF   x41,W
1154:  SUBLW  1A
1156:  BC    116A
1158:  XORLW  FF
115A:  BNZ   1162
115C:  MOVF   x40,W
115E:  SUBLW  F7
1160:  BC    116A
.................... #else 
....................    if(NewRXRDLocation.Val < RXSTART || NewRXRDLocation.Val > RXSTOP) 
.................... #endif 
....................    { 
....................       NewRXRDLocation.Val = RXSTOP; 
1162:  MOVLW  1B
1164:  MOVWF  x41
1166:  MOVLW  F7
1168:  MOVWF  x40
116A:  CLRF   19
116C:  BTFSC  FF2.7
116E:  BSF    19.7
1170:  BCF    FF2.7
....................    } 
....................  
....................    // Decrement the RX packet counter register, EPKTCNT 
....................    BFSReg(ECON2, ECON2_PKTDEC); 
1172:  MOVLW  1E
1174:  MOVWF  xB5
1176:  MOVLW  40
1178:  MOVWF  xB6
117A:  MOVLB  0
117C:  CALL   01E6
1180:  BTFSC  19.7
1182:  BSF    FF2.7
1184:  CLRF   19
1186:  BTFSC  FF2.7
1188:  BSF    19.7
118A:  BCF    FF2.7
....................  
....................    // Move the receive read pointer to unwrite-protect the memory used by the 
....................    // last packet.  The writing order is important: set the low byte first, 
....................    // high byte last. 
....................    BankSel(ERXRDPTL); 
118C:  MOVLB  2
118E:  CLRF   xB1
1190:  MOVLW  0C
1192:  MOVWF  xB0
1194:  MOVLB  0
1196:  CALL   0204
119A:  BTFSC  19.7
119C:  BSF    FF2.7
119E:  CLRF   19
11A0:  BTFSC  FF2.7
11A2:  BSF    19.7
11A4:  BCF    FF2.7
....................    WriteReg(ERXRDPTL, NewRXRDLocation.v[0]); 
11A6:  MOVLW  0C
11A8:  MOVLB  2
11AA:  MOVWF  xB3
11AC:  MOVFF  240,2B4
11B0:  MOVLB  0
11B2:  CALL   01AA
11B6:  BTFSC  19.7
11B8:  BSF    FF2.7
11BA:  CLRF   19
11BC:  BTFSC  FF2.7
11BE:  BSF    19.7
11C0:  BCF    FF2.7
....................    WriteReg(ERXRDPTH, NewRXRDLocation.v[1]); 
11C2:  MOVLW  0D
11C4:  MOVLB  2
11C6:  MOVWF  xB3
11C8:  MOVFF  241,2B4
11CC:  MOVLB  0
11CE:  CALL   01AA
11D2:  BTFSC  19.7
11D4:  BSF    FF2.7
.................... } 
11D6:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetFreeRxSize(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A WORD estimate of how much RX buffer space is free at 
....................  *               the present time. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetFreeRxSize(void) 
.................... { 
*
29F2:  CLRF   19
29F4:  BTFSC  FF2.7
29F6:  BSF    19.7
29F8:  BCF    FF2.7
....................    WORD_VAL ReadPT, WritePT; 
....................  
....................    // Read the Ethernet hardware buffer write pointer.  Because packets can be 
....................    // received at any time, it can change between reading the low and high 
....................    // bytes.  A loop is necessary to make certain a proper low/high byte pair 
....................    // is read. 
....................    BankSel(EPKTCNT); 
29FA:  MOVLW  01
29FC:  MOVLB  2
29FE:  MOVWF  xB1
2A00:  MOVLW  19
2A02:  MOVWF  xB0
2A04:  MOVLB  0
2A06:  CALL   0204
2A0A:  BTFSC  19.7
2A0C:  BSF    FF2.7
2A0E:  CLRF   19
2A10:  BTFSC  FF2.7
2A12:  BSF    19.7
2A14:  BCF    FF2.7
....................    do { 
....................       // Save EPKTCNT in a temporary location 
....................       ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val; 
2A16:  MOVLW  19
2A18:  MOVLB  2
2A1A:  MOVWF  xA9
2A1C:  MOVLB  0
2A1E:  CALL   016C
2A22:  BTFSC  19.7
2A24:  BSF    FF2.7
2A26:  MOVFF  01,27A
2A2A:  CLRF   19
2A2C:  BTFSC  FF2.7
2A2E:  BSF    19.7
2A30:  BCF    FF2.7
....................  
....................       BankSel(ERXWRPTL); 
2A32:  MOVLB  2
2A34:  CLRF   xB1
2A36:  MOVLW  0E
2A38:  MOVWF  xB0
2A3A:  MOVLB  0
2A3C:  CALL   0204
2A40:  BTFSC  19.7
2A42:  BSF    FF2.7
2A44:  CLRF   19
2A46:  BTFSC  FF2.7
2A48:  BSF    19.7
2A4A:  BCF    FF2.7
....................       WritePT.v[0] = ReadETHReg(ERXWRPTL).Val; 
2A4C:  MOVLW  0E
2A4E:  MOVLB  2
2A50:  MOVWF  xA9
2A52:  MOVLB  0
2A54:  CALL   016C
2A58:  BTFSC  19.7
2A5A:  BSF    FF2.7
2A5C:  MOVFF  01,27C
2A60:  CLRF   19
2A62:  BTFSC  FF2.7
2A64:  BSF    19.7
2A66:  BCF    FF2.7
....................       WritePT.v[1] = ReadETHReg(ERXWRPTH).Val; 
2A68:  MOVLW  0F
2A6A:  MOVLB  2
2A6C:  MOVWF  xA9
2A6E:  MOVLB  0
2A70:  CALL   016C
2A74:  BTFSC  19.7
2A76:  BSF    FF2.7
2A78:  MOVFF  01,27D
2A7C:  CLRF   19
2A7E:  BTFSC  FF2.7
2A80:  BSF    19.7
2A82:  BCF    FF2.7
....................  
....................       BankSel(EPKTCNT); 
2A84:  MOVLW  01
2A86:  MOVLB  2
2A88:  MOVWF  xB1
2A8A:  MOVLW  19
2A8C:  MOVWF  xB0
2A8E:  MOVLB  0
2A90:  CALL   0204
2A94:  BTFSC  19.7
2A96:  BSF    FF2.7
2A98:  CLRF   19
2A9A:  BTFSC  FF2.7
2A9C:  BSF    19.7
2A9E:  BCF    FF2.7
....................    } while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]); 
2AA0:  MOVLW  19
2AA2:  MOVLB  2
2AA4:  MOVWF  xA9
2AA6:  MOVLB  0
2AA8:  CALL   016C
2AAC:  BTFSC  19.7
2AAE:  BSF    FF2.7
2AB0:  MOVLB  2
2AB2:  MOVF   x7A,W
2AB4:  SUBWF  01,W
2AB6:  BTFSC  FD8.2
2AB8:  BRA    2ABE
2ABA:  MOVLB  0
2ABC:  BRA    2A0E
2ABE:  CLRF   19
2AC0:  BTFSC  FF2.7
2AC2:  BSF    19.7
2AC4:  BCF    FF2.7
....................  
....................    // Determine where the write protection pointer is 
....................    BankSel(ERXRDPTL); 
2AC6:  CLRF   xB1
2AC8:  MOVLW  0C
2ACA:  MOVWF  xB0
2ACC:  MOVLB  0
2ACE:  CALL   0204
2AD2:  BTFSC  19.7
2AD4:  BSF    FF2.7
2AD6:  CLRF   19
2AD8:  BTFSC  FF2.7
2ADA:  BSF    19.7
2ADC:  BCF    FF2.7
....................    ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val; 
2ADE:  MOVLW  0C
2AE0:  MOVLB  2
2AE2:  MOVWF  xA9
2AE4:  MOVLB  0
2AE6:  CALL   016C
2AEA:  BTFSC  19.7
2AEC:  BSF    FF2.7
2AEE:  MOVFF  01,27A
2AF2:  CLRF   19
2AF4:  BTFSC  FF2.7
2AF6:  BSF    19.7
2AF8:  BCF    FF2.7
....................    ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val; 
2AFA:  MOVLW  0D
2AFC:  MOVLB  2
2AFE:  MOVWF  xA9
2B00:  MOVLB  0
2B02:  CALL   016C
2B06:  BTFSC  19.7
2B08:  BSF    FF2.7
2B0A:  MOVFF  01,27B
....................  
....................    // Calculate the difference between the pointers, taking care to account 
....................    // for buffer wrapping conditions 
....................    if ( WritePT.Val > ReadPT.Val ) 
2B0E:  MOVLB  2
2B10:  MOVF   x7B,W
2B12:  SUBWF  x7D,W
2B14:  BNC   2B42
2B16:  BNZ   2B1E
2B18:  MOVF   x7C,W
2B1A:  SUBWF  x7A,W
2B1C:  BC    2B42
....................    { 
....................       return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val); 
2B1E:  MOVF   x7A,W
2B20:  SUBWF  x7C,W
2B22:  MOVWF  00
2B24:  MOVF   x7B,W
2B26:  SUBWFB x7D,W
2B28:  MOVWF  03
2B2A:  MOVF   00,W
2B2C:  XORLW  FF
2B2E:  ADDLW  F8
2B30:  MOVWF  00
2B32:  MOVLW  1B
2B34:  SUBFWB 03,F
2B36:  MOVFF  00,01
2B3A:  MOVFF  03,02
2B3E:  BRA    2B7A
....................    } 
....................    else if ( WritePT.Val == ReadPT.Val ) 
2B40:  BRA    2B7A
2B42:  MOVF   x7A,W
2B44:  SUBWF  x7C,W
2B46:  BNZ   2B5A
2B48:  MOVF   x7B,W
2B4A:  SUBWF  x7D,W
2B4C:  BNZ   2B5A
....................    { 
....................       return RXSIZE - 1; 
2B4E:  MOVLW  F7
2B50:  MOVWF  01
2B52:  MOVLW  1B
2B54:  MOVWF  02
2B56:  BRA    2B7A
....................    } 
....................    else 
2B58:  BRA    2B7A
....................     { 
....................       return ReadPT.Val - WritePT.Val - 1; 
2B5A:  MOVF   x7C,W
2B5C:  SUBWF  x7A,W
2B5E:  MOVWF  x7E
2B60:  MOVF   x7D,W
2B62:  SUBWFB x7B,W
2B64:  MOVWF  x7F
2B66:  MOVLW  01
2B68:  SUBWF  x7E,W
2B6A:  MOVWF  00
2B6C:  MOVLW  00
2B6E:  SUBWFB x7F,W
2B70:  MOVWF  03
2B72:  MOVFF  00,01
2B76:  MOVWF  02
2B78:  BRA    2B7A
....................    } 
.................... } 
2B7A:  MOVLB  0
2B7C:  GOTO   2E64 (RETURN)
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           *remote: Location to store the Source MAC address of the 
....................  *                      received frame. 
....................  *               *type: Location of a BYTE to store the constant 
....................  *                     MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing 
....................  *                     the contents of the Ethernet type field. 
....................  * 
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The 
....................  *                    remote, and type values are updated. 
....................  *               FALSE: If a packet was not pending.  remote and type are 
....................  *                     not changed. 
....................  * 
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already 
....................  *               been called. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
.................... { 
*
126A:  CLRF   19
126C:  BTFSC  FF2.7
126E:  BSF    19.7
1270:  BCF    FF2.7
....................    ENC_PREAMBLE header; 
....................  
....................    // Test if at least one packet has been received and is waiting 
....................    BankSel(EPKTCNT); 
1272:  MOVLW  01
1274:  MOVLB  2
1276:  MOVWF  xB1
1278:  MOVLW  19
127A:  MOVWF  xB0
127C:  MOVLB  0
127E:  CALL   0204
1282:  BTFSC  19.7
1284:  BSF    FF2.7
1286:  CLRF   19
1288:  BTFSC  FF2.7
128A:  BSF    19.7
128C:  BCF    FF2.7
....................    if(ReadETHReg((BYTE)EPKTCNT).Val == 0) 
128E:  MOVLW  19
1290:  MOVLB  2
1292:  MOVWF  xA9
1294:  MOVLB  0
1296:  CALL   016C
129A:  BTFSC  19.7
129C:  BSF    FF2.7
129E:  MOVF   01,F
12A0:  BNZ   12A8
....................       return FALSE; 
12A2:  MOVLW  00
12A4:  MOVWF  01
12A6:  BRA    13DC
....................  
....................    // Make absolutely certain that any previous packet was discarded 
....................    if(WasDiscarded == FALSE) 
12A8:  BTFSC  x83.0
12AA:  BRA    12B4
....................    { 
....................       MACDiscardRx(); 
12AC:  RCALL  1138
....................       return FALSE; 
12AE:  MOVLW  00
12B0:  MOVWF  01
12B2:  BRA    13DC
....................    } 
....................  
....................    // Save the location of this packet 
....................    CurrentPacketLocation.Val = NextPacketLocation.Val; 
12B4:  MOVFF  80,82
12B8:  MOVFF  7F,81
12BC:  CLRF   19
12BE:  BTFSC  FF2.7
12C0:  BSF    19.7
12C2:  BCF    FF2.7
....................  
....................    // Set the SPI read pointer to the beginning of the next unprocessed packet 
....................    BankSel(ERDPTL); 
12C4:  MOVLB  2
12C6:  CLRF   xB1
12C8:  CLRF   xB0
12CA:  MOVLB  0
12CC:  CALL   0204
12D0:  BTFSC  19.7
12D2:  BSF    FF2.7
12D4:  CLRF   19
12D6:  BTFSC  FF2.7
12D8:  BSF    19.7
12DA:  BCF    FF2.7
....................    WriteReg(ERDPTL, NextPacketLocation.v[0]); 
12DC:  MOVLB  2
12DE:  CLRF   xB3
12E0:  MOVFF  7F,2B4
12E4:  MOVLB  0
12E6:  CALL   01AA
12EA:  BTFSC  19.7
12EC:  BSF    FF2.7
12EE:  CLRF   19
12F0:  BTFSC  FF2.7
12F2:  BSF    19.7
12F4:  BCF    FF2.7
....................    WriteReg(ERDPTH, NextPacketLocation.v[1]); 
12F6:  MOVLW  01
12F8:  MOVLB  2
12FA:  MOVWF  xB3
12FC:  MOVFF  80,2B4
1300:  MOVLB  0
1302:  CALL   01AA
1306:  BTFSC  19.7
1308:  BSF    FF2.7
....................  
....................    // Obtain the MAC header from the Ethernet buffer 
....................    MACGetArray((BYTE*)&header, sizeof(header)); 
130A:  MOVLW  01
130C:  MOVLB  2
130E:  MOVWF  x0D
1310:  MOVLW  F8
1312:  MOVFF  20D,289
1316:  MOVWF  x88
1318:  CLRF   x8B
131A:  MOVLW  14
131C:  MOVWF  x8A
131E:  MOVLB  0
1320:  RCALL  11D8
....................  
....................    // The EtherType field, like most items transmitted on the Ethernet medium 
....................    // are in big endian. 
....................     header.Type.Val = swaps(header.Type.Val); 
1322:  MOVFF  20B,29A
1326:  MOVFF  20A,299
132A:  RCALL  1254
132C:  MOVFF  02,20B
1330:  MOVFF  01,20A
....................  
....................    // Validate the data returned from the ENC28J60.  Random data corruption, 
....................    // such as if a single SPI bit error occurs while communicating or a 
....................    // momentary power glitch could cause this to occur in rare circumstances. 
....................    if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 || 
....................       header.StatusVector.bits.Zero || 
....................       header.StatusVector.bits.CRCError || 
....................       header.StatusVector.bits.ByteCount > 1518 || 
....................       !header.StatusVector.bits.ReceiveOk) 
1334:  MOVLB  1
1336:  MOVF   xF9,W
1338:  SUBLW  1A
133A:  BC    1346
133C:  XORLW  FF
133E:  BNZ   136E
1340:  MOVF   xF8,W
1342:  SUBLW  F7
1344:  BNC   136E
1346:  MOVLW  01
1348:  MOVWF  FEA
134A:  MOVLW  F8
134C:  MOVWF  FE9
134E:  BTFSC  FEF.0
1350:  BRA    136E
1352:  BTFSC  xFD.7
1354:  BRA    136E
1356:  BTFSC  xFC.4
1358:  BRA    136E
135A:  MOVF   xFB,W
135C:  SUBLW  04
135E:  BC    136A
1360:  XORLW  FF
1362:  BNZ   136E
1364:  MOVF   xFA,W
1366:  SUBLW  EE
1368:  BNC   136E
136A:  BTFSC  xFC.7
136C:  BRA    1370
....................    { 
....................       //Reset(); 
....................       reset_cpu(); 
136E:  RESET
....................    } 
....................  
....................    // Save the location where the hardware will write the next packet to 
....................    NextPacketLocation.Val = header.NextPacketPointer; 
1370:  MOVFF  1F9,80
1374:  MOVFF  1F8,7F
....................  
....................    // Return the Ethernet frame's Source MAC address field to the caller 
....................    // This parameter is useful for replying to requests without requiring an 
....................    // ARP cycle. 
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote)); 
1378:  MOVFF  1F5,03
137C:  MOVFF  1F4,20C
1380:  MOVLB  2
1382:  MOVFF  1F5,20D
1386:  MOVFF  1F5,FEA
138A:  MOVFF  1F4,FE9
138E:  MOVLW  02
1390:  MOVWF  FE2
1392:  MOVLW  04
1394:  MOVWF  FE1
1396:  MOVLW  06
1398:  MOVWF  01
139A:  MOVFF  FE6,FEE
139E:  DECFSZ 01,F
13A0:  BRA    139A
....................  
....................    // Return a simplified version of the EtherType field to the caller 
....................     *type = MAC_UNKNOWN; 
13A2:  MOVFF  1F7,03
13A6:  MOVLB  1
13A8:  MOVFF  1F6,FE9
13AC:  MOVFF  03,FEA
13B0:  MOVLW  FF
13B2:  MOVWF  FEF
....................     if( (header.Type.v[1] == 0x08u) && 
....................        ((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) ) 
13B4:  MOVLB  2
13B6:  MOVF   x0B,W
13B8:  SUBLW  08
13BA:  BNZ   13D4
13BC:  MOVF   x0A,F
13BE:  BZ    13C6
13C0:  MOVF   x0A,W
13C2:  SUBLW  06
13C4:  BNZ   13D4
....................     { 
....................        *type = header.Type.v[0]; 
13C6:  MOVLB  1
13C8:  MOVFF  1F6,FE9
13CC:  MOVFF  1F7,FEA
13D0:  MOVFF  20A,FEF
....................     } 
....................  
....................     // Mark this packet as discardable 
....................     WasDiscarded = FALSE; 
13D4:  MOVLB  0
13D6:  BCF    x83.0
....................    return TRUE; 
13D8:  MOVLW  01
13DA:  MOVWF  01
.................... } 
13DC:  GOTO   44B4 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void    MACPutHeader(MAC_ADDR *remote, 
....................  *                                    BYTE type, 
....................  *                                   WORD dataLen) 
....................  * 
....................  * PreCondition:    MACIsTxReady() must return TRUE. 
....................  * 
....................  * Input:           *remote: Pointer to memory which contains the destination 
....................  *                       MAC address (6 bytes) 
....................  *               type: The constant ETHER_ARP or ETHER_IP, defining which 
....................  *                    value to write into the Ethernet header's type field. 
....................  *               dataLen: Length of the Ethernet data payload 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Because of the dataLen parameter, it is probably 
....................  *               advantagous to call this function immediately before 
....................  *               transmitting a packet rather than initially when the 
....................  *               packet is first created.  The order in which the packet 
....................  *               is constructed (header first or data first) is not 
....................  *               important. 
....................  *****************************************************************************/ 
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen) 
.................... { 
*
1726:  CLRF   19
1728:  BTFSC  FF2.7
172A:  BSF    19.7
172C:  BCF    FF2.7
....................  
....................    BankSel(EWRPTL); 
172E:  MOVLB  2
1730:  CLRF   xB1
1732:  MOVLW  02
1734:  MOVWF  xB0
1736:  MOVLB  0
1738:  CALL   0204
173C:  BTFSC  19.7
173E:  BSF    FF2.7
1740:  CLRF   19
1742:  BTFSC  FF2.7
1744:  BSF    19.7
1746:  BCF    FF2.7
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(EWRPTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TxBuffers[CurrentTxBuffer].StartAddress.Val; 
....................    TxBuffers[CurrentTxBuffer].EndAddress.Val = dataLen; 
.................... #else 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
1748:  MOVLW  02
174A:  MOVLB  2
174C:  MOVWF  xB3
174E:  MOVLW  F8
1750:  MOVWF  xB4
1752:  MOVLB  0
1754:  CALL   01AA
1758:  BTFSC  19.7
175A:  BSF    FF2.7
175C:  CLRF   19
175E:  BTFSC  FF2.7
1760:  BSF    19.7
1762:  BCF    FF2.7
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
1764:  MOVLW  03
1766:  MOVLB  2
1768:  MOVWF  xB3
176A:  MOVLW  1B
176C:  MOVWF  xB4
176E:  MOVLB  0
1770:  CALL   01AA
1774:  BTFSC  19.7
1776:  BSF    FF2.7
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART; 
1778:  MOVLW  06
177A:  MOVLB  2
177C:  ADDWF  x9A,F
177E:  MOVLW  1C
1780:  ADDWFC x9B,F
....................  
....................    // Write the TXND pointer into the registers, given the dataLen given 
....................    WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]); 
1782:  MOVLW  02
1784:  MOVWF  FEA
1786:  MOVLW  9A
1788:  MOVWF  FE9
178A:  MOVFF  FEF,29E
178E:  CLRF   19
1790:  BTFSC  FF2.7
1792:  BSF    19.7
1794:  BCF    FF2.7
1796:  MOVLW  06
1798:  MOVWF  xB3
179A:  MOVFF  29E,2B4
179E:  MOVLB  0
17A0:  CALL   01AA
17A4:  BTFSC  19.7
17A6:  BSF    FF2.7
....................    WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]); 
17A8:  MOVLW  02
17AA:  MOVWF  FEA
17AC:  MOVLW  9B
17AE:  MOVWF  FE9
17B0:  MOVFF  FEF,29E
17B4:  CLRF   19
17B6:  BTFSC  FF2.7
17B8:  BSF    19.7
17BA:  BCF    FF2.7
17BC:  MOVLW  07
17BE:  MOVLB  2
17C0:  MOVWF  xB3
17C2:  MOVFF  29E,2B4
17C6:  MOVLB  0
17C8:  CALL   01AA
17CC:  BTFSC  19.7
17CE:  BSF    FF2.7
.................... #endif 
....................  
....................  
....................    // Set the per-packet control byte and write the Ethernet destination 
....................    // address 
....................    MACPut(0x00);   // Use default control configuration 
17D0:  MOVLB  2
17D2:  CLRF   x9D
17D4:  MOVLB  0
17D6:  RCALL  168A
....................     MACPutArray((BYTE*)remote, sizeof(*remote)); 
17D8:  MOVFF  298,29F
17DC:  MOVFF  297,29E
17E0:  MOVLB  2
17E2:  CLRF   xA1
17E4:  MOVLW  06
17E6:  MOVWF  xA0
17E8:  MOVLB  0
17EA:  RCALL  16C0
....................  
....................    // Write our MAC address in the Ethernet source field 
....................    MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
17EC:  MOVLB  2
17EE:  CLRF   x9D
17F0:  MOVLW  47
17F2:  MOVFF  29D,29F
17F6:  MOVWF  x9E
17F8:  CLRF   xA1
17FA:  MOVLW  06
17FC:  MOVWF  xA0
17FE:  MOVLB  0
1800:  RCALL  16C0
....................  
....................    // Write the appropriate Ethernet Type WORD for the protocol being used 
....................     MACPut(0x08); 
1802:  MOVLW  08
1804:  MOVLB  2
1806:  MOVWF  x9D
1808:  MOVLB  0
180A:  RCALL  168A
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP); 
180C:  MOVLB  2
180E:  MOVF   x99,F
1810:  BNZ   1816
1812:  MOVLW  00
1814:  BRA    1818
1816:  MOVLW  06
1818:  MOVWF  x9D
181A:  MOVLB  0
181C:  RCALL  168A
.................... } 
181E:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACFlush(void) 
....................  * 
....................  * PreCondition:    A packet has been created by calling MACPut() and 
....................  *               MACPutHeader(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACFlush causes the current TX packet to be sent out on 
....................  *               the Ethernet medium.  The hardware MAC will take control 
....................  *               and handle CRC generation, collision retransmission and 
....................  *               other details. 
....................  * 
....................  * Note:         After transmission completes (MACIsTxReady() returns TRUE), 
....................  *               the packet can be modified and transmitted again by calling 
....................  *               MACFlush() again.  Until MACPutHeader() or MACPut() is 
....................  *               called (in the TX data area), the data in the TX buffer 
....................  *               will not be corrupted. 
....................  *****************************************************************************/ 
.................... void MACFlush(void) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
1820:  CLRF   19
1822:  BTFSC  FF2.7
1824:  BSF    19.7
1826:  BCF    FF2.7
....................    // Set the packet start and end address pointers 
....................    BankSel(ETXSTL); 
....................    WriteReg(ETXSTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(ETXSTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................    WriteReg(ETXNDL, TxBuffers[CurrentTxBuffer].EndAddress.v[0]); 
....................    WriteReg(ETXNDH, TxBuffers[CurrentTxBuffer].EndAddress.v[1]); 
....................    LastTXedBuffer = CurrentTxBuffer; 
....................    TxBuffers[CurrentTxBuffer].Flags.bTransmitted = TRUE; 
.................... #endif 
....................  
....................    // Reset transmit logic if a TX Error has previously occured 
....................    // This is a silicon errata workaround 
....................    if(ReadETHReg(EIR).EIRbits.TXERIF) 
1828:  MOVLW  1C
182A:  MOVLB  2
182C:  MOVWF  xA9
182E:  MOVLB  0
1830:  CALL   016C
1834:  BTFSC  19.7
1836:  BSF    FF2.7
1838:  BTFSS  01.1
183A:  BRA    1874
183C:  CLRF   19
183E:  BTFSC  FF2.7
1840:  BSF    19.7
1842:  BCF    FF2.7
....................    { 
....................       BFSReg(ECON1, ECON1_TXRST); 
1844:  MOVLW  1F
1846:  MOVLB  2
1848:  MOVWF  xB5
184A:  MOVLW  80
184C:  MOVWF  xB6
184E:  MOVLB  0
1850:  CALL   01E6
1854:  BTFSC  19.7
1856:  BSF    FF2.7
1858:  CLRF   19
185A:  BTFSC  FF2.7
185C:  BSF    19.7
185E:  BCF    FF2.7
....................       BFCReg(ECON1, ECON1_TXRST); 
1860:  MOVLW  1F
1862:  MOVLB  2
1864:  MOVWF  xB2
1866:  MOVLW  80
1868:  MOVWF  xB3
186A:  MOVLB  0
186C:  CALL   01C8
1870:  BTFSC  19.7
1872:  BSF    FF2.7
1874:  CLRF   19
1876:  BTFSC  FF2.7
1878:  BSF    19.7
187A:  BCF    FF2.7
....................    } 
....................    BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
187C:  MOVLW  1C
187E:  MOVLB  2
1880:  MOVWF  xB2
1882:  MOVLW  0A
1884:  MOVWF  xB3
1886:  MOVLB  0
1888:  CALL   01C8
188C:  BTFSC  19.7
188E:  BSF    FF2.7
1890:  CLRF   19
1892:  BTFSC  FF2.7
1894:  BSF    19.7
1896:  BCF    FF2.7
....................  
....................    // Start the transmission 
....................    // After transmission completes (MACIsTxReady() returns TRUE), the packet 
....................    // can be modified and transmitted again by calling MACFlush() again. 
....................    // Until MACPutHeader() is called, the data in the TX buffer will not be 
....................    // corrupted. 
....................    BFSReg(ECON1, ECON1_TXRTS); 
1898:  MOVLW  1F
189A:  MOVLB  2
189C:  MOVWF  xB5
189E:  MOVLW  08
18A0:  MOVWF  xB6
18A2:  MOVLB  0
18A4:  CALL   01E6
18A8:  BTFSC  19.7
18AA:  BSF    FF2.7
....................  
....................    // Revision B5 silicon errata workaround 
....................    if(ENCRevID == 0x05) 
18AC:  MOVF   x84,W
18AE:  SUBLW  05
18B0:  BTFSS  FD8.2
18B2:  BRA    1B50
18B4:  CLRF   19
18B6:  BTFSC  FF2.7
18B8:  BSF    19.7
18BA:  BCF    FF2.7
....................    { 
....................       while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
18BC:  MOVLW  1C
18BE:  MOVLB  2
18C0:  MOVWF  xA9
18C2:  MOVLB  0
18C4:  CALL   016C
18C8:  BTFSC  19.7
18CA:  BSF    FF2.7
18CC:  MOVF   01,W
18CE:  ANDLW  0A
18D0:  BZ    18B4
18D2:  CLRF   19
18D4:  BTFSC  FF2.7
18D6:  BSF    19.7
18D8:  BCF    FF2.7
....................       if(ReadETHReg(EIR).EIRbits.TXERIF) 
18DA:  MOVLW  1C
18DC:  MOVLB  2
18DE:  MOVWF  xA9
18E0:  MOVLB  0
18E2:  CALL   016C
18E6:  BTFSC  19.7
18E8:  BSF    FF2.7
18EA:  BTFSS  01.1
18EC:  BRA    1B50
18EE:  CLRF   19
18F0:  BTFSC  FF2.7
18F2:  BSF    19.7
18F4:  BCF    FF2.7
....................       { 
....................          WORD_VAL ReadPtrSave; 
....................          WORD_VAL TXEnd; 
....................          TXSTATUS TXStatus; 
....................          BYTE i; 
....................  
....................          // Cancel the previous transmission if it has become stuck set 
....................          BFCReg(ECON1, ECON1_TXRTS); 
18F6:  MOVLW  1F
18F8:  MOVLB  2
18FA:  MOVWF  xB2
18FC:  MOVLW  08
18FE:  MOVWF  xB3
1900:  MOVLB  0
1902:  CALL   01C8
1906:  BTFSC  19.7
1908:  BSF    FF2.7
190A:  CLRF   19
190C:  BTFSC  FF2.7
190E:  BSF    19.7
1910:  BCF    FF2.7
....................  
....................          // Save the current read pointer (controlled by application) 
....................          BankSel(ERDPTL); 
1912:  MOVLB  2
1914:  CLRF   xB1
1916:  CLRF   xB0
1918:  MOVLB  0
191A:  CALL   0204
191E:  BTFSC  19.7
1920:  BSF    FF2.7
1922:  CLRF   19
1924:  BTFSC  FF2.7
1926:  BSF    19.7
1928:  BCF    FF2.7
....................          ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val; 
192A:  MOVLB  2
192C:  CLRF   xA9
192E:  MOVLB  0
1930:  CALL   016C
1934:  BTFSC  19.7
1936:  BSF    FF2.7
1938:  MOVFF  01,27A
193C:  CLRF   19
193E:  BTFSC  FF2.7
1940:  BSF    19.7
1942:  BCF    FF2.7
....................          ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val; 
1944:  MOVLW  01
1946:  MOVLB  2
1948:  MOVWF  xA9
194A:  MOVLB  0
194C:  CALL   016C
1950:  BTFSC  19.7
1952:  BSF    FF2.7
1954:  MOVFF  01,27B
1958:  CLRF   19
195A:  BTFSC  FF2.7
195C:  BSF    19.7
195E:  BCF    FF2.7
....................  
....................          // Get the location of the transmit status vector 
....................          TXEnd.v[0] = ReadETHReg(ETXNDL).Val; 
1960:  MOVLW  06
1962:  MOVLB  2
1964:  MOVWF  xA9
1966:  MOVLB  0
1968:  CALL   016C
196C:  BTFSC  19.7
196E:  BSF    FF2.7
1970:  MOVFF  01,27C
1974:  CLRF   19
1976:  BTFSC  FF2.7
1978:  BSF    19.7
197A:  BCF    FF2.7
....................          TXEnd.v[1] = ReadETHReg(ETXNDH).Val; 
197C:  MOVLW  07
197E:  MOVLB  2
1980:  MOVWF  xA9
1982:  MOVLB  0
1984:  CALL   016C
1988:  BTFSC  19.7
198A:  BSF    FF2.7
198C:  MOVFF  01,27D
....................          TXEnd.Val++; 
1990:  MOVLB  2
1992:  INCF   x7C,F
1994:  BTFSC  FD8.2
1996:  INCF   x7D,F
1998:  CLRF   19
199A:  BTFSC  FF2.7
199C:  BSF    19.7
199E:  BCF    FF2.7
....................  
....................          // Read the transmit status vector 
....................          WriteReg(ERDPTL, TXEnd.v[0]); 
19A0:  CLRF   xB3
19A2:  MOVFF  27C,2B4
19A6:  MOVLB  0
19A8:  CALL   01AA
19AC:  BTFSC  19.7
19AE:  BSF    FF2.7
19B0:  CLRF   19
19B2:  BTFSC  FF2.7
19B4:  BSF    19.7
19B6:  BCF    FF2.7
....................          WriteReg(ERDPTH, TXEnd.v[1]); 
19B8:  MOVLW  01
19BA:  MOVLB  2
19BC:  MOVWF  xB3
19BE:  MOVFF  27D,2B4
19C2:  MOVLB  0
19C4:  CALL   01AA
19C8:  BTFSC  19.7
19CA:  BSF    FF2.7
....................          MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
19CC:  MOVLW  02
19CE:  MOVLB  2
19D0:  MOVWF  x87
19D2:  MOVLW  7E
19D4:  MOVFF  287,289
19D8:  MOVWF  x88
19DA:  CLRF   x8B
19DC:  MOVLW  07
19DE:  MOVWF  x8A
19E0:  MOVLB  0
19E2:  CALL   11D8
....................  
....................          // Implement retransmission if a late collision occured (this can 
....................          // happen on B5 when certain link pulses arrive at the same time 
....................          // as the transmission) 
....................          for(i = 0; i < 16; i++) 
19E6:  MOVLB  2
19E8:  CLRF   x85
19EA:  MOVF   x85,W
19EC:  SUBLW  0F
19EE:  BTFSS  FD8.0
19F0:  BRA    1B1C
19F2:  CLRF   19
19F4:  BTFSC  FF2.7
19F6:  BSF    19.7
19F8:  BCF    FF2.7
....................          { 
....................             if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision) 
19FA:  MOVLW  1C
19FC:  MOVWF  xA9
19FE:  MOVLB  0
1A00:  CALL   016C
1A04:  BTFSC  19.7
1A06:  BSF    FF2.7
1A08:  BTFSS  01.1
1A0A:  BRA    1B10
1A0C:  MOVLB  2
1A0E:  BTFSC  x81.5
1A10:  BRA    1A16
1A12:  MOVLB  0
1A14:  BRA    1B10
1A16:  CLRF   19
1A18:  BTFSC  FF2.7
1A1A:  BSF    19.7
1A1C:  BCF    FF2.7
....................             { 
....................                // Reset the TX logic 
....................                BFSReg(ECON1, ECON1_TXRST); 
1A1E:  MOVLW  1F
1A20:  MOVWF  xB5
1A22:  MOVLW  80
1A24:  MOVWF  xB6
1A26:  MOVLB  0
1A28:  CALL   01E6
1A2C:  BTFSC  19.7
1A2E:  BSF    FF2.7
1A30:  CLRF   19
1A32:  BTFSC  FF2.7
1A34:  BSF    19.7
1A36:  BCF    FF2.7
....................                BFCReg(ECON1, ECON1_TXRST); 
1A38:  MOVLW  1F
1A3A:  MOVLB  2
1A3C:  MOVWF  xB2
1A3E:  MOVLW  80
1A40:  MOVWF  xB3
1A42:  MOVLB  0
1A44:  CALL   01C8
1A48:  BTFSC  19.7
1A4A:  BSF    FF2.7
1A4C:  CLRF   19
1A4E:  BTFSC  FF2.7
1A50:  BSF    19.7
1A52:  BCF    FF2.7
....................                BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
1A54:  MOVLW  1C
1A56:  MOVLB  2
1A58:  MOVWF  xB2
1A5A:  MOVLW  0A
1A5C:  MOVWF  xB3
1A5E:  MOVLB  0
1A60:  CALL   01C8
1A64:  BTFSC  19.7
1A66:  BSF    FF2.7
1A68:  CLRF   19
1A6A:  BTFSC  FF2.7
1A6C:  BSF    19.7
1A6E:  BCF    FF2.7
....................  
....................                // Transmit the packet again 
....................                BFSReg(ECON1, ECON1_TXRTS); 
1A70:  MOVLW  1F
1A72:  MOVLB  2
1A74:  MOVWF  xB5
1A76:  MOVLW  08
1A78:  MOVWF  xB6
1A7A:  MOVLB  0
1A7C:  CALL   01E6
1A80:  BTFSC  19.7
1A82:  BSF    FF2.7
1A84:  CLRF   19
1A86:  BTFSC  FF2.7
1A88:  BSF    19.7
1A8A:  BCF    FF2.7
....................                while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
1A8C:  MOVLW  1C
1A8E:  MOVLB  2
1A90:  MOVWF  xA9
1A92:  MOVLB  0
1A94:  CALL   016C
1A98:  BTFSC  19.7
1A9A:  BSF    FF2.7
1A9C:  MOVF   01,W
1A9E:  ANDLW  0A
1AA0:  BZ    1A84
1AA2:  CLRF   19
1AA4:  BTFSC  FF2.7
1AA6:  BSF    19.7
1AA8:  BCF    FF2.7
....................  
....................                // Cancel the previous transmission if it has become stuck set 
....................                BFCReg(ECON1, ECON1_TXRTS); 
1AAA:  MOVLW  1F
1AAC:  MOVLB  2
1AAE:  MOVWF  xB2
1AB0:  MOVLW  08
1AB2:  MOVWF  xB3
1AB4:  MOVLB  0
1AB6:  CALL   01C8
1ABA:  BTFSC  19.7
1ABC:  BSF    FF2.7
1ABE:  CLRF   19
1AC0:  BTFSC  FF2.7
1AC2:  BSF    19.7
1AC4:  BCF    FF2.7
....................  
....................                // Read transmit status vector 
....................                WriteReg(ERDPTL, TXEnd.v[0]); 
1AC6:  MOVLB  2
1AC8:  CLRF   xB3
1ACA:  MOVFF  27C,2B4
1ACE:  MOVLB  0
1AD0:  CALL   01AA
1AD4:  BTFSC  19.7
1AD6:  BSF    FF2.7
1AD8:  CLRF   19
1ADA:  BTFSC  FF2.7
1ADC:  BSF    19.7
1ADE:  BCF    FF2.7
....................                WriteReg(ERDPTH, TXEnd.v[1]); 
1AE0:  MOVLW  01
1AE2:  MOVLB  2
1AE4:  MOVWF  xB3
1AE6:  MOVFF  27D,2B4
1AEA:  MOVLB  0
1AEC:  CALL   01AA
1AF0:  BTFSC  19.7
1AF2:  BSF    FF2.7
....................                MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
1AF4:  MOVLW  02
1AF6:  MOVLB  2
1AF8:  MOVWF  x87
1AFA:  MOVLW  7E
1AFC:  MOVFF  287,289
1B00:  MOVWF  x88
1B02:  CLRF   x8B
1B04:  MOVLW  07
1B06:  MOVWF  x8A
1B08:  MOVLB  0
1B0A:  CALL   11D8
....................             } 
....................             else 
1B0E:  BRA    1B16
....................             { 
....................                break; 
1B10:  MOVLB  2
1B12:  BRA    1B1C
1B14:  MOVLB  0
....................             } 
....................          } 
1B16:  MOVLB  2
1B18:  INCF   x85,F
1B1A:  BRA    19EA
1B1C:  CLRF   19
1B1E:  BTFSC  FF2.7
1B20:  BSF    19.7
1B22:  BCF    FF2.7
....................  
....................          // Restore the current read pointer 
....................          WriteReg(ERDPTL, ReadPtrSave.v[0]); 
1B24:  CLRF   xB3
1B26:  MOVFF  27A,2B4
1B2A:  MOVLB  0
1B2C:  CALL   01AA
1B30:  BTFSC  19.7
1B32:  BSF    FF2.7
1B34:  CLRF   19
1B36:  BTFSC  FF2.7
1B38:  BSF    19.7
1B3A:  BCF    FF2.7
....................          WriteReg(ERDPTH, ReadPtrSave.v[1]); 
1B3C:  MOVLW  01
1B3E:  MOVLB  2
1B40:  MOVWF  xB3
1B42:  MOVFF  27B,2B4
1B46:  MOVLB  0
1B48:  CALL   01AA
1B4C:  BTFSC  19.7
1B4E:  BSF    FF2.7
....................       } 
....................    } 
.................... } 
1B50:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetRxBuffer(WORD offset) 
....................  * 
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and 
....................  *               getting a TRUE result. 
....................  * 
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         RXSTOP must be statically defined as being > RXSTART for 
....................  *               this function to work correctly.  In other words, do not 
....................  *               define an RX buffer which spans the 0x1FFF->0x0000 memory 
....................  *               boundary. 
....................  *****************************************************************************/ 
.................... void MACSetRxBuffer(WORD offset) 
.................... { 
....................    WORD_VAL ReadPT; 
....................  
....................    // Determine the address of the beginning of the entire packet 
....................    // and adjust the address to the desired location 
....................    ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
1EDE:  MOVLW  14
1EE0:  ADDWF  x81,W
1EE2:  MOVLB  2
1EE4:  MOVWF  x29
1EE6:  MOVLW  00
1EE8:  MOVLB  0
1EEA:  ADDWFC x82,W
1EEC:  MOVLB  2
1EEE:  MOVWF  x2A
1EF0:  MOVF   x25,W
1EF2:  ADDWF  x29,W
1EF4:  MOVWF  x27
1EF6:  MOVF   x26,W
1EF8:  ADDWFC x2A,W
1EFA:  MOVWF  x28
....................  
....................    // Since the receive buffer is circular, adjust if a wraparound is needed 
....................    if ( ReadPT.Val > RXSTOP ) 
1EFC:  MOVF   x28,W
1EFE:  SUBLW  1A
1F00:  BC    1F14
1F02:  XORLW  FF
1F04:  BNZ   1F0C
1F06:  MOVF   x27,W
1F08:  SUBLW  F7
1F0A:  BC    1F14
....................       ReadPT.Val -= RXSIZE; 
1F0C:  MOVLW  F8
1F0E:  SUBWF  x27,F
1F10:  MOVLW  1B
1F12:  SUBWFB x28,F
1F14:  CLRF   19
1F16:  BTFSC  FF2.7
1F18:  BSF    19.7
1F1A:  BCF    FF2.7
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(ERDPTL); 
1F1C:  CLRF   xB1
1F1E:  CLRF   xB0
1F20:  MOVLB  0
1F22:  CALL   0204
1F26:  BTFSC  19.7
1F28:  BSF    FF2.7
1F2A:  CLRF   19
1F2C:  BTFSC  FF2.7
1F2E:  BSF    19.7
1F30:  BCF    FF2.7
....................    WriteReg(ERDPTL, ReadPT.v[0]); 
1F32:  MOVLB  2
1F34:  CLRF   xB3
1F36:  MOVFF  227,2B4
1F3A:  MOVLB  0
1F3C:  CALL   01AA
1F40:  BTFSC  19.7
1F42:  BSF    FF2.7
1F44:  CLRF   19
1F46:  BTFSC  FF2.7
1F48:  BSF    19.7
1F4A:  BCF    FF2.7
....................    WriteReg(ERDPTH, ReadPT.v[1]); 
1F4C:  MOVLW  01
1F4E:  MOVLB  2
1F50:  MOVWF  xB3
1F52:  MOVFF  228,2B4
1F56:  MOVLB  0
1F58:  CALL   01AA
1F5C:  BTFSC  19.7
1F5E:  BSF    FF2.7
1F60:  CLRF   19
1F62:  BTFSC  FF2.7
1F64:  BSF    19.7
1F66:  BCF    FF2.7
....................    WriteReg(EWRPTL, ReadPT.v[0]); 
1F68:  MOVLW  02
1F6A:  MOVLB  2
1F6C:  MOVWF  xB3
1F6E:  MOVFF  227,2B4
1F72:  MOVLB  0
1F74:  CALL   01AA
1F78:  BTFSC  19.7
1F7A:  BSF    FF2.7
1F7C:  CLRF   19
1F7E:  BTFSC  FF2.7
1F80:  BSF    19.7
1F82:  BCF    FF2.7
....................    WriteReg(EWRPTH, ReadPT.v[1]); 
1F84:  MOVLW  03
1F86:  MOVLB  2
1F88:  MOVWF  xB3
1F8A:  MOVFF  228,2B4
1F8E:  MOVLB  0
1F90:  CALL   01AA
1F94:  BTFSC  19.7
1F96:  BSF    FF2.7
.................... } 
1F98:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetTxBuffer(BUFFER buffer, WORD offset) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           buffer: BYTE specifying which transmit buffer to seek 
....................  *                     within.  If MAC_TX_BUFFER_COUNT <= 1, this 
....................  *                     parameter is not used. 
....................  *               offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         None 
....................  *****************************************************************************/ 
.................... void MACSetTxBuffer(BUFFER buffer, WORD offset) 
.................... { 
....................     CurrentTxBuffer = buffer; 
*
15C4:  MOVFF  293,7A
....................  
....................    // Calculate the proper address.  Since the TX memory area is not circular, 
....................    // no wrapparound checks are necessary. +1 adjustment is needed because of 
....................    // the per packet control byte which preceeds the packet in the TX memory 
....................    // area. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    offset += TxBuffers[buffer].StartAddress.Val + 1 + sizeof(ETHER_HEADER); 
.................... #else 
....................    offset += TXSTART + 1 + sizeof(ETHER_HEADER); 
15C8:  MOVLW  07
15CA:  MOVLB  2
15CC:  ADDWF  x94,F
15CE:  MOVLW  1C
15D0:  ADDWFC x95,F
15D2:  CLRF   19
15D4:  BTFSC  FF2.7
15D6:  BSF    19.7
15D8:  BCF    FF2.7
.................... #endif 
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(EWRPTL); 
15DA:  CLRF   xB1
15DC:  MOVLW  02
15DE:  MOVWF  xB0
15E0:  MOVLB  0
15E2:  CALL   0204
15E6:  BTFSC  19.7
15E8:  BSF    FF2.7
....................    WriteReg(ERDPTL, ((WORD_VAL*)&offset)->v[0]); 
15EA:  MOVLW  02
15EC:  MOVWF  FEA
15EE:  MOVLW  94
15F0:  MOVWF  FE9
15F2:  MOVFF  FEF,298
15F6:  CLRF   19
15F8:  BTFSC  FF2.7
15FA:  BSF    19.7
15FC:  BCF    FF2.7
15FE:  MOVLB  2
1600:  CLRF   xB3
1602:  MOVFF  298,2B4
1606:  MOVLB  0
1608:  CALL   01AA
160C:  BTFSC  19.7
160E:  BSF    FF2.7
....................    WriteReg(ERDPTH, ((WORD_VAL*)&offset)->v[1]); 
1610:  MOVLW  02
1612:  MOVWF  FEA
1614:  MOVLW  95
1616:  MOVWF  FE9
1618:  MOVFF  FEF,298
161C:  CLRF   19
161E:  BTFSC  FF2.7
1620:  BSF    19.7
1622:  BCF    FF2.7
1624:  MOVLW  01
1626:  MOVLB  2
1628:  MOVWF  xB3
162A:  MOVFF  298,2B4
162E:  MOVLB  0
1630:  CALL   01AA
1634:  BTFSC  19.7
1636:  BSF    FF2.7
....................    WriteReg(EWRPTL, ((WORD_VAL*)&offset)->v[0]); 
1638:  MOVLW  02
163A:  MOVWF  FEA
163C:  MOVLW  94
163E:  MOVWF  FE9
1640:  MOVFF  FEF,298
1644:  CLRF   19
1646:  BTFSC  FF2.7
1648:  BSF    19.7
164A:  BCF    FF2.7
164C:  MOVLW  02
164E:  MOVLB  2
1650:  MOVWF  xB3
1652:  MOVFF  298,2B4
1656:  MOVLB  0
1658:  CALL   01AA
165C:  BTFSC  19.7
165E:  BSF    FF2.7
....................    WriteReg(EWRPTH, ((WORD_VAL*)&offset)->v[1]); 
1660:  MOVLW  02
1662:  MOVWF  FEA
1664:  MOVLW  95
1666:  MOVWF  FE9
1668:  MOVFF  FEF,298
166C:  CLRF   19
166E:  BTFSC  FF2.7
1670:  BSF    19.7
1672:  BCF    FF2.7
1674:  MOVLW  03
1676:  MOVLB  2
1678:  MOVWF  xB3
167A:  MOVFF  298,2B4
167E:  MOVLB  0
1680:  CALL   01AA
1684:  BTFSC  19.7
1686:  BSF    FF2.7
.................... } 
1688:  RETLW  00
....................  
....................  
.................... #if defined(MCHP_MAC) 
.................... // MACCalcRxChecksum() and MACCalcTxChecksum() use the DMA module to calculate 
.................... // checksums.  These two functions have been tested. 
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcRxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Add the offset requested by firmware plus the Ethernet header 
....................    temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
1D76:  MOVLW  14
1D78:  ADDWF  x81,W
1D7A:  MOVLB  2
1D7C:  MOVWF  x53
1D7E:  MOVLW  00
1D80:  MOVLB  0
1D82:  ADDWFC x82,W
1D84:  MOVLB  2
1D86:  MOVWF  x54
1D88:  MOVF   x4D,W
1D8A:  ADDWF  x53,W
1D8C:  MOVWF  x51
1D8E:  MOVF   x4E,W
1D90:  ADDWFC x54,W
1D92:  MOVWF  x52
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
1D94:  MOVF   x52,W
1D96:  SUBLW  1A
1D98:  BC    1DAC
1D9A:  XORLW  FF
1D9C:  BNZ   1DA4
1D9E:  MOVF   x51,W
1DA0:  SUBLW  F7
1DA2:  BC    1DAC
....................    { 
....................       temp.Val -= RXSIZE; 
1DA4:  MOVLW  F8
1DA6:  SUBWF  x51,F
1DA8:  MOVLW  1B
1DAA:  SUBWFB x52,F
1DAC:  CLRF   19
1DAE:  BTFSC  FF2.7
1DB0:  BSF    19.7
1DB2:  BCF    FF2.7
....................    } 
....................  
....................    // Program the start address of the DMA 
....................    BankSel(EDMASTL); 
1DB4:  CLRF   xB1
1DB6:  MOVLW  10
1DB8:  MOVWF  xB0
1DBA:  MOVLB  0
1DBC:  CALL   0204
1DC0:  BTFSC  19.7
1DC2:  BSF    FF2.7
1DC4:  CLRF   19
1DC6:  BTFSC  FF2.7
1DC8:  BSF    19.7
1DCA:  BCF    FF2.7
....................    WriteReg(EDMASTL, temp.v[0]); 
1DCC:  MOVLW  10
1DCE:  MOVLB  2
1DD0:  MOVWF  xB3
1DD2:  MOVFF  251,2B4
1DD6:  MOVLB  0
1DD8:  CALL   01AA
1DDC:  BTFSC  19.7
1DDE:  BSF    FF2.7
1DE0:  CLRF   19
1DE2:  BTFSC  FF2.7
1DE4:  BSF    19.7
1DE6:  BCF    FF2.7
....................    WriteReg(EDMASTH, temp.v[1]); 
1DE8:  MOVLW  11
1DEA:  MOVLB  2
1DEC:  MOVWF  xB3
1DEE:  MOVFF  252,2B4
1DF2:  MOVLB  0
1DF4:  CALL   01AA
1DF8:  BTFSC  19.7
1DFA:  BSF    FF2.7
....................  
....................    // Calculate the end address, given the start address and len 
....................    temp.Val += len-1; 
1DFC:  MOVLW  01
1DFE:  MOVLB  2
1E00:  SUBWF  x4F,W
1E02:  MOVWF  00
1E04:  MOVLW  00
1E06:  SUBWFB x50,W
1E08:  MOVWF  03
1E0A:  MOVF   00,W
1E0C:  ADDWF  x51,F
1E0E:  MOVF   03,W
1E10:  ADDWFC x52,F
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
1E12:  MOVF   x52,W
1E14:  SUBLW  1A
1E16:  BC    1E2A
1E18:  XORLW  FF
1E1A:  BNZ   1E22
1E1C:  MOVF   x51,W
1E1E:  SUBLW  F7
1E20:  BC    1E2A
....................    { 
....................       temp.Val -= RXSIZE; 
1E22:  MOVLW  F8
1E24:  SUBWF  x51,F
1E26:  MOVLW  1B
1E28:  SUBWFB x52,F
1E2A:  CLRF   19
1E2C:  BTFSC  FF2.7
1E2E:  BSF    19.7
1E30:  BCF    FF2.7
....................    } 
....................  
....................    // Program the end address of the DMA 
....................    WriteReg(EDMANDL, temp.v[0]); 
1E32:  MOVLW  12
1E34:  MOVWF  xB3
1E36:  MOVFF  251,2B4
1E3A:  MOVLB  0
1E3C:  CALL   01AA
1E40:  BTFSC  19.7
1E42:  BSF    FF2.7
1E44:  CLRF   19
1E46:  BTFSC  FF2.7
1E48:  BSF    19.7
1E4A:  BCF    FF2.7
....................    WriteReg(EDMANDH, temp.v[1]); 
1E4C:  MOVLW  13
1E4E:  MOVLB  2
1E50:  MOVWF  xB3
1E52:  MOVFF  252,2B4
1E56:  MOVLB  0
1E58:  CALL   01AA
1E5C:  BTFSC  19.7
1E5E:  BSF    FF2.7
1E60:  CLRF   19
1E62:  BTFSC  FF2.7
1E64:  BSF    19.7
1E66:  BCF    FF2.7
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
1E68:  MOVLW  1F
1E6A:  MOVLB  2
1E6C:  MOVWF  xB5
1E6E:  MOVLW  30
1E70:  MOVWF  xB6
1E72:  MOVLB  0
1E74:  CALL   01E6
1E78:  BTFSC  19.7
1E7A:  BSF    FF2.7
1E7C:  CLRF   19
1E7E:  BTFSC  FF2.7
1E80:  BSF    19.7
1E82:  BCF    FF2.7
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
1E84:  MOVLW  1F
1E86:  MOVLB  2
1E88:  MOVWF  xA9
1E8A:  MOVLB  0
1E8C:  CALL   016C
1E90:  BTFSC  19.7
1E92:  BSF    FF2.7
1E94:  BTFSC  01.5
1E96:  BRA    1E7C
1E98:  CLRF   19
1E9A:  BTFSC  FF2.7
1E9C:  BSF    19.7
1E9E:  BCF    FF2.7
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
1EA0:  MOVLW  16
1EA2:  MOVLB  2
1EA4:  MOVWF  xA9
1EA6:  MOVLB  0
1EA8:  CALL   016C
1EAC:  BTFSC  19.7
1EAE:  BSF    FF2.7
1EB0:  MOVFF  01,252
1EB4:  CLRF   19
1EB6:  BTFSC  FF2.7
1EB8:  BSF    19.7
1EBA:  BCF    FF2.7
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
1EBC:  MOVLW  17
1EBE:  MOVLB  2
1EC0:  MOVWF  xA9
1EC2:  MOVLB  0
1EC4:  CALL   016C
1EC8:  BTFSC  19.7
1ECA:  BSF    FF2.7
1ECC:  MOVFF  01,251
....................    return temp.Val; 
1ED0:  MOVLB  2
1ED2:  MOVFF  251,01
1ED6:  MOVFF  252,02
.................... } 
1EDA:  MOVLB  0
1EDC:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcTxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcTxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Program the start address of the DMA, after adjusting for the Ethernet 
....................    // header 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    temp.Val = TxBuffers[CurrentTxBuffer].StartAddress.Val + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
.................... #else 
....................    temp.Val = TXSTART + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
*
2B80:  MOVLW  06
2B82:  MOVLB  2
2B84:  ADDWF  x93,W
2B86:  MOVWF  x99
2B88:  MOVLW  1C
2B8A:  ADDWFC x94,W
2B8C:  MOVWF  x9A
2B8E:  MOVLW  01
2B90:  ADDWF  x99,W
2B92:  MOVWF  x97
2B94:  MOVLW  00
2B96:  ADDWFC x9A,W
2B98:  MOVWF  x98
2B9A:  CLRF   19
2B9C:  BTFSC  FF2.7
2B9E:  BSF    19.7
2BA0:  BCF    FF2.7
.................... #endif 
....................    BankSel(EDMASTL); 
2BA2:  CLRF   xB1
2BA4:  MOVLW  10
2BA6:  MOVWF  xB0
2BA8:  MOVLB  0
2BAA:  CALL   0204
2BAE:  BTFSC  19.7
2BB0:  BSF    FF2.7
2BB2:  CLRF   19
2BB4:  BTFSC  FF2.7
2BB6:  BSF    19.7
2BB8:  BCF    FF2.7
....................    WriteReg(EDMASTL, temp.v[0]); 
2BBA:  MOVLW  10
2BBC:  MOVLB  2
2BBE:  MOVWF  xB3
2BC0:  MOVFF  297,2B4
2BC4:  MOVLB  0
2BC6:  CALL   01AA
2BCA:  BTFSC  19.7
2BCC:  BSF    FF2.7
2BCE:  CLRF   19
2BD0:  BTFSC  FF2.7
2BD2:  BSF    19.7
2BD4:  BCF    FF2.7
....................    WriteReg(EDMASTH, temp.v[1]); 
2BD6:  MOVLW  11
2BD8:  MOVLB  2
2BDA:  MOVWF  xB3
2BDC:  MOVFF  298,2B4
2BE0:  MOVLB  0
2BE2:  CALL   01AA
2BE6:  BTFSC  19.7
2BE8:  BSF    FF2.7
....................  
....................    // Program the end address of the DMA. 
....................    temp.Val += len-1; 
2BEA:  MOVLW  01
2BEC:  MOVLB  2
2BEE:  SUBWF  x95,W
2BF0:  MOVWF  00
2BF2:  MOVLW  00
2BF4:  SUBWFB x96,W
2BF6:  MOVWF  03
2BF8:  MOVF   00,W
2BFA:  ADDWF  x97,F
2BFC:  MOVF   03,W
2BFE:  ADDWFC x98,F
2C00:  CLRF   19
2C02:  BTFSC  FF2.7
2C04:  BSF    19.7
2C06:  BCF    FF2.7
....................    WriteReg(EDMANDL, temp.v[0]); 
2C08:  MOVLW  12
2C0A:  MOVWF  xB3
2C0C:  MOVFF  297,2B4
2C10:  MOVLB  0
2C12:  CALL   01AA
2C16:  BTFSC  19.7
2C18:  BSF    FF2.7
2C1A:  CLRF   19
2C1C:  BTFSC  FF2.7
2C1E:  BSF    19.7
2C20:  BCF    FF2.7
....................    WriteReg(EDMANDH, temp.v[1]); 
2C22:  MOVLW  13
2C24:  MOVLB  2
2C26:  MOVWF  xB3
2C28:  MOVFF  298,2B4
2C2C:  MOVLB  0
2C2E:  CALL   01AA
2C32:  BTFSC  19.7
2C34:  BSF    FF2.7
2C36:  CLRF   19
2C38:  BTFSC  FF2.7
2C3A:  BSF    19.7
2C3C:  BCF    FF2.7
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
2C3E:  MOVLW  1F
2C40:  MOVLB  2
2C42:  MOVWF  xB5
2C44:  MOVLW  30
2C46:  MOVWF  xB6
2C48:  MOVLB  0
2C4A:  CALL   01E6
2C4E:  BTFSC  19.7
2C50:  BSF    FF2.7
2C52:  CLRF   19
2C54:  BTFSC  FF2.7
2C56:  BSF    19.7
2C58:  BCF    FF2.7
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
2C5A:  MOVLW  1F
2C5C:  MOVLB  2
2C5E:  MOVWF  xA9
2C60:  MOVLB  0
2C62:  CALL   016C
2C66:  BTFSC  19.7
2C68:  BSF    FF2.7
2C6A:  BTFSC  01.5
2C6C:  BRA    2C52
2C6E:  CLRF   19
2C70:  BTFSC  FF2.7
2C72:  BSF    19.7
2C74:  BCF    FF2.7
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
2C76:  MOVLW  16
2C78:  MOVLB  2
2C7A:  MOVWF  xA9
2C7C:  MOVLB  0
2C7E:  CALL   016C
2C82:  BTFSC  19.7
2C84:  BSF    FF2.7
2C86:  MOVFF  01,298
2C8A:  CLRF   19
2C8C:  BTFSC  FF2.7
2C8E:  BSF    19.7
2C90:  BCF    FF2.7
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
2C92:  MOVLW  17
2C94:  MOVLB  2
2C96:  MOVWF  xA9
2C98:  MOVLB  0
2C9A:  CALL   016C
2C9E:  BTFSC  19.7
2CA0:  BSF    FF2.7
2CA2:  MOVFF  01,297
....................    return temp.Val; 
2CA6:  MOVLB  2
2CA8:  MOVFF  297,01
2CAC:  MOVFF  298,02
.................... } 
2CB0:  MOVLB  0
2CB2:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    Read buffer pointer set to starting of checksum data 
....................  * 
....................  * Input:           len: Total number of bytes to calculate the checksum over. 
....................  *                   The first byte included in the checksum is the byte 
....................  *                   pointed to by ERDPT, which is updated by calls to 
....................  *                   MACGet(), MACSetRxBuffer(), MACSetTxBuffer(), etc. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module 
....................  *               which can calculate the checksum faster than software, so 
....................  *               this function replaces the CaclIPBufferChecksum() function 
....................  *               defined in the helpers.c file.  Through the use of 
....................  *               preprocessor defines, this replacement is automatic. 
....................  * 
....................  * Note:            This function works either in the RX buffer area or the TX 
....................  *               buffer area.  No validation is done on the len parameter. 
....................  *****************************************************************************/ 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Take care of special cases which the DMA cannot be used for 
....................    if(len == 0u) 
*
22A0:  MOVLB  2
22A2:  MOVF   x7A,F
22A4:  BNZ   22B4
22A6:  MOVF   x7B,F
22A8:  BNZ   22B4
....................    { 
....................       return 0xFFFF; 
22AA:  MOVLW  FF
22AC:  MOVWF  01
22AE:  MOVWF  02
22B0:  BRA    2468
....................    } 
....................    else if(len == 1u) 
22B2:  BRA    22E2
22B4:  DECFSZ x7A,W
22B6:  BRA    22E2
22B8:  MOVF   x7B,F
22BA:  BNZ   22E2
....................    { 
....................       return ~(((WORD)MACGet())<<8); 
22BC:  MOVLB  0
22BE:  RCALL  225C
22C0:  MOVLB  2
22C2:  CLRF   x7F
22C4:  MOVFF  01,27E
22C8:  MOVFF  01,03
22CC:  MOVLW  00
22CE:  CLRF   00
22D0:  DECF   00,F
22D2:  XORWF  00,F
22D4:  MOVLW  FF
22D6:  XORWF  03,F
22D8:  MOVFF  00,01
22DC:  MOVFF  03,02
22E0:  BRA    2468
22E2:  CLRF   19
22E4:  BTFSC  FF2.7
22E6:  BSF    19.7
22E8:  BCF    FF2.7
....................    } 
....................  
....................  
....................    // Set the DMA starting address to the SPI read pointer value 
....................    BankSel(ERDPTL); 
22EA:  CLRF   xB1
22EC:  CLRF   xB0
22EE:  MOVLB  0
22F0:  CALL   0204
22F4:  BTFSC  19.7
22F6:  BSF    FF2.7
22F8:  CLRF   19
22FA:  BTFSC  FF2.7
22FC:  BSF    19.7
22FE:  BCF    FF2.7
....................    temp.v[0] = ReadETHReg(ERDPTL).Val; 
2300:  MOVLB  2
2302:  CLRF   xA9
2304:  MOVLB  0
2306:  CALL   016C
230A:  BTFSC  19.7
230C:  BSF    FF2.7
230E:  MOVFF  01,27C
2312:  CLRF   19
2314:  BTFSC  FF2.7
2316:  BSF    19.7
2318:  BCF    FF2.7
....................    temp.v[1] = ReadETHReg(ERDPTH).Val; 
231A:  MOVLW  01
231C:  MOVLB  2
231E:  MOVWF  xA9
2320:  MOVLB  0
2322:  CALL   016C
2326:  BTFSC  19.7
2328:  BSF    FF2.7
232A:  MOVFF  01,27D
232E:  CLRF   19
2330:  BTFSC  FF2.7
2332:  BSF    19.7
2334:  BCF    FF2.7
....................    WriteReg(EDMASTL, temp.v[0]); 
2336:  MOVLW  10
2338:  MOVLB  2
233A:  MOVWF  xB3
233C:  MOVFF  27C,2B4
2340:  MOVLB  0
2342:  CALL   01AA
2346:  BTFSC  19.7
2348:  BSF    FF2.7
234A:  CLRF   19
234C:  BTFSC  FF2.7
234E:  BSF    19.7
2350:  BCF    FF2.7
....................    WriteReg(EDMASTH, temp.v[1]); 
2352:  MOVLW  11
2354:  MOVLB  2
2356:  MOVWF  xB3
2358:  MOVFF  27D,2B4
235C:  MOVLB  0
235E:  CALL   01AA
2362:  BTFSC  19.7
2364:  BSF    FF2.7
....................  
....................    // See if we are calculating a checksum within the RX buffer (where 
....................    // wrapping rules apply) or TX/unused area (where wrapping rules are 
....................    // not applied) 
.................... #if RXSTART == 0 
....................    if(temp.Val <= RXSTOP) 
2366:  MOVLB  2
2368:  MOVF   x7D,W
236A:  SUBLW  1B
236C:  BNC   23A4
236E:  BNZ   2376
2370:  MOVF   x7C,W
2372:  SUBLW  F7
2374:  BNC   23A4
.................... #else 
....................    if(temp.Val >= RXSTART && temp.Val <= RXSTOP) 
.................... #endif 
....................    { 
....................       // Calculate the DMA ending address given the starting address and len 
....................       // parameter.  The DMA will follow the receive buffer wrapping boundary. 
....................       temp.Val += len-1; 
2376:  MOVLW  01
2378:  SUBWF  x7A,W
237A:  MOVWF  00
237C:  MOVLW  00
237E:  SUBWFB x7B,W
2380:  MOVWF  03
2382:  MOVF   00,W
2384:  ADDWF  x7C,F
2386:  MOVF   03,W
2388:  ADDWFC x7D,F
....................       if(temp.Val > RXSTOP) 
238A:  MOVF   x7D,W
238C:  SUBLW  1A
238E:  BC    23A2
2390:  XORLW  FF
2392:  BNZ   239A
2394:  MOVF   x7C,W
2396:  SUBLW  F7
2398:  BC    23A2
....................       { 
....................          temp.Val -= RXSIZE; 
239A:  MOVLW  F8
239C:  SUBWF  x7C,F
239E:  MOVLW  1B
23A0:  SUBWFB x7D,F
....................       } 
....................    } 
....................    else 
23A2:  BRA    23B8
....................    { 
....................       temp.Val += len-1; 
23A4:  MOVLW  01
23A6:  SUBWF  x7A,W
23A8:  MOVWF  00
23AA:  MOVLW  00
23AC:  SUBWFB x7B,W
23AE:  MOVWF  03
23B0:  MOVF   00,W
23B2:  ADDWF  x7C,F
23B4:  MOVF   03,W
23B6:  ADDWFC x7D,F
23B8:  CLRF   19
23BA:  BTFSC  FF2.7
23BC:  BSF    19.7
23BE:  BCF    FF2.7
....................    } 
....................  
....................    // Write the DMA end address 
....................    WriteReg(EDMANDL, temp.v[0]); 
23C0:  MOVLW  12
23C2:  MOVWF  xB3
23C4:  MOVFF  27C,2B4
23C8:  MOVLB  0
23CA:  CALL   01AA
23CE:  BTFSC  19.7
23D0:  BSF    FF2.7
23D2:  CLRF   19
23D4:  BTFSC  FF2.7
23D6:  BSF    19.7
23D8:  BCF    FF2.7
....................    WriteReg(EDMANDH, temp.v[1]); 
23DA:  MOVLW  13
23DC:  MOVLB  2
23DE:  MOVWF  xB3
23E0:  MOVFF  27D,2B4
23E4:  MOVLB  0
23E6:  CALL   01AA
23EA:  BTFSC  19.7
23EC:  BSF    FF2.7
23EE:  CLRF   19
23F0:  BTFSC  FF2.7
23F2:  BSF    19.7
23F4:  BCF    FF2.7
....................  
....................    // Begin the DMA checksum calculation and wait until it is finished 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
23F6:  MOVLW  1F
23F8:  MOVLB  2
23FA:  MOVWF  xB5
23FC:  MOVLW  30
23FE:  MOVWF  xB6
2400:  MOVLB  0
2402:  CALL   01E6
2406:  BTFSC  19.7
2408:  BSF    FF2.7
240A:  CLRF   19
240C:  BTFSC  FF2.7
240E:  BSF    19.7
2410:  BCF    FF2.7
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
2412:  MOVLW  1F
2414:  MOVLB  2
2416:  MOVWF  xA9
2418:  MOVLB  0
241A:  CALL   016C
241E:  BTFSC  19.7
2420:  BSF    FF2.7
2422:  BTFSC  01.5
2424:  BRA    240A
2426:  CLRF   19
2428:  BTFSC  FF2.7
242A:  BSF    19.7
242C:  BCF    FF2.7
....................  
....................    // Return the resulting good stuff 
....................    temp.v[0] = ReadETHReg(EDMACSL).Val; 
242E:  MOVLW  16
2430:  MOVLB  2
2432:  MOVWF  xA9
2434:  MOVLB  0
2436:  CALL   016C
243A:  BTFSC  19.7
243C:  BSF    FF2.7
243E:  MOVFF  01,27C
2442:  CLRF   19
2444:  BTFSC  FF2.7
2446:  BSF    19.7
2448:  BCF    FF2.7
....................    temp.v[1] = ReadETHReg(EDMACSH).Val; 
244A:  MOVLW  17
244C:  MOVLB  2
244E:  MOVWF  xA9
2450:  MOVLB  0
2452:  CALL   016C
2456:  BTFSC  19.7
2458:  BSF    FF2.7
245A:  MOVFF  01,27D
....................    return temp.Val; 
245E:  MOVLB  2
2460:  MOVFF  27C,01
2464:  MOVFF  27D,02
.................... } 
2468:  MOVLB  0
246A:  RETLW  00
.................... #endif   // End of MCHP_MAC specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           RxOffset: Offset in the RX buffer (0=first byte of 
....................  *                        destination MAC address) to copy from. 
....................  *               TxOffset: Offset in the TX buffer (0=first byte of 
....................  *                       destination MAC address) to copy to. 
....................  *               len:     Number of bytes to copy 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        If the TX logic is transmitting a packet (ECON1.TXRTS is 
....................  *               set), the hardware will wait until it is finished.  Then, 
....................  *               the DMA module will copy the data from the receive buffer 
....................  *               to the transmit buffer. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... // Remove this line if your application needs to use this 
.................... // function.  This code has NOT been tested. 
.................... #if 0 
.................... void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    temp.Val = CurrentPacketLocation.Val + RxOffset + sizeof(ENC_PREAMBLE); 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    BankSel(EDMASTL); 
....................    WriteReg(EDMASTL, temp.v[0]); 
....................    WriteReg(EDMASTH, temp.v[1]); 
....................  
....................    temp.Val += len-1; 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    WriteReg(EDMANDL, temp.v[0]); 
....................    WriteReg(EDMANDH, temp.v[1]); 
....................  
....................    TxOffset += TXSTART+1; 
....................    WriteReg(EDMADSTL, ((WORD_VAL*)&TxOffset)->v[0]); 
....................    WriteReg(EDMADSTH, ((WORD_VAL*)&TxOffset)->v[1]); 
....................  
....................    // Do the DMA Copy.  The DMA module will wait for TXRTS to become clear 
....................    // before starting the copy. 
....................    BFCReg(ECON1, ECON1_CSUMEN); 
....................    BFSReg(ECON1, ECON1_DMAST); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
.................... } 
.................... #endif 
....................  
....................  
.................... #if defined(MAC_FILTER_BROADCASTS) 
.................... // NOTE: This code has NOT been tested.  See StackTsk.h's explanation 
.................... // of MAC_FILTER_BROADCASTS. 
.................... /****************************************************************************** 
....................  * Function:        void MACSetPMFilter(BYTE *Pattern, 
....................  *                              BYTE *PatternMask, 
....................  *                              WORD PatternOffset) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                MACIsTxReady() must return TRUE 
....................  * 
....................  * Input:           *Pattern: Pointer to an intial pattern to compare against 
....................  *               *PatternMask: Pointer to an 8 byte pattern mask which 
....................  *                          defines which bytes of the pattern are 
....................  *                          important.  At least one bit must be set. 
....................  *               PatternOffset: Offset from the beginning of the Ethernet 
....................  *                           frame (1st byte of destination address), to 
....................  *                           begin comparing with the given pattern. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Contents of the TX buffer space are overwritten 
....................  * 
....................  * Overview:        MACSetPMFilter sets the hardware receive filters for: 
....................  *               CRC AND (Unicast OR Pattern Match).  As a result, only a 
....................  *               subset of the broadcast packets which are normally 
....................  *               received will be received. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACSetPMFilter(BYTE *Pattern, 
....................                BYTE *PatternMask, 
....................                WORD PatternOffset) 
.................... { 
....................    WORD_VAL i; 
....................    BYTE *MaskPtr; 
....................    BYTE UnmaskedPatternLen; 
....................  
....................    // Set the SPI write pointer and DMA startting address to the beginning of 
....................    // the transmit buffer 
....................    BankSel(EWRPTL); 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
....................    WriteReg(EDMASTL, LOW(TXSTART)); 
....................    WriteReg(EDMASTH, HIGH(TXSTART)); 
....................  
....................    // Fill the transmit buffer with the pattern to match against.  Only the 
....................    // bytes which have a mask bit of 1 are written into the buffer and will 
....................    // subsequently be used for checksum computation. 
....................    MaskPtr = PatternMask; 
....................    for(i.Val = 0x0100; i.v[0] < 64; i.v[0]++) 
....................    { 
....................       if( *MaskPtr & i.v[1] ) 
....................       { 
....................          MACPut(*Pattern); 
....................          UnmaskedPatternLen++; 
....................       } 
....................       Pattern++; 
....................  
....................       i.v[1] <<= 1; 
....................       if( i.v[1] == 0u ) 
....................       { 
....................          i.v[1] = 0x01; 
....................          MaskPtr++; 
....................       } 
....................    } 
....................  
....................    // Calculate and set the DMA end address 
....................    i.Val = TXSTART + (WORD)UnmaskedPatternLen - 1; 
....................    WriteReg(EDMANDL, i.v[0]); 
....................    WriteReg(EDMANDH, i.v[1]); 
....................  
....................    // Calculate the checksum on the given pattern using the DMA module 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Make certain that the PM filter isn't enabled while it is 
....................    // being reconfigured. 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................  
....................    // Get the calculated DMA checksum and store it in the PM 
....................    // checksum registers 
....................    i.v[0] == ReadETHReg(EDMACSL).Val; 
....................    i.v[1] == ReadETHReg(EDMACSH).Val; 
....................    WriteReg(EPMCSL, i.v[0]); 
....................    WriteReg(EPMCSH, i.v[0]); 
....................  
....................    // Set the Pattern Match offset and 8 byte mask 
....................    WriteReg(EPMOL, ((WORD_VAL*)&PatternOffset)->v[0]); 
....................    WriteReg(EPMOH, ((WORD_VAL*)&PatternOffset)->v[1]); 
....................    for(i.Val = EPMM0; i.Val <= EPMM7 ; i.Val++) 
....................    { 
....................       WriteReg(i.Val, *PatternMask++); 
....................    } 
....................  
....................    // Begin using the new Pattern Match filter instead of the 
....................    // broadcast filter 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_PMEN); 
.................... }//end MACSetPMFilter 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDisablePMFilter(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACDisablePMFilter disables the Pattern Match receive 
....................  *               filter (if enabled) and returns to the default filter 
....................  *               configuration of: CRC AND (Unicast OR Broadcast). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDisablePMFilter(void) 
.................... { 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................    return; 
.................... }//end MACDisablePMFilter 
.................... #endif // end of MAC_FILTER_BROADCASTS specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE MACGet() 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and 
....................  *               increments ERDPT so MACGet() can be called again.  The 
....................  *               increment will follow the receive buffer wrapping boundary. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE MACGet() 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return SSPBUF; 
.................... */ 
....................    char c; 
....................  
....................    SPISelectEthernet(); 
*
225C:  BCF    F95.3
225E:  BCF    F8C.3
2260:  CLRF   19
2262:  BTFSC  FF2.7
2264:  BSF    19.7
2266:  BCF    FF2.7
....................    ENCSPIXfer(RBM); 
2268:  MOVLW  3A
226A:  MOVLB  2
226C:  MOVWF  xB8
226E:  MOVLB  0
2270:  CALL   0132
2274:  BTFSC  19.7
2276:  BSF    FF2.7
2278:  CLRF   19
227A:  BTFSC  FF2.7
227C:  BSF    19.7
227E:  BCF    FF2.7
....................    c=ENCSPIXfer(0); 
2280:  MOVLB  2
2282:  CLRF   xB8
2284:  MOVLB  0
2286:  CALL   0132
228A:  BTFSC  19.7
228C:  BSF    FF2.7
228E:  MOVFF  01,27E
....................    SPIUnselectEthernet(); 
2292:  BCF    F95.3
2294:  BSF    F8C.3
....................    return(c); 
2296:  MOVLB  2
2298:  MOVFF  27E,01
.................... }//end MACGet 
229C:  MOVLB  0
229E:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           *val: Pointer to storage location 
....................  *               len:  Number of bytes to read from the data buffer. 
....................  * 
....................  * Output:          Byte(s) of data read from the data buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Burst reads several sequential bytes from the data buffer 
....................  *               and places them into local memory.  With SPI burst support, 
....................  *               it performs much faster than multiple MACGet() calls. 
....................  *               ERDPT is incremented after each byte, following the same 
....................  *               rules as MACGet(). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetArray(BYTE *val, WORD len) 
.................... { 
*
11D8:  MOVLB  2
11DA:  CLRF   x8D
11DC:  CLRF   x8C
.................... /* 
....................    int16 i; 
....................  
....................    // Start the burst operation 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM;         // Send the Read Buffer Memory opcode. 
....................    i = 0; 
....................    val--; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Read the data 
....................    while(i<len) 
....................    { 
....................       SSPBUF = 0;         // Send a dummy byte to receive a byte 
....................       i++; 
....................       val++; 
....................       while(!PIR1_SSPIF);   // Wait until byte is received. 
....................       PIR1_SSPIF = 0; 
....................       *val = SSPBUF; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
....................  
....................    return i; 
.................... */ 
....................  
....................    int16 i=0; 
....................  
....................    SPISelectEthernet(); 
11DE:  BCF    F95.3
11E0:  BCF    F8C.3
11E2:  CLRF   19
11E4:  BTFSC  FF2.7
11E6:  BSF    19.7
11E8:  BCF    FF2.7
....................    ENCSPIXfer(RBM); 
11EA:  MOVLW  3A
11EC:  MOVWF  xB8
11EE:  MOVLB  0
11F0:  CALL   0132
11F4:  BTFSC  19.7
11F6:  BSF    FF2.7
....................    while(i<len) 
....................    { 
11F8:  MOVLB  2
11FA:  MOVF   x8D,W
11FC:  SUBWF  x8B,W
11FE:  BNC   1244
1200:  BNZ   1208
1202:  MOVF   x8A,W
1204:  SUBWF  x8C,W
1206:  BC    1244
....................       *val=ENCSPIXfer(0); 
1208:  MOVFF  289,03
120C:  MOVFF  288,28E
1210:  MOVFF  289,28F
1214:  CLRF   19
1216:  BTFSC  FF2.7
1218:  BSF    19.7
121A:  BCF    FF2.7
121C:  CLRF   xB8
121E:  MOVLB  0
1220:  CALL   0132
1224:  BTFSC  19.7
1226:  BSF    FF2.7
1228:  MOVFF  28F,FEA
122C:  MOVFF  28E,FE9
1230:  MOVFF  01,FEF
....................       val++; 
1234:  MOVLB  2
1236:  INCF   x88,F
1238:  BTFSC  FD8.2
123A:  INCF   x89,F
....................       i++; 
123C:  INCF   x8C,F
123E:  BTFSC  FD8.2
1240:  INCF   x8D,F
....................    } 
1242:  BRA    11FA
....................    SPIUnselectEthernet(); 
1244:  BCF    F95.3
1246:  BSF    F8C.3
....................  
....................    return(i); 
1248:  MOVFF  28C,01
124C:  MOVFF  28D,02
.................... }//end MACGetArray 
1250:  MOVLB  0
1252:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPut(BYTE val) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           Byte to write into the ENC28J60 buffer memory 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant 
....................  *               (8 bits) and data to write (8 bits) over the SPI. 
....................  *               EWRPT is incremented after the write. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPut(BYTE val) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the opcode and constant. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = val;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until byte is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
168A:  BCF    F95.3
168C:  BCF    F8C.3
168E:  CLRF   19
1690:  BTFSC  FF2.7
1692:  BSF    19.7
1694:  BCF    FF2.7
....................    ENCSPIXfer(WBM); 
1696:  MOVLW  7A
1698:  MOVLB  2
169A:  MOVWF  xB8
169C:  MOVLB  0
169E:  CALL   0132
16A2:  BTFSC  19.7
16A4:  BSF    FF2.7
16A6:  CLRF   19
16A8:  BTFSC  FF2.7
16AA:  BSF    19.7
16AC:  BCF    FF2.7
....................    ENCSPIXfer(val); 
16AE:  MOVFF  29D,2B8
16B2:  CALL   0132
16B6:  BTFSC  19.7
16B8:  BSF    FF2.7
....................    SPIUnselectEthernet(); 
16BA:  BCF    F95.3
16BC:  BSF    F8C.3
.................... }//end MACPut 
16BE:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *               len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *               ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *               calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutArray(BYTE *val, WORD len) 
.................... { 
.................... /* 
....................    // Select the chip and send the proper opcode 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the Write Buffer Memory opcode 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Send the data 
....................    while(len) 
....................    { 
....................       SSPBUF = *val;      // Start sending the byte 
....................       val++;            // Increment after writing to SSPBUF to increase speed 
....................       len--;            // Decrement after writing to SSPBUF to increase speed 
....................       while(!PIR1_SSPIF);   // Wait until byte is transmitted 
....................       PIR1_SSPIF = 0; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
16C0:  BCF    F95.3
16C2:  BCF    F8C.3
16C4:  CLRF   19
16C6:  BTFSC  FF2.7
16C8:  BSF    19.7
16CA:  BCF    FF2.7
....................    ENCSPIXfer(WBM); 
16CC:  MOVLW  7A
16CE:  MOVLB  2
16D0:  MOVWF  xB8
16D2:  MOVLB  0
16D4:  CALL   0132
16D8:  BTFSC  19.7
16DA:  BSF    FF2.7
....................    while(len--) 
....................    { 
16DC:  MOVLB  2
16DE:  MOVFF  2A1,03
16E2:  MOVF   xA0,W
16E4:  BTFSC  FD8.2
16E6:  DECF   xA1,F
16E8:  DECF   xA0,F
16EA:  IORWF  03,W
16EC:  BZ    171E
....................       ENCSPIXfer(*val); 
16EE:  MOVFF  29F,03
16F2:  MOVFF  29E,FE9
16F6:  MOVFF  29F,FEA
16FA:  MOVFF  FEF,2A2
16FE:  CLRF   19
1700:  BTFSC  FF2.7
1702:  BSF    19.7
1704:  BCF    FF2.7
1706:  MOVFF  2A2,2B8
170A:  MOVLB  0
170C:  CALL   0132
1710:  BTFSC  19.7
1712:  BSF    FF2.7
....................       val++; 
1714:  MOVLB  2
1716:  INCF   x9E,F
1718:  BTFSC  FD8.2
171A:  INCF   x9F,F
....................    } 
171C:  BRA    16DE
....................    SPIUnselectEthernet(); 
171E:  BCF    F95.3
1720:  BSF    F8C.3
.................... }//end MACPutArray 
1722:  MOVLB  0
1724:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static void SendSystemReset(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SendSystemReset sends the System Reset SPI command to 
....................  *               the Ethernet controller.  It resets all register contents 
....................  *               (except for ECOCON) and returns the device to the power 
....................  *               on default state. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void SendSystemReset(void) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = SR; 
....................    while(!PIR1_SSPIF);      // Wait until the command is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
0196:  BCF    F95.3
0198:  BCF    F8C.3
....................    ENCSPIXfer(SR); 
019A:  MOVLW  FF
019C:  MOVLB  2
019E:  MOVWF  xB8
01A0:  MOVLB  0
01A2:  RCALL  0132
....................    SPIUnselectEthernet(); 
01A4:  BCF    F95.3
01A6:  BSF    F8C.3
.................... }//end SendSystemReset 
01A8:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadETHReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the ETH control register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's ETH register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over 
....................  *               the SPI and then retrives the register contents in the 
....................  *               next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access MAC/MII or PHY 
....................  *               registers.  Use ReadMACReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadETHReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    // Select the chip and send the Read Control Register opcode/address 
....................    SPISelectEthernet(); 
....................    SSPBUF = RCR | Address; 
....................  
....................    while(!PIR1_SSPIF);      // Wait until the opcode/address is transmitted 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents 
....................    while(!PIR1_SSPIF);      // Wait until the register is received 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
....................    */ 
....................  
....................    SPISelectEthernet(); 
*
016C:  BCF    F95.3
016E:  BCF    F8C.3
....................    ENCSPIXfer(RCR | Address); 
0170:  MOVFF  2A9,2AB
0174:  MOVFF  2A9,2B8
0178:  MOVLB  0
017A:  RCALL  0132
....................    c=ENCSPIXfer(0); 
017C:  MOVLB  2
017E:  CLRF   xB8
0180:  MOVLB  0
0182:  RCALL  0132
0184:  MOVFF  01,2AA
....................    SPIUnselectEthernet(); 
0188:  BCF    F95.3
018A:  BSF    F8C.3
....................    return(c); 
018C:  MOVLB  2
018E:  MOVFF  2AA,01
.................... }//end ReadETHReg 
0192:  MOVLB  0
0194:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadMACReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the MAC or MII register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well 
....................  *               as a dummy byte over the SPI and then retrives the 
....................  *               register contents in the last 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access ETH or PHY 
....................  *               registers.  Use ReadETHReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadMACReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    SPISelectEthernet(); 
....................  
....................    SSPBUF = RCR | Address;   // Send the Read Control Register opcode and 
....................                      //   address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send a dummy byte 
....................    while(!PIR1_SSPIF);      // Wait for the dummy byte to be transmitted 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send another dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
.................... */ 
....................    SPISelectEthernet(); 
*
022E:  BCF    F95.3
0230:  BCF    F8C.3
....................  
....................    ENCSPIXfer(RCR | Address); 
0232:  MOVFF  2B0,2B2
0236:  MOVFF  2B0,2B8
023A:  MOVLB  0
023C:  RCALL  0132
....................    ENCSPIXfer(0); 
023E:  MOVLB  2
0240:  CLRF   xB8
0242:  MOVLB  0
0244:  RCALL  0132
....................    c=ENCSPIXfer(0); 
0246:  MOVLB  2
0248:  CLRF   xB8
024A:  MOVLB  0
024C:  RCALL  0132
024E:  MOVFF  01,2B1
....................  
....................    SPIUnselectEthernet(); 
0252:  BCF    F95.3
0254:  BSF    F8C.3
....................  
....................    return(c); 
0256:  MOVLB  2
0258:  MOVFF  2B1,01
.................... }//end ReadMACReg 
025C:  MOVLB  0
025E:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        ReadPHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to read from. 
....................  * 
....................  * Output:          16 bits of data read from the PHY register. 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 2 
....................  * 
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PHYREG ReadPHYReg(BYTE Register) 
.................... { 
....................    PHYREG Result; 
....................  
....................    // Set the right address and start the register read operation 
....................    BankSel(MIREGADR); 
*
02CE:  MOVLW  02
02D0:  MOVLB  2
02D2:  MOVWF  xB1
02D4:  MOVLW  14
02D6:  MOVWF  xB0
02D8:  MOVLB  0
02DA:  RCALL  0204
....................    WriteReg(MIREGADR, Register); 
02DC:  MOVLW  14
02DE:  MOVLB  2
02E0:  MOVWF  xB3
02E2:  MOVFF  2AD,2B4
02E6:  MOVLB  0
02E8:  RCALL  01AA
....................    WriteReg(MICMD, MICMD_MIIRD); 
02EA:  MOVLW  12
02EC:  MOVLB  2
02EE:  MOVWF  xB3
02F0:  MOVLW  01
02F2:  MOVWF  xB4
02F4:  MOVLB  0
02F6:  RCALL  01AA
....................  
....................    // Loop to wait until the PHY register has been read through the MII 
....................    // This requires 10.24us 
....................    BankSel(MISTAT); 
02F8:  MOVLW  03
02FA:  MOVLB  2
02FC:  MOVWF  xB1
02FE:  MOVLW  0A
0300:  MOVWF  xB0
0302:  MOVLB  0
0304:  RCALL  0204
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
0306:  MOVLW  0A
0308:  MOVLB  2
030A:  MOVWF  xB0
030C:  MOVLB  0
030E:  RCALL  022E
0310:  BTFSC  01.0
0312:  BRA    0306
....................  
....................    // Stop reading 
....................    BankSel(MIREGADR); 
0314:  MOVLW  02
0316:  MOVLB  2
0318:  MOVWF  xB1
031A:  MOVLW  14
031C:  MOVWF  xB0
031E:  MOVLB  0
0320:  RCALL  0204
....................    WriteReg(MICMD, 0x00); 
0322:  MOVLW  12
0324:  MOVLB  2
0326:  MOVWF  xB3
0328:  CLRF   xB4
032A:  MOVLB  0
032C:  RCALL  01AA
....................  
....................    // Obtain results and return 
....................    Result.VAL.v[0] = ReadMACReg(MIRDL).Val; 
032E:  MOVLW  18
0330:  MOVLB  2
0332:  MOVWF  xB0
0334:  MOVLB  0
0336:  RCALL  022E
0338:  MOVFF  01,2AE
....................    Result.VAL.v[1] = ReadMACReg(MIRDH).Val; 
033C:  MOVLW  19
033E:  MOVLB  2
0340:  MOVWF  xB0
0342:  MOVLB  0
0344:  RCALL  022E
0346:  MOVFF  01,2AF
....................    return Result; 
034A:  MOVLB  2
034C:  MOVFF  2AE,01
0350:  MOVFF  2AF,02
.................... }//end ReadPHYReg 
0354:  MOVLB  0
0356:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void WriteReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify. 
....................  *                 The top 3 bits must be 0. 
....................  *               Byte to be written into the register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the 
....................  *               SPI and then sends the data to write in the next 8 SPI 
....................  *               clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the BFCReg() and 
....................  *               BFSReg() functions.  It is seperate to maximize speed. 
....................  *               Unlike the ReadETHReg/ReadMACReg functions, WriteReg() 
....................  *               can write to any ETH or MAC register.  Writing to PHY 
....................  *               registers must be accomplished with WritePHYReg(). 
....................  *****************************************************************************/ 
.................... static void WriteReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WCR | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
01AA:  BCF    F95.3
01AC:  BCF    F8C.3
....................    ENCSPIXfer(WCR | Address); 
01AE:  MOVLB  2
01B0:  MOVF   xB3,W
01B2:  IORLW  40
01B4:  MOVWF  xB5
01B6:  MOVWF  xB8
01B8:  MOVLB  0
01BA:  RCALL  0132
....................    ENCSPIXfer(Data); 
01BC:  MOVFF  2B4,2B8
01C0:  RCALL  0132
....................    SPIUnselectEthernet(); 
01C2:  BCF    F95.3
01C4:  BSF    F8C.3
.................... }//end WriteReg 
01C6:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFCReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                 to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Clear operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFSReg() functions.  It is separate to maximize speed. 
....................  *               BFCReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFCReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFC | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
01C8:  BCF    F95.3
01CA:  BCF    F8C.3
....................    ENCSPIXfer(BFC | Address); 
01CC:  MOVLB  2
01CE:  MOVF   xB2,W
01D0:  IORLW  A0
01D2:  MOVWF  xB4
01D4:  MOVWF  xB8
01D6:  MOVLB  0
01D8:  RCALL  0132
....................    ENCSPIXfer(Data); 
01DA:  MOVFF  2B3,2B8
01DE:  RCALL  0132
....................    SPIUnselectEthernet(); 
01E0:  BCF    F95.3
01E2:  BSF    F8C.3
.................... }//end BFCReg 
01E4:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFSReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Set operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFCReg() functions.  It is separate to maximize speed. 
....................  *               BFSReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFSReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFS | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
01E6:  BCF    F95.3
01E8:  BCF    F8C.3
....................    ENCSPIXfer(BFS | Address); 
01EA:  MOVLB  2
01EC:  MOVF   xB5,W
01EE:  IORLW  80
01F0:  MOVWF  xB7
01F2:  MOVWF  xB8
01F4:  MOVLB  0
01F6:  RCALL  0132
....................    ENCSPIXfer(Data); 
01F8:  MOVFF  2B6,2B8
01FC:  RCALL  0132
....................    SPIUnselectEthernet(); 
01FE:  BCF    F95.3
0200:  BSF    F8C.3
.................... }//end BFSReg 
0202:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WritePHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to write to. 
....................  *               16 bits of data to write to PHY register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 3 
....................  * 
....................  * Overview:        WritePHYReg performs an MII write operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void WritePHYReg(BYTE Register, WORD Data) 
.................... { 
....................    // Write the register address 
....................    BankSel(MIREGADR); 
*
0260:  MOVLW  02
0262:  MOVLB  2
0264:  MOVWF  xB1
0266:  MOVLW  14
0268:  MOVWF  xB0
026A:  MOVLB  0
026C:  RCALL  0204
....................    WriteReg(MIREGADR, Register); 
026E:  MOVLW  14
0270:  MOVLB  2
0272:  MOVWF  xB3
0274:  MOVFF  2AD,2B4
0278:  MOVLB  0
027A:  RCALL  01AA
....................  
....................    // Write the data 
....................    // Order is important: write low byte first, high byte last 
....................    WriteReg(MIWRL, ((WORD_VAL*)&Data)->v[0]); 
027C:  MOVLW  02
027E:  MOVWF  FEA
0280:  MOVLW  AE
0282:  MOVWF  FE9
0284:  MOVFF  FEF,2B2
0288:  MOVLW  16
028A:  MOVLB  2
028C:  MOVWF  xB3
028E:  MOVFF  2B2,2B4
0292:  MOVLB  0
0294:  RCALL  01AA
....................    WriteReg(MIWRH, ((WORD_VAL*)&Data)->v[1]); 
0296:  MOVLW  02
0298:  MOVWF  FEA
029A:  MOVLW  AF
029C:  MOVWF  FE9
029E:  MOVFF  FEF,2B2
02A2:  MOVLW  17
02A4:  MOVLB  2
02A6:  MOVWF  xB3
02A8:  MOVFF  2B2,2B4
02AC:  MOVLB  0
02AE:  RCALL  01AA
....................  
....................    // Wait until the PHY register has been written 
....................    BankSel(MISTAT); 
02B0:  MOVLW  03
02B2:  MOVLB  2
02B4:  MOVWF  xB1
02B6:  MOVLW  0A
02B8:  MOVWF  xB0
02BA:  MOVLB  0
02BC:  RCALL  0204
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
02BE:  MOVLW  0A
02C0:  MOVLB  2
02C2:  MOVWF  xB0
02C4:  MOVLB  0
02C6:  RCALL  022E
02C8:  BTFSC  01.0
02CA:  BRA    02BE
.................... }//end WritePHYReg 
02CC:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BankSel 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Register address with the high byte containing the 2 bank 
....................  *                 select 2 bits. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BankSel takes the high byte of a register address and 
....................  *               changes the bank select bits in ETHCON1 to match. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void BankSel(WORD Register) 
.................... { 
....................    BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0); 
*
0204:  MOVLW  1F
0206:  MOVLB  2
0208:  MOVWF  xB2
020A:  MOVLW  03
020C:  MOVWF  xB3
020E:  MOVLB  0
0210:  RCALL  01C8
....................    BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]); 
0212:  MOVLW  02
0214:  MOVWF  FEA
0216:  MOVLW  B1
0218:  MOVWF  FE9
021A:  MOVFF  FEF,2B4
021E:  MOVLW  1F
0220:  MOVLB  2
0222:  MOVWF  xB5
0224:  MOVFF  2B4,2B6
0228:  MOVLB  0
022A:  RCALL  01E6
.................... }//end BankSel 
022C:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static BOOL TestMemory(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if the memory tests have passed 
....................  *               FALSE if the BIST has detected a hardware fault 
....................  * 
....................  * Side Effects:    Alters the state of numerous control registers and all 
....................  *               RAM bytes. 
....................  * 
....................  * Overview:        The internal BIST and DMA modules are used to fill the 
....................  *               entire dual port memory and calculate a checksum of the 
....................  *               data stored within.  Address and Random fill modes are 
....................  *               used. 
....................  * 
....................  * Note:            For the Random Fill mode, the random number generator is 
....................  *               seeded by the contents of the TMR0L PIC SFR.  If the timer 
....................  *               is running, additional confidence that the memory is 
....................  *               working can be obtained by calling TestMemory multiple 
....................  *               times. 
....................  *****************************************************************************/ 
.................... #if defined(MAC_POWER_ON_TEST) 
.................... static BOOL TestMemory(void) 
.................... { 
....................    #define RANDOM_FILL      0b0000 
....................    #define ADDRESS_FILL   0b0100 
....................    #define PATTERN_SHIFT   0b1000 
....................  
....................    WORD_VAL DMAChecksum, BISTChecksum; 
....................  
....................  
....................    // Select Bank 0 and disable anything that could have been in progress 
....................    WriteReg(ECON1, 0x00); 
....................  
....................    // Set up necessary pointers for the DMA to calculate over the entire 
....................    // memory 
....................    WriteReg(EDMASTL, 0x00); 
....................    WriteReg(EDMASTH, 0x00); 
....................    WriteReg(EDMANDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(EDMANDH, HIGH(RAMSIZE-1u)); 
....................    WriteReg(ERXNDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(ERXNDH, HIGH(RAMSIZE-1u)); 
....................  
....................    // Enable Test Mode and do an Address Fill 
....................    BankSel(EBSTCON); 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                    EBSTCON_BISTST | 
....................                    ADDRESS_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode before 
....................    // starting any DMA operations. 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................    // Compare the results 
....................    // 0xF807 should always be generated in Address fill mode 
....................    if( (DMAChecksum.Val != BISTChecksum.Val) || (DMAChecksum.Val != 0xF807) ) 
....................       return FALSE; 
....................  
....................    // Seed the random number generator and begin another Random Fill test 
....................    // with the DMA and BIST memory access ports swapped. 
.................... #ifdef __C30__ 
....................    WriteReg((BYTE)EBSTSD, TMR1); 
.................... #else 
....................    WriteReg((BYTE)EBSTSD, TMR0L); 
.................... #endif 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                  EBSTCON_PSEL | 
....................                  EBSTCON_BISTST | 
....................                  RANDOM_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode since 
....................    // we won't be needing it anymore 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................  
....................    return (DMAChecksum.Val == BISTChecksum.Val); 
.................... }//end TestMemory 
.................... #endif 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetDuplex(DUPLEX DuplexState) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Member of DUPLEX enum: 
....................  *                  FULL: Set full duplex mode 
....................  *                  HALF: Set half duplex mode 
....................  *                  USE_PHY: Set the MAC to match the PHYDPLXMODE bit in 
....................  *                         PHYCON.  This is controlled by LEDB on RESET. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Changes bank bits to Bank 2. 
....................  * 
....................  * Overview:        Disables RX, TX logic, sets MAC up for full duplex 
....................  *               operation, sets PHY up for full duplex operation, and 
....................  *               reenables RX logic.  The back-to-back inter-packet gap 
....................  *               register (MACBBIPG) is updated to maintain a 9.6us gap. 
....................  * 
....................  * Note:            If a packet is being transmitted or received while this 
....................  *               function is called, it will be aborted. 
....................  *****************************************************************************/ 
.................... void MACSetDuplex(DUPLEX DuplexState) 
.................... { 
....................    REG Register; 
....................    PHYREG PhyReg; 
....................  
....................    // Disable receive logic and abort any packets currently being transmitted 
....................    BFCReg(ECON1, ECON1_TXRTS | ECON1_RXEN); 
*
0358:  MOVLW  1F
035A:  MOVLB  2
035C:  MOVWF  xB2
035E:  MOVLW  0C
0360:  MOVWF  xB3
0362:  MOVLB  0
0364:  RCALL  01C8
....................  
....................    // Set the PHY to the proper duplex mode 
....................    PhyReg = ReadPHYReg(PHCON1); 
0366:  MOVLB  2
0368:  CLRF   xAD
036A:  MOVLB  0
036C:  RCALL  02CE
036E:  MOVFF  02,2AC
0372:  MOVFF  01,2AB
....................    if(DuplexState == USE_PHY) 
0376:  MOVLB  2
0378:  MOVF   xA9,W
037A:  SUBLW  02
037C:  BNZ   0386
....................    { 
....................       DuplexState = PhyReg.PHCON1bits.PDPXMD; 
037E:  CLRF   xA9
0380:  BTFSC  xAC.0
0382:  INCF   xA9,F
....................    } 
....................    else 
0384:  BRA    039C
....................    { 
....................       PhyReg.PHCON1bits.PDPXMD = DuplexState; 
0386:  BCF    xAC.0
0388:  BTFSC  xA9.0
038A:  BSF    xAC.0
....................       WritePHYReg(PHCON1, PhyReg.Val); 
038C:  CLRF   xAD
038E:  MOVFF  2AC,2AF
0392:  MOVFF  2AB,2AE
0396:  MOVLB  0
0398:  RCALL  0260
039A:  MOVLB  2
....................    } 
....................  
....................    // Set the MAC to the proper duplex mode 
....................    BankSel(MACON3); 
039C:  MOVLW  02
039E:  MOVWF  xB1
03A0:  MOVWF  xB0
03A2:  MOVLB  0
03A4:  RCALL  0204
....................    Register = ReadMACReg(MACON3); 
03A6:  MOVLW  02
03A8:  MOVLB  2
03AA:  MOVWF  xB0
03AC:  MOVLB  0
03AE:  RCALL  022E
03B0:  MOVFF  01,2AA
....................    Register.MACON3bits.FULDPX = DuplexState; 
03B4:  MOVLB  2
03B6:  BCF    xAA.0
03B8:  BTFSC  xA9.0
03BA:  BSF    xAA.0
....................    WriteReg(MACON3, Register.Val); 
03BC:  MOVLW  02
03BE:  MOVWF  xB3
03C0:  MOVFF  2AA,2B4
03C4:  MOVLB  0
03C6:  RCALL  01AA
....................  
....................    // Set the back-to-back inter-packet gap time to IEEE specified 
....................    // requirements.  The meaning of the MABBIPG value changes with the duplex 
....................    // state, so it must be updated in this function. 
....................    // In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex 
....................    WriteReg(MABBIPG, DuplexState ? 0x15 : 0x12); 
03C8:  MOVLB  2
03CA:  MOVF   xA9,F
03CC:  BZ    03D2
03CE:  MOVLW  15
03D0:  BRA    03D4
03D2:  MOVLW  12
03D4:  MOVWF  xAD
03D6:  MOVLW  04
03D8:  MOVWF  xB3
03DA:  MOVFF  2AD,2B4
03DE:  MOVLB  0
03E0:  RCALL  01AA
....................  
....................    // Reenable receive logic 
....................    BFSReg(ECON1, ECON1_RXEN); 
03E2:  MOVLW  1F
03E4:  MOVLB  2
03E6:  MOVWF  xB5
03E8:  MOVLW  04
03EA:  MOVWF  xB6
03EC:  MOVLB  0
03EE:  RCALL  01E6
.................... }//end MACSetDuplex 
03F0:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerDown(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In 
....................  *               sleep mode, no packets can be transmitted or received. 
....................  *               All MAC and PHY registers should not be accessed. 
....................  * 
....................  * Note:            If a packet is being transmitted while this function is 
....................  *                called, this function will block until it is it complete. 
....................  *               If anything is being received, it will be completed. 
....................  *****************************************************************************/ 
.................... void MACPowerDown(void) 
.................... { 
....................    // Disable packet reception 
....................    BFCReg(ECON1, ECON1_RXEN); 
....................  
....................    // Make sure any last packet which was in-progress when RXEN was cleared 
....................    // is completed 
....................    while(ReadETHReg(ESTAT).ESTATbits.RXBUSY); 
....................  
....................    // If a packet is being transmitted, wait for it to finish 
....................    while(ReadETHReg(ECON1).ECON1bits.TXRTS); 
....................  
....................    // Enter sleep mode 
....................    BFSReg(ECON2, ECON2_PWRSV); 
.................... }//end MACPowerDown 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerUp(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation 
....................  *               after a previous call to MACPowerDown().  Calling this 
....................  *               function when already powered up will have no effect. 
....................  * 
....................  * Note:            The first packet transmitted may get lost at the RX end if 
....................  *               you don't wait for the link to go up first.  MACIsLinked() 
....................  *               can be called to determine if a link is established. 
....................  *****************************************************************************/ 
.................... void MACPowerUp(void) 
.................... { 
....................    // Leave power down mode 
....................    BFCReg(ECON2, ECON2_PWRSV); 
....................  
....................    // Wait for the 300us Oscillator Startup Timer (OST) to time out.  This 
....................    // delay is required for the PHY module to return to an operational state. 
....................    while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY); 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
.................... }//end MACPowerUp 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetCLKOUT(BYTE NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low) 
....................  *                        0x01: Divide by 1 (25 MHz) 
....................  *                        0x02: Divide by 2 (12.5 MHz) 
....................  *                        0x03: Divide by 3 (8.333333 MHz) 
....................  *                        0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                        0x05: Divide by 8 (3.125 MHz) 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the ECOCON register. 
....................  *               The CLKOUT pin will beginning outputting the new frequency 
....................  *               immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... void SetCLKOUT(BYTE NewConfig) 
.................... { 
....................    BankSel(ECOCON); 
....................    WriteReg(ECOCON, NewConfig); 
.................... }//end SetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE GetCLKOUT(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low) 
....................  *                     0x01: Divide by 1 (25 MHz) 
....................  *                     0x02: Divide by 2 (12.5 MHz) 
....................  *                     0x03: Divide by 3 (8.333333 MHz) 
....................  *                     0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                     0x05: Divide by 8 (3.125 MHz) 
....................  *                     0x06: Reserved 
....................  *                     0x07: Reserved 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the ECOCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE GetCLKOUT(void) 
.................... { 
....................    BankSel(ECOCON); 
....................    return ReadETHReg(ECOCON).Val; 
.................... }//end GetCLKOUT 
....................  
.................... #else 
.................... #include "tcpip/rtl8019AS.c" 
.................... #endif 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
.................... #include "tcpip/modem.c" 
.................... #include "tcpip/ppp.c" 
.................... #include "tcpip/pppwrap.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SLIP 
.................... #include "tcpip/slip.c" 
.................... #ENDIF 
....................  
.................... #if STACK_USE_UDP 
.................... #include "tcpip/udp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #include "tcpip/dhcp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
.................... #include "tcpip/smtp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
.................... #include "tcpip/http.h" 
.................... #endif 
....................  
.................... #if STACK_USE_FAT 
.................... #include "fat/fat_pic.c" 
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
.................... #include "mpfs/mpfs.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
.................... #include "tcpip/http2.h" 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
.................... #include "tcpip/ftp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
.................... #include "tcpip/tftp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
.................... #include "tcpip/dns.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
.................... #include "tcpip/snmp.h" 
.................... #endif 
....................  
.................... /* 
....................  #if STACK_USE_MPFS 
....................  #include "tcpip/mpfs.h" 
....................  #endif 
....................  */ 
....................  
.................... #include "tcpip/ip.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC IP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.C 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail) 
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... // This is left shifted by 4.  Actual value is 0x04. 
.................... #define IPv4                (0x40u) 
.................... #define IP_VERSION          IPv4 
....................  
.................... #define debug_ip 
.................... //#define debug_ip  debug_printf 
....................  
.................... // IHL (Internet Header Length) is # of DWORDs in a header. 
.................... // Since, we do not support options, our IP header length will be 
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5. 
.................... #define IP_IHL              (0x05) 
....................  
.................... #define IP_SERVICE_NW_CTRL  (0x07) 
.................... #define IP_SERVICE_IN_CTRL  (0x06) 
.................... #define IP_SERVICE_ECP      (0x05) 
.................... #define IP_SERVICE_OVR      (0x04) 
.................... #define IP_SERVICE_FLASH    (0x03) 
.................... #define IP_SERVICE_IMM      (0x02) 
.................... #define IP_SERVICE_PRIOR    (0x01) 
.................... #define IP_SERVICE_ROUTINE  (0x00) 
....................  
.................... #define IP_SERVICE_N_DELAY  (0x00) 
.................... #define IP_SERCICE_L_DELAY  (0x08) 
.................... #define IP_SERVICE_N_THRPT  (0x00) 
.................... #define IP_SERVICE_H_THRPT  (0x10) 
.................... #define IP_SERVICE_N_RELIB  (0x00) 
.................... #define IP_SERVICE_H_RELIB  (0x20) 
....................  
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY) 
....................  
.................... #define MY_IP_TTL           (100)   // Time-To-Live in Seconds 
....................  
....................  
....................  
....................  
.................... static WORD _Identifier = 0; 
.................... static BYTE IPHeaderLen; 
....................  
.................... static void SwapIPHeader(IP_HEADER* h); 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len) 
.................... { 
....................     WORD_VAL    CalcChecksum; 
....................     IP_HEADER   header; 
....................  
.................... #if !defined(MCHP_MAC) 
....................     WORD_VAL    ReceivedChecksum; 
....................     WORD        checksums[2]; 
....................     BYTE        optionsLen; 
.................... #define MAX_OPTIONS_LEN     (40)            // As per RFC 791. 
....................     BYTE        options[MAX_OPTIONS_LEN]; 
.................... #endif 
....................  
....................     // Read IP header. 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
*
207A:  MOVLW  01
207C:  MOVLB  2
207E:  MOVWF  x13
2080:  MOVLW  FE
2082:  MOVFF  213,289
2086:  MOVWF  x88
2088:  CLRF   x8B
208A:  MOVLW  14
208C:  MOVWF  x8A
208E:  MOVLB  0
2090:  CALL   11D8
....................  
....................     // Make sure that this is an IPv4 packet. 
....................     if ( (header.VersionIHL & 0xf0) != IP_VERSION ) 
2094:  MOVLB  1
2096:  MOVF   xFE,W
2098:  ANDLW  F0
209A:  SUBLW  40
209C:  BZ    20A4
....................     	return FALSE; 
209E:  MOVLW  00
20A0:  MOVWF  01
20A2:  BRA    2160
....................  
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2; 
20A4:  MOVF   xFE,W
20A6:  ANDLW  0F
20A8:  MOVWF  00
20AA:  RLCF   00,W
20AC:  MOVLB  0
20AE:  MOVWF  x87
20B0:  RLCF   x87,F
20B2:  MOVLW  FC
20B4:  ANDWF  x87,F
....................  
.................... #if defined(MCHP_MAC) 
.................... 	// Validate the IP header.  If it is correct, the checksum 
.................... 	// will come out to 0x0000 (because the header contains a 
.................... 	// precomputed checksum).  A corrupt header will have a 
.................... 	// nonzero checksum. 
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen); 
20B6:  MOVLB  2
20B8:  CLRF   x4E
20BA:  CLRF   x4D
20BC:  CLRF   x50
20BE:  MOVFF  87,24F
20C2:  MOVLB  0
20C4:  RCALL  1D76
20C6:  MOVFF  02,1FD
20CA:  MOVFF  01,1FC
....................  
.................... 	// Seek to the end of the IP header 
.................... 	MACSetRxBuffer(IPHeaderLen); 
20CE:  MOVLB  2
20D0:  CLRF   x26
20D2:  MOVFF  87,225
20D6:  MOVLB  0
20D8:  RCALL  1EDE
....................  
....................     if(CalcChecksum.Val) 
20DA:  MOVLB  1
20DC:  MOVF   xFC,W
20DE:  IORWF  xFD,W
20E0:  BZ    20E8
.................... #else 
....................  
....................     // Calculate options length in this header, if there is any. 
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual 
....................     // length is 4 times IHL. 
....................     optionsLen = ((header.VersionIHL & 0x0f) << 2) - sizeof(header); 
....................  
....................     // If there is any option(s), read it so that we can include them 
....................     // in checksum calculation. 
....................     if ( optionsLen > MAX_OPTIONS_LEN ) 
....................         return FALSE; 
....................  
....................     if ( optionsLen > 0 ) 
....................         MACGetArray(options, optionsLen); 
....................  
....................     // Save header checksum; clear it and recalculate it ourselves. 
....................     ReceivedChecksum.Val = header.HeaderChecksum; 
....................     header.HeaderChecksum = 0; 
....................  
....................     // Calculate checksum of header including options bytes. 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header)); 
....................  
....................     // Calculate Options checksum too, if they are present. 
....................     if ( optionsLen > 0 ) 
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen); 
....................     else 
....................         checksums[1] = 0; 
....................  
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums, 
....................                                             2 * sizeof(WORD)); 
....................  
....................     // Make sure that checksum is correct 
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val ) 
.................... #endif 
....................     { 
....................         // Bad packet. The function caller will be notified by means of the FALSE 
....................         // return value and it should discard the packet. 
....................         return FALSE; 
20E2:  MOVLW  00
20E4:  MOVWF  01
20E6:  BRA    2160
....................     } 
....................  
....................     // Network to host conversion. 
....................     SwapIPHeader(&header); 
20E8:  MOVLW  01
20EA:  MOVLB  2
20EC:  MOVWF  x94
20EE:  MOVLW  FE
20F0:  MOVWF  x93
20F2:  MOVLB  0
20F4:  RCALL  1F9A
....................  
....................     // If caller is intrested, return destination IP address 
....................     // as seen in this IP header. 
....................     if ( localIP ) 
20F6:  MOVLB  1
20F8:  MOVF   xF4,W
20FA:  IORWF  xF5,W
20FC:  BZ    2116
....................         localIP->Val    = header.DestAddress.Val; 
20FE:  MOVFF  1F4,FE9
2102:  MOVFF  1F5,FEA
2106:  MOVFF  20E,FEF
210A:  MOVFF  20F,FEC
210E:  MOVFF  210,FEC
2112:  MOVFF  211,FEC
....................  
....................     remote->IPAddr.Val  = header.SourceAddress.Val; 
2116:  MOVLW  06
2118:  ADDWF  xF6,W
211A:  MOVWF  FE9
211C:  MOVLW  00
211E:  ADDWFC xF7,W
2120:  MOVWF  FEA
2122:  MOVFF  20A,FEF
2126:  MOVFF  20B,FEC
212A:  MOVFF  20C,FEC
212E:  MOVFF  20D,FEC
....................     *protocol           = header.Protocol; 
2132:  MOVFF  1F8,FE9
2136:  MOVFF  1F9,FEA
213A:  MOVFF  207,FEF
.................... #if defined(MCHP_MAC) 
....................     *len 				= header.TotalLength - IPHeaderLen; 
213E:  MOVFF  1FA,FE9
2142:  MOVFF  1FB,FEA
2146:  MOVLB  0
2148:  MOVF   x87,W
214A:  MOVLB  2
214C:  SUBWF  x00,W
214E:  MOVWF  00
2150:  MOVLW  00
2152:  SUBWFB x01,W
2154:  MOVFF  00,FEF
2158:  MOVWF  FEC
.................... #else 
....................     *len                = header.TotalLength - optionsLen - 
....................                             sizeof(header); 
.................... #endif 
....................  
....................     return TRUE; 
215A:  MOVLW  01
215C:  MOVWF  01
215E:  MOVLB  1
.................... } 
2160:  MOVLB  0
2162:  GOTO   4518 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function: WORD IPPutHeader(NODE_INFO *remote, 
....................  *           				  BYTE protocol, 
....................  *                			  WORD len) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           *remote     - Destination node address 
....................  *                  protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          (WORD)0 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  ********************************************************************/ 
.................... WORD IPPutHeader(NODE_INFO *remote, 
....................                 BYTE protocol, 
....................                 WORD    len) 
.................... { 
....................     IP_HEADER   header; 
....................  
....................     IPHeaderLen = sizeof(IP_HEADER); 
*
2CB4:  MOVLW  14
2CB6:  MOVWF  x87
....................  
....................     header.VersionIHL       = IP_VERSION | IP_IHL; 
2CB8:  MOVLW  45
2CBA:  MOVLB  2
2CBC:  MOVWF  x7F
....................     header.TypeOfService    = IP_SERVICE; 
2CBE:  CLRF   x80
....................     header.TotalLength      = sizeof(header) + len; 
2CC0:  MOVLW  14
2CC2:  ADDWF  x7D,W
2CC4:  MOVWF  x81
2CC6:  MOVLW  00
2CC8:  ADDWFC x7E,W
2CCA:  MOVWF  x82
....................     header.Identification   = ++_Identifier; 
2CCC:  MOVLB  0
2CCE:  INCF   x85,F
2CD0:  BTFSC  FD8.2
2CD2:  INCF   x86,F
2CD4:  MOVFF  86,284
2CD8:  MOVFF  85,283
....................     header.FragmentInfo     = 0; 
2CDC:  MOVLB  2
2CDE:  CLRF   x86
2CE0:  CLRF   x85
....................     header.TimeToLive       = MY_IP_TTL; 
2CE2:  MOVLW  64
2CE4:  MOVWF  x87
....................     header.Protocol         = protocol; 
2CE6:  MOVFF  27C,288
....................     header.HeaderChecksum   = 0; 
2CEA:  CLRF   x8A
2CEC:  CLRF   x89
.................... 	header.SourceAddress = AppConfig.MyIPAddr; 
2CEE:  MOVFF  46,28E
2CF2:  MOVFF  45,28D
2CF6:  MOVFF  44,28C
2CFA:  MOVFF  43,28B
....................  
....................     header.DestAddress.Val = remote->IPAddr.Val; 
2CFE:  MOVLW  06
2D00:  ADDWF  x7A,W
2D02:  MOVWF  FE9
2D04:  MOVLW  00
2D06:  ADDWFC x7B,W
2D08:  MOVWF  FEA
2D0A:  MOVFF  FEF,00
2D0E:  MOVFF  FEC,01
2D12:  MOVFF  FEC,02
2D16:  MOVFF  FEC,03
2D1A:  MOVFF  03,292
2D1E:  MOVFF  02,291
2D22:  MOVFF  01,290
2D26:  MOVFF  00,28F
....................  
....................     SwapIPHeader(&header); 
2D2A:  MOVLW  02
2D2C:  MOVWF  x94
2D2E:  MOVLW  7F
2D30:  MOVWF  x93
2D32:  MOVLB  0
2D34:  CALL   1F9A
....................  
.................... #if !defined(MCHP_MAC) 
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, 
....................                                                 sizeof(header)); 
.................... #endif 
....................  
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len)); 
2D38:  MOVLB  2
2D3A:  MOVFF  27A,01
2D3E:  MOVFF  27B,03
2D42:  MOVFF  27A,293
2D46:  MOVFF  27B,294
2D4A:  MOVLW  14
2D4C:  ADDWF  x7D,W
2D4E:  MOVWF  x95
2D50:  MOVLW  00
2D52:  ADDWFC x7E,W
2D54:  MOVWF  x96
2D56:  MOVFF  27B,298
2D5A:  MOVFF  27A,297
2D5E:  CLRF   x99
2D60:  MOVWF  x9B
2D62:  MOVFF  295,29A
2D66:  MOVLB  0
2D68:  CALL   1726
....................     MACPutArray((BYTE*)&header, sizeof(header)); 
2D6C:  MOVLW  02
2D6E:  MOVLB  2
2D70:  MOVWF  x94
2D72:  MOVLW  7F
2D74:  MOVFF  294,29F
2D78:  MOVWF  x9E
2D7A:  CLRF   xA1
2D7C:  MOVLW  14
2D7E:  MOVWF  xA0
2D80:  MOVLB  0
2D82:  CALL   16C0
....................  
.................... #if defined(MCHP_MAC) 
.................... 	header.HeaderChecksum = MACCalcTxChecksum(0, sizeof(header)); 
2D86:  MOVLB  2
2D88:  CLRF   x94
2D8A:  CLRF   x93
2D8C:  CLRF   x96
2D8E:  MOVLW  14
2D90:  MOVWF  x95
2D92:  MOVLB  0
2D94:  RCALL  2B80
2D96:  MOVFF  02,28A
2D9A:  MOVFF  01,289
.................... 	MACSetTxBuffer(CurrentTxBuffer, 10);	// 10 is the offset in header to the HeaderChecksum member 
2D9E:  MOVFF  7A,293
2DA2:  MOVLB  2
2DA4:  CLRF   x95
2DA6:  MOVLW  0A
2DA8:  MOVWF  x94
2DAA:  MOVLB  0
2DAC:  CALL   15C4
.................... 	MACPutArray((BYTE*)&header.HeaderChecksum, 2); 
2DB0:  MOVLW  02
2DB2:  MOVLB  2
2DB4:  MOVWF  x94
2DB6:  MOVLW  89
2DB8:  MOVFF  294,29F
2DBC:  MOVWF  x9E
2DBE:  CLRF   xA1
2DC0:  MOVLW  02
2DC2:  MOVWF  xA0
2DC4:  MOVLB  0
2DC6:  CALL   16C0
.................... 	MACSetTxBuffer(CurrentTxBuffer, sizeof(header));	// Seek back to the end of the packet 
2DCA:  MOVFF  7A,293
2DCE:  MOVLB  2
2DD0:  CLRF   x95
2DD2:  MOVLW  14
2DD4:  MOVWF  x94
2DD6:  MOVLB  0
2DD8:  CALL   15C4
.................... #endif 
....................  
....................     return 0x0; 
2DDC:  MOVLW  00
2DDE:  MOVWF  01
2DE0:  MOVWF  02
.................... } 
2DE2:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset) 
.................... { 
.................... 	MACSetRxBuffer(Offset+IPHeaderLen); 
*
246C:  MOVF   x87,W
246E:  MOVLB  2
2470:  ADDWF  x21,W
2472:  MOVWF  x23
2474:  MOVLW  00
2476:  ADDWFC x22,W
2478:  MOVWF  x24
247A:  MOVWF  x26
247C:  MOVFF  223,225
2480:  MOVLB  0
2482:  RCALL  1EDE
.................... } 
2484:  RETLW  00
....................  
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h) 
.................... { 
....................     h->TotalLength      = swaps(h->TotalLength); 
*
1F9A:  MOVLW  02
1F9C:  MOVLB  2
1F9E:  ADDWF  x93,W
1FA0:  MOVWF  01
1FA2:  MOVLW  00
1FA4:  ADDWFC x94,W
1FA6:  MOVWF  03
1FA8:  MOVFF  01,295
1FAC:  MOVWF  x96
1FAE:  MOVLW  02
1FB0:  ADDWF  x93,W
1FB2:  MOVWF  FE9
1FB4:  MOVLW  00
1FB6:  ADDWFC x94,W
1FB8:  MOVWF  FEA
1FBA:  MOVFF  FEC,298
1FBE:  MOVF   FED,F
1FC0:  MOVFF  FEF,297
1FC4:  MOVFF  298,29A
1FC8:  MOVFF  297,299
1FCC:  MOVLB  0
1FCE:  CALL   1254
1FD2:  MOVFF  296,FEA
1FD6:  MOVFF  295,FE9
1FDA:  MOVFF  02,FEC
1FDE:  MOVF   FED,F
1FE0:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification); 
1FE4:  MOVLW  04
1FE6:  MOVLB  2
1FE8:  ADDWF  x93,W
1FEA:  MOVWF  01
1FEC:  MOVLW  00
1FEE:  ADDWFC x94,W
1FF0:  MOVWF  03
1FF2:  MOVFF  01,295
1FF6:  MOVWF  x96
1FF8:  MOVLW  04
1FFA:  ADDWF  x93,W
1FFC:  MOVWF  FE9
1FFE:  MOVLW  00
2000:  ADDWFC x94,W
2002:  MOVWF  FEA
2004:  MOVFF  FEC,298
2008:  MOVF   FED,F
200A:  MOVFF  FEF,297
200E:  MOVFF  298,29A
2012:  MOVFF  297,299
2016:  MOVLB  0
2018:  CALL   1254
201C:  MOVFF  296,FEA
2020:  MOVFF  295,FE9
2024:  MOVFF  02,FEC
2028:  MOVF   FED,F
202A:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum); 
202E:  MOVLW  0A
2030:  MOVLB  2
2032:  ADDWF  x93,W
2034:  MOVWF  01
2036:  MOVLW  00
2038:  ADDWFC x94,W
203A:  MOVWF  03
203C:  MOVFF  01,295
2040:  MOVWF  x96
2042:  MOVLW  0A
2044:  ADDWF  x93,W
2046:  MOVWF  FE9
2048:  MOVLW  00
204A:  ADDWFC x94,W
204C:  MOVWF  FEA
204E:  MOVFF  FEC,298
2052:  MOVF   FED,F
2054:  MOVFF  FEF,297
2058:  MOVFF  298,29A
205C:  MOVFF  297,299
2060:  MOVLB  0
2062:  CALL   1254
2066:  MOVFF  296,FEA
206A:  MOVFF  295,FE9
206E:  MOVFF  02,FEC
2072:  MOVF   FED,F
2074:  MOVFF  01,FEF
.................... } 
2078:  RETLW  00
....................  
....................  
.................... #if STACK_USE_TCP 
.................... #include "tcpip/tcp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module for Microchip TCP/IP Stack 
....................  *               Based on RFC 793 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.C 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  *                  ARP.h 
....................  *                  Tick.h 
....................  *                  TCP.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        CCS PCH 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     11/1/02 Fixed TCPTick() SYN Retry bug. 
....................  * Darren Rook (CCS)    06/28/04  Applied 2.20 fix (above) 
....................  * Darren Rook (CCS)    06/30/04 TCPTick() will not time out an establisehd socket if that socket is in server mode. 
....................  * Darren Rook (CCS)    07/02/04 A bug fix for change made on 06/28/04 
....................  * Darren Rook (CCS)    07/12/04 TCPConnect() will set StartTick to fix a bug with timeout 
....................  * Darren Rook (CCS)    07/12/04 TCPInit() attempts to make _NextPort a random number 
....................  * Darren Rook (CCS)    07/12/06 startTick spelled wrong (case) 
....................  * Nilesh Rajbharti     12/5/02   Modified TCPProcess() 
....................  *                              to include localIP as third param. 
....................  *                              This was done to allow this function 
....................  *                              to calculate checksum correctly. 
....................  * Roy Schofield      10/1/04   TCPConnect() startTick bug fix. 
....................  * Howard Schlunder      1/3/05   Fixed HandleTCPSeg() unexpected 
....................  *                         discard problem identified by Richard 
....................  *                         Shelquist. 
....................  * Howard Schlunder      1/16/06   Fixed an imporbable RX checksum bug 
....................  *                        when using a Microchip Ethernet controller) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    09/18/06 Added TCPPutAvailable() 
....................  * Howard Schlunder      5/10/06   Revised TCP state machine, add TCP_FIN_2 
....................  * Howard Schlunder      8/01/06 Adjusted response to ACK only in TCP_SYN_SENT state 
....................  * Howard Schlunder      8/03/06 Fixed checksum comparison check 
....................  *                        reported by DouglasPunch on Microchip Forum. 
....................  * Howard Schlunder      8/11/06 Fixed a resource leak causing MAC TX 
....................  *                        Buffers to be obtained but not 
....................  *                        released when many web requests were 
....................  *                        received concurrently. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.75 stack 
....................  * Darren Rook (CCS)   01/03/07 Fixed a bug in TCPPutArray() 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               12 // 10 original value (MiE) 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tcp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        CCS PCH 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip")  
....................  * and is supplied to you for use exclusively as described in the  
....................  * associated software agreement.  This software is protected by  
....................  * software and other intellectual property laws.  Any use in  
....................  * violation of the software license may subject the user to criminal  
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL  
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED  
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND  
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,  
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     12/5/03 Modified TCPProcess() prototype. 
....................  *                              See TCP.c for more information. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef TCP_H 
.................... #define TCP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               12 // 10 original value (MiE) 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... typedef BYTE TCP_SOCKET; 
.................... typedef WORD TCP_PORT; 
....................  
.................... #ifndef TCP_NO_WAIT_FOR_ACK 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * Maximum number of times a connection be retried before 
....................  * closing it down. 
....................  */ 
.................... #define MAX_RETRY_COUNTS    (3) 
....................  
.................... #define INVALID_SOCKET      (0xfe) 
.................... #define UNKNOWN_SOCKET      (0xff) 
....................  
.................... #define REMOTE_HOST(s)      (TCB[s].remote) 
....................  
.................... /* 
....................  * TCP States as defined by rfc793 
....................  */ 
.................... typedef enum _TCP_STATE 
.................... { 
....................     TCP_LISTEN = 0, 
....................     TCP_SYN_SENT, 
....................     TCP_SYN_RECEIVED, 
....................     TCP_ESTABLISHED, 
....................     TCP_FIN_WAIT_1, 
....................     TCP_FIN_WAIT_2, 
....................     TCP_CLOSING, 
....................     TCP_TIME_WAIT, 
....................    TCP_CLOSE_WAIT, 
....................     TCP_LAST_ACK, 
....................     TCP_CLOSED, 
.................... } TCP_STATE; 
....................  
.................... /* 
....................  * Socket info. 
....................  * Union is used to create anonymous structure members. 
....................  */ 
.................... typedef struct _SOCKET_INFO 
.................... { 
....................     TCP_STATE smState; 
....................  
....................     NODE_INFO remote; 
....................     TCP_PORT localPort; 
....................     TCP_PORT remotePort; 
....................  
....................     BUFFER TxBuffer; 
....................     WORD TxCount; 
....................     WORD RxCount; 
....................    WORD RemoteWindow; 
....................     
....................     DWORD SND_SEQ; 
....................     DWORD SND_ACK; 
....................  
....................     BYTE RetryCount; 
....................     TICKTYPE startTick; 
....................     TICKTYPE TimeOut; 
....................  
....................     struct 
....................     { 
....................         int1 bServer        : 1; 
....................         int1 bIsPutReady    : 1; 
....................         int1 bFirstRead     : 1; 
....................         int1 bIsGetReady    : 1; 
....................         int1 bIsTxInProgress : 1; 
....................         int1 bACKValid : 1; 
....................     } Flags; 
....................  
.................... } SOCKET_INFO; 
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TCP is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initialize all socket info. 
....................  * 
....................  * Note:            This function is called only one during lifetime 
....................  *                  of the application. 
....................  ********************************************************************/ 
.................... void        TCPInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           port    - A TCP port to be opened. 
....................  * 
....................  * Output:          Given port is opened and returned on success 
....................  *                  INVALID_SOCKET if no more sockets left. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TCP_SOCKET  TCPListen(TCP_PORT port); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
....................  *                                      TCP_PORT remotePort) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           remote      - Remote node address info 
....................  *                  remotePort  - remote port to be connected. 
....................  * 
....................  * Output:          A new socket is created, connection request is 
....................  *                  sent and socket handle is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT port); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsConnected(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPDisconnect(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsPutReady(s) == TRUE 
....................  * 
....................  * Input:           s       - Socket to be disconnected. 
....................  * 
....................  * Output:          A disconnect request is sent for given socket. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPDisconnect(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsPutReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s       - socket to use 
....................  *                  byte    - a data byte to send 
....................  * 
....................  * Output:          TRUE if given byte was put in transmit buffer 
....................  *                  FALSE if transmit buffer is full. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPPut(TCP_SOCKET socket, BYTE data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPFlush(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket whose data is to be transmitted. 
....................  * 
....................  * Output:          All and any data associated with this socket 
....................  *                  is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPFlush(TCP_SOCKET socket); 
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPIsGetReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPGet(TCP_SOCKET socket, int8 *data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD        TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPDiscard(TCP_SOCKET socket); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPProcess(NODE_INFO* remote, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  len         - Total length of TCP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPProcess(NODE_INFO *remote, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPTick(void) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Each socket FSM is executed for any timeout 
....................  *                  situation. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPTick(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define debug_tcp(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
.................... //#define debug_tcp debug_printf 
....................  
.................... // Max TCP data length is MAC_TX_BUFFER_SIZE - sizeof(TCP_HEADER) - 
.................... // sizeof(IP_HEADER) - sizeof(ETHER_HEADER) 
.................... #define MAX_TCP_DATA_LEN    (MAC_TX_BUFFER_SIZE - 54) 
....................  
.................... // TCP Timeout value to begin with. 
.................... #define TCP_START_TIMEOUT_VAL   (TICKS_PER_SECOND * (TICKTYPE)3) 
....................  
.................... // TCP Flags defined in RFC 
.................... #define FIN     (0x01) 
.................... #define SYN     (0x02) 
.................... #define RST     (0x04) 
.................... #define PSH     (0x08) 
.................... #define ACK     (0x10) 
.................... #define URG     (0x20) 
....................  
.................... // TCP Header 
.................... typedef struct _TCP_HEADER { 
....................    WORD SourcePort; 
....................    WORD DestPort; 
....................    DWORD SeqNumber; 
....................    DWORD AckNumber; 
....................  
....................    struct { 
....................       BYTE Reserved3 :4; 
....................       BYTE Val :4; 
....................    } DataOffset; 
....................  
....................    union { 
....................       struct { 
....................          int1 flagFIN :1; 
....................          int1 flagSYN :1; 
....................          int1 flagRST :1; 
....................          int1 flagPSH :1; 
....................          int1 flagACK :1; 
....................          int1 flagURG :1; 
....................          int1 Reserved2 :2; 
....................       } bits; 
....................       BYTE b; 
....................    } Flags; 
....................  
....................    WORD Window; 
....................    WORD Checksum; 
....................    WORD UrgentPointer; 
.................... } TCP_HEADER; 
....................  
.................... // TCP Options as defined by RFC 
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00) 
.................... #define TCP_OPTIONS_NO_OP           (0x01) 
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02) 
.................... typedef struct _TCP_OPTIONS { 
....................    BYTE Kind; 
....................    BYTE Length; 
....................    WORD_VAL MaxSegSize; 
.................... } TCP_OPTIONS; 
....................  
.................... #define SwapPseudoTCPHeader(h)  (h.TCPLength = swaps(h.TCPLength)) 
....................  
.................... // IP pseudo header as defined by RFC 793 
.................... typedef struct _PSEUDO_HEADER { 
....................    IP_ADDR SourceAddress; 
....................    IP_ADDR DestAddress; 
....................    BYTE Zero; 
....................    BYTE Protocol; 
....................    WORD TCPLength; 
.................... } PSEUDO_HEADER; 
....................  
.................... #define LOCAL_PORT_START_NUMBER (1024) 
.................... #define LOCAL_PORT_END_NUMBER   (5000) 
....................  
.................... // Local temp port numbers. 
.................... static WORD _NextPort = LOCAL_PORT_START_NUMBER; 
....................  
.................... // The TCB array is very large.  With the C18 compiler, one must 
.................... // modify the linker script to make an array that spans more than 
.................... // one memory bank.  To do this, make the necessary changes to your 
.................... // processor's linker script (.lkr).  Here is an example showing 
.................... // gpr11 and 128 bytes of gpr12 being combined into one 384 byte 
.................... // block used exclusively by the TCB_MEM data section: 
.................... // ... 
.................... // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF 
.................... // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF 
.................... // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED 
.................... // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF 
.................... // ... 
.................... // SECTION    NAME=TCB_MEM    RAM=gpr11b 
.................... // ... 
.................... //#pragma udata TCB_MEM   //not needed in ccs 
.................... SOCKET_INFO TCB[MAX_SOCKETS]; 
.................... //   #pragma udata bla   // Return to any other RAM section   //not needed in ccs 
....................  
.................... static void HandleTCPSeg(TCP_SOCKET s, NODE_INFO *remote, TCP_HEADER *h, 
....................       WORD len); 
....................  
.................... static void TransmitTCP(NODE_INFO *remote, TCP_PORT localPort, 
....................       TCP_PORT remotePort, DWORD tseq, DWORD tack, BYTE flags, BUFFER buff, 
....................       WORD len); 
....................  
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, NODE_INFO *remote); 
.................... static void SwapTCPHeader(TCP_HEADER* header); 
.................... static void CloseSocket(SOCKET_INFO* ps); 
....................  
.................... #define SendTCP(remote, localPort, remotePort, seq, ack, flags)     \ 
....................         TransmitTCP(remote, localPort, remotePort, seq, ack, flags, \ 
....................                     INVALID_BUFFER, 0) 
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TCP is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initialize all socket states 
....................  * 
....................  * Note:            This function is called only once during lifetime 
....................  *                  of the application. 
....................  ********************************************************************/ 
.................... int16 TCPInit_RandSeed; 
.................... void TCPInit(void) { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................  
....................    // Initialize all sockets. 
....................    for (s = 0; s < MAX_SOCKETS; s++) { 
*
0712:  MOVLB  2
0714:  CLRF   xA8
0716:  MOVF   xA8,W
0718:  SUBLW  04
071A:  BNC   07EC
....................       ps = &TCB[s]; 
071C:  MOVF   xA8,W
071E:  MULLW  24
0720:  MOVF   FF3,W
0722:  CLRF   03
0724:  ADDLW  8A
0726:  MOVWF  01
0728:  MOVLW  00
072A:  ADDWFC 03,F
072C:  MOVFF  01,2A9
0730:  MOVFF  03,2AA
....................  
....................       ps->smState = TCP_CLOSED; 
0734:  MOVFF  2A9,FE9
0738:  MOVFF  2AA,FEA
073C:  MOVLW  0A
073E:  MOVWF  FEF
....................       ps->Flags.bServer = FALSE; 
0740:  MOVLW  23
0742:  ADDWF  xA9,W
0744:  MOVWF  FE9
0746:  MOVLW  00
0748:  ADDWFC xAA,W
074A:  MOVWF  FEA
074C:  BCF    FEF.0
....................       ps->Flags.bIsPutReady = TRUE; 
074E:  MOVLW  23
0750:  ADDWF  xA9,W
0752:  MOVWF  FE9
0754:  MOVLW  00
0756:  ADDWFC xAA,W
0758:  MOVWF  FEA
075A:  BSF    FEF.1
....................       ps->Flags.bFirstRead = TRUE; 
075C:  MOVLW  23
075E:  ADDWF  xA9,W
0760:  MOVWF  FE9
0762:  MOVLW  00
0764:  ADDWFC xAA,W
0766:  MOVWF  FEA
0768:  BSF    FEF.2
....................       ps->Flags.bIsTxInProgress = FALSE; 
076A:  MOVLW  23
076C:  ADDWF  xA9,W
076E:  MOVWF  FE9
0770:  MOVLW  00
0772:  ADDWFC xAA,W
0774:  MOVWF  FEA
0776:  BCF    FEF.4
....................       ps->Flags.bIsGetReady = FALSE; 
0778:  MOVLW  23
077A:  ADDWF  xA9,W
077C:  MOVWF  FE9
077E:  MOVLW  00
0780:  ADDWFC xAA,W
0782:  MOVWF  FEA
0784:  BCF    FEF.3
....................       if (ps->TxBuffer != INVALID_BUFFER) { 
0786:  MOVLW  0F
0788:  ADDWF  xA9,W
078A:  MOVWF  FE9
078C:  MOVLW  00
078E:  ADDWFC xAA,W
0790:  MOVWF  FEA
0792:  INCFSZ FEF,W
0794:  BRA    0798
0796:  BRA    07C2
....................          MACDiscardTx(ps->TxBuffer); 
0798:  MOVLW  0F
079A:  ADDWF  xA9,W
079C:  MOVWF  FE9
079E:  MOVLW  00
07A0:  ADDWFC xAA,W
07A2:  MOVWF  FEA
07A4:  MOVFF  FEF,2AB
07A8:  MOVFF  2AB,2AC
07AC:  MOVLB  0
07AE:  RCALL  0004
....................          ps->TxBuffer = INVALID_BUFFER; 
07B0:  MOVLW  0F
07B2:  MOVLB  2
07B4:  ADDWF  xA9,W
07B6:  MOVWF  FE9
07B8:  MOVLW  00
07BA:  ADDWFC xAA,W
07BC:  MOVWF  FEA
07BE:  MOVLW  FF
07C0:  MOVWF  FEF
....................       } 
....................       ps->TimeOut = TCP_START_TIMEOUT_VAL; 
07C2:  MOVLW  21
07C4:  ADDWF  xA9,W
07C6:  MOVWF  FE9
07C8:  MOVLW  00
07CA:  ADDWFC xAA,W
07CC:  MOVWF  FEA
07CE:  CLRF   FEC
07D0:  MOVF   FED,F
07D2:  MOVLW  24
07D4:  MOVWF  FEF
....................       ps->TxCount = 0; 
07D6:  MOVLW  10
07D8:  ADDWF  xA9,W
07DA:  MOVWF  FE9
07DC:  MOVLW  00
07DE:  ADDWFC xAA,W
07E0:  MOVWF  FEA
07E2:  CLRF   FEC
07E4:  MOVF   FED,F
07E6:  CLRF   FEF
....................    } 
....................  
....................    //_NextPort = LOCAL_PORT_START_NUMBER; 
.................... #if getenv("TIMER0") 
07E8:  INCF   xA8,F
07EA:  BRA    0716
....................    TCPInit_RandSeed+=get_timer0(); 
07EC:  MOVF   FD6,W
07EE:  MOVLB  1
07F0:  ADDWF  x3E,F
07F2:  MOVF   FD7,W
07F4:  ADDWFC x3F,F
.................... #endif 
.................... #if getenv("TIMER1") 
....................    TCPInit_RandSeed+=get_timer1(); 
07F6:  MOVF   FCE,W
07F8:  ADDWF  x3E,F
07FA:  MOVF   FCF,W
07FC:  ADDWFC x3F,F
.................... #endif 
.................... #if getenv("TIMER2") 
....................    TCPInit_RandSeed+=get_timer2(); 
07FE:  MOVF   FCC,W
0800:  ADDWF  x3E,F
0802:  MOVLW  00
0804:  ADDWFC x3F,F
.................... #endif 
.................... #if getenv("TIMER3") 
....................    TCPInit_RandSeed+=get_timer3(); 
0806:  MOVF   FB2,W
0808:  ADDWF  x3E,F
080A:  MOVF   FB3,W
080C:  ADDWFC x3F,F
.................... #endif 
.................... #if getenv("TIMER4") 
....................    TCPInit_RandSeed+=get_timer4(); 
.................... #endif 
.................... #if getenv("TIMER5") 
....................    TCPInit_RandSeed+=get_timer5(); 
.................... #endif 
....................    srand(TCPInit_RandSeed); 
080E:  MOVLB  2
0810:  CLRF   xAE
0812:  CLRF   xAD
0814:  MOVFF  13F,2AC
0818:  MOVFF  13E,2AB
081C:  MOVLB  0
081E:  RCALL  05DC
....................    _NextPort = rand(); 
0820:  RCALL  0690
0822:  MOVFF  02,89
0826:  MOVFF  01,88
....................    _NextPort += LOCAL_PORT_START_NUMBER; 
082A:  MOVLW  04
082C:  ADDWF  x89,F
....................    while (_NextPort >= LOCAL_PORT_END_NUMBER) { 
082E:  MOVF   x89,W
0830:  SUBLW  12
0832:  BC    0848
0834:  XORLW  FF
0836:  BNZ   083E
0838:  MOVF   x88,W
083A:  SUBLW  87
083C:  BC    0848
....................       _NextPort -= LOCAL_PORT_END_NUMBER; 
083E:  MOVLW  88
0840:  SUBWF  x88,F
0842:  MOVLW  13
0844:  SUBWFB x89,F
....................    } 
0846:  BRA    082E
....................    if (_NextPort < LOCAL_PORT_START_NUMBER) { 
0848:  MOVF   x89,W
084A:  SUBLW  03
084C:  BNC   0852
....................       _NextPort += LOCAL_PORT_START_NUMBER; 
084E:  MOVLW  04
0850:  ADDWF  x89,F
....................    } 
.................... } 
0852:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           port    - A TCP port to be opened. 
....................  * 
....................  * Output:          Given port is opened and returned on success 
....................  *                  INVALID_SOCKET if no more sockets left. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TCP_SOCKET TCPListen(TCP_PORT port) { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................  
....................    //debug_tcp("\r\nTCP LISTEN PORT=%LU -> ", port); 
....................  
....................    for (s = 0; s < MAX_SOCKETS; s++) { 
....................       ps = &TCB[s]; 
....................  
....................       if (ps->smState == TCP_CLOSED) { 
....................          // We have a CLOSED socket. 
....................          // Initialize it with LISTENing state info. 
....................          ps->smState = TCP_LISTEN; 
....................          ps->localPort = port; 
....................          ps->remotePort = 0; 
....................  
....................          // There is no remote node IP address info yet. 
....................          ps->remote.IPAddr.Val = 0x00; 
....................  
....................          // If a socket is listened on, it is a SERVER. 
....................          ps->Flags.bServer = TRUE; 
....................  
....................          ps->Flags.bIsGetReady = FALSE; 
....................          if (ps->TxBuffer != INVALID_BUFFER) { 
....................             MACDiscardTx(ps->TxBuffer); 
....................             ps->TxBuffer = INVALID_BUFFER; 
....................          } 
....................          ps->Flags.bIsPutReady = TRUE; 
....................  
....................          //debug_tcp("SOCK=%U", s); 
....................  
....................          return s; 
....................       } 
....................    } 
....................  
....................    //debug_tcp("FAIL"); 
....................  
....................    return INVALID_SOCKET; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
....................  *                                      TCP_PORT remotePort) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           remote      - Remote node address info 
....................  *                  remotePort  - remote port to be connected. 
....................  * 
....................  * Output:          A new socket is created, connection request is 
....................  *                  sent and socket handle is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT remotePort) { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................    BOOL lbFound; 
....................  
....................    lbFound = FALSE; 
*
4D52:  MOVLB  2
4D54:  BCF    x12.0
....................  
....................    //debug_tcp("\r\nTCP CONNECT PORT=%LU -> ", remotePort); 
....................  
....................    // Find an available socket 
....................    for (s = 0; s < MAX_SOCKETS; s++) { 
4D56:  CLRF   x0F
4D58:  MOVF   x0F,W
4D5A:  SUBLW  04
4D5C:  BNC   4D8C
....................       ps = &TCB[s]; 
4D5E:  MOVF   x0F,W
4D60:  MULLW  24
4D62:  MOVF   FF3,W
4D64:  CLRF   03
4D66:  ADDLW  8A
4D68:  MOVWF  01
4D6A:  MOVLW  00
4D6C:  ADDWFC 03,F
4D6E:  MOVFF  01,210
4D72:  MOVFF  03,211
....................       if (ps->smState == TCP_CLOSED) { 
4D76:  MOVFF  210,FE9
4D7A:  MOVFF  211,FEA
4D7E:  MOVF   FEF,W
4D80:  SUBLW  0A
4D82:  BNZ   4D88
....................          lbFound = TRUE; 
4D84:  BSF    x12.0
....................          break; 
4D86:  BRA    4D8C
....................       } 
....................    } 
4D88:  INCF   x0F,F
4D8A:  BRA    4D58
....................  
....................    // If there is no socket available, return error. 
....................    if (!lbFound) 
4D8C:  BTFSC  x12.0
4D8E:  BRA    4D96
....................       return INVALID_SOCKET; 
4D90:  MOVLW  FE
4D92:  MOVWF  01
4D94:  BRA    4F6A
....................  
....................    // Each new socket that is opened by this node, gets 
....................    // next sequential port number. 
....................    ps->localPort = ++_NextPort; 
4D96:  MOVLW  0B
4D98:  ADDWF  x10,W
4D9A:  MOVWF  FE9
4D9C:  MOVLW  00
4D9E:  ADDWFC x11,W
4DA0:  MOVWF  FEA
4DA2:  MOVLB  0
4DA4:  INCF   x88,F
4DA6:  BTFSC  FD8.2
4DA8:  INCF   x89,F
4DAA:  MOVFF  89,FEC
4DAE:  MOVF   FED,F
4DB0:  MOVFF  88,FEF
....................    if (_NextPort >= LOCAL_PORT_END_NUMBER) 
4DB4:  MOVF   x89,W
4DB6:  SUBLW  12
4DB8:  BC    4DCC
4DBA:  XORLW  FF
4DBC:  BNZ   4DC4
4DBE:  MOVF   x88,W
4DC0:  SUBLW  87
4DC2:  BC    4DCC
....................       _NextPort = LOCAL_PORT_START_NUMBER - 1; 
4DC4:  MOVLW  03
4DC6:  MOVWF  x89
4DC8:  MOVLW  FF
4DCA:  MOVWF  x88
....................  
....................    // This is a client socket. 
....................    ps->Flags.bServer = FALSE; 
4DCC:  MOVLW  23
4DCE:  MOVLB  2
4DD0:  ADDWF  x10,W
4DD2:  MOVWF  FE9
4DD4:  MOVLW  00
4DD6:  ADDWFC x11,W
4DD8:  MOVWF  FEA
4DDA:  BCF    FEF.0
....................  
....................    // This is the port, we are trying to connect to. 
....................    ps->remotePort = remotePort; 
4DDC:  MOVLW  0D
4DDE:  ADDWF  x10,W
4DE0:  MOVWF  FE9
4DE2:  MOVLW  00
4DE4:  ADDWFC x11,W
4DE6:  MOVWF  FEA
4DE8:  MOVFF  20E,FEC
4DEC:  MOVF   FED,F
4DEE:  MOVFF  20D,FEF
....................  
....................    // Each new socket that is opened by this node, will 
....................    // start with next the next seqeuence number (essentially random) 
....................    ps->SND_SEQ++; 
4DF2:  MOVLW  16
4DF4:  ADDWF  x10,W
4DF6:  MOVWF  FE9
4DF8:  MOVLW  00
4DFA:  ADDWFC x11,W
4DFC:  MOVWF  FEA
4DFE:  MOVLW  01
4E00:  ADDWF  FEE,F
4E02:  MOVLW  00
4E04:  ADDWFC FEE,F
4E06:  ADDWFC FEE,F
4E08:  ADDWFC FED,F
....................    ps->SND_ACK = 0; 
4E0A:  MOVLW  1A
4E0C:  ADDWF  x10,W
4E0E:  MOVWF  FE9
4E10:  MOVLW  00
4E12:  ADDWFC x11,W
4E14:  MOVWF  FEA
4E16:  MOVF   FEE,F
4E18:  MOVF   FEE,F
4E1A:  CLRF   FEC
4E1C:  MOVF   FED,F
4E1E:  CLRF   FEF
4E20:  MOVF   FED,F
4E22:  CLRF   FEF
4E24:  MOVF   FED,F
4E26:  CLRF   FEF
....................  
....................    memcpy((BYTE*) &ps->remote, (void*) remote, sizeof(ps->remote)); 
4E28:  MOVLW  01
4E2A:  ADDWF  x10,W
4E2C:  MOVWF  01
4E2E:  MOVLW  00
4E30:  ADDWFC x11,W
4E32:  MOVWF  03
4E34:  MOVFF  01,213
4E38:  MOVWF  x14
4E3A:  MOVWF  FEA
4E3C:  MOVFF  01,FE9
4E40:  MOVFF  20C,FE2
4E44:  MOVFF  20B,FE1
4E48:  MOVLW  0A
4E4A:  MOVWF  01
4E4C:  MOVFF  FE6,FEE
4E50:  DECFSZ 01,F
4E52:  BRA    4E4C
....................  
....................    // Send SYN message. 
....................    SendTCP(&ps->remote, ps->localPort, ps->remotePort, ps->SND_SEQ, 
....................          ps->SND_ACK, SYN); 
4E54:  MOVLW  01
4E56:  ADDWF  x10,W
4E58:  MOVWF  01
4E5A:  MOVLW  00
4E5C:  ADDWFC x11,W
4E5E:  MOVWF  03
4E60:  MOVFF  01,213
4E64:  MOVWF  x14
4E66:  MOVLW  0B
4E68:  ADDWF  x10,W
4E6A:  MOVWF  FE9
4E6C:  MOVLW  00
4E6E:  ADDWFC x11,W
4E70:  MOVWF  FEA
4E72:  MOVFF  FEC,216
4E76:  MOVF   FED,F
4E78:  MOVFF  FEF,215
4E7C:  MOVLW  0D
4E7E:  ADDWF  x10,W
4E80:  MOVWF  FE9
4E82:  MOVLW  00
4E84:  ADDWFC x11,W
4E86:  MOVWF  FEA
4E88:  MOVFF  FEC,218
4E8C:  MOVF   FED,F
4E8E:  MOVFF  FEF,217
4E92:  MOVLW  16
4E94:  ADDWF  x10,W
4E96:  MOVWF  FE9
4E98:  MOVLW  00
4E9A:  ADDWFC x11,W
4E9C:  MOVWF  FEA
4E9E:  MOVFF  FEF,219
4EA2:  MOVFF  FEC,21A
4EA6:  MOVFF  FEC,21B
4EAA:  MOVFF  FEC,21C
4EAE:  MOVLW  1A
4EB0:  ADDWF  x10,W
4EB2:  MOVWF  FE9
4EB4:  MOVLW  00
4EB6:  ADDWFC x11,W
4EB8:  MOVWF  FEA
4EBA:  MOVFF  FEF,21D
4EBE:  MOVFF  FEC,21E
4EC2:  MOVFF  FEC,21F
4EC6:  MOVFF  FEC,220
4ECA:  MOVFF  03,243
4ECE:  MOVFF  01,242
4ED2:  MOVFF  216,245
4ED6:  MOVFF  215,244
4EDA:  MOVFF  218,247
4EDE:  MOVFF  217,246
4EE2:  MOVFF  21C,24B
4EE6:  MOVFF  21B,24A
4EEA:  MOVFF  21A,249
4EEE:  MOVFF  219,248
4EF2:  MOVFF  220,24F
4EF6:  MOVFF  21F,24E
4EFA:  MOVFF  21E,24D
4EFE:  MOVFF  21D,24C
4F02:  MOVLW  02
4F04:  MOVWF  x50
4F06:  MOVLW  FF
4F08:  MOVWF  x51
4F0A:  CLRF   x53
4F0C:  CLRF   x52
4F0E:  MOVLB  0
4F10:  CALL   2DE4
....................  
....................    ps->smState = TCP_SYN_SENT; 
4F14:  MOVLB  2
4F16:  MOVFF  210,FE9
4F1A:  MOVFF  211,FEA
4F1E:  MOVLW  01
4F20:  MOVWF  FEF
....................    ps->SND_SEQ++; 
4F22:  MOVLW  16
4F24:  ADDWF  x10,W
4F26:  MOVWF  FE9
4F28:  MOVLW  00
4F2A:  ADDWFC x11,W
4F2C:  MOVWF  FEA
4F2E:  MOVLW  01
4F30:  ADDWF  FEE,F
4F32:  MOVLW  00
4F34:  ADDWFC FEE,F
4F36:  ADDWFC FEE,F
4F38:  ADDWFC FED,F
....................  
....................    // Allow TCPTick() to operate properly 
....................    ps->startTick = TickGet(); 
4F3A:  MOVLW  1F
4F3C:  ADDWF  x10,W
4F3E:  MOVWF  01
4F40:  MOVLW  00
4F42:  ADDWFC x11,W
4F44:  MOVWF  03
4F46:  MOVFF  01,213
4F4A:  MOVWF  x14
4F4C:  MOVLB  0
4F4E:  CALL   10B0
4F52:  MOVFF  214,FEA
4F56:  MOVFF  213,FE9
4F5A:  MOVFF  02,FEC
4F5E:  MOVF   FED,F
4F60:  MOVFF  01,FEF
....................  
....................    //debug_tcp("SOCK=%U", s); 
....................  
....................    return s; 
4F64:  MOVLB  2
4F66:  MOVFF  20F,01
.................... } 
4F6A:  MOVLB  0
4F6C:  GOTO   6274 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL TCPIsConnected(TCP_SOCKET s) { 
....................    return (TCB[s].smState == TCP_ESTABLISHED); 
4F70:  MOVLB  2
4F72:  MOVF   x0B,W
4F74:  MULLW  24
4F76:  MOVF   FF3,W
4F78:  CLRF   x0D
4F7A:  MOVWF  x0C
4F7C:  MOVLW  8A
4F7E:  ADDWF  x0C,W
4F80:  MOVWF  FE9
4F82:  MOVLW  00
4F84:  ADDWFC x0D,W
4F86:  MOVWF  FEA
4F88:  MOVF   FEF,W
4F8A:  SUBLW  03
4F8C:  BZ    4F92
4F8E:  MOVLW  00
4F90:  BRA    4F94
4F92:  MOVLW  01
4F94:  MOVWF  01
.................... } 
4F96:  MOVLB  0
4F98:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPDisconnect(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsPutReady(s) == TRUE 
....................  * 
....................  * Input:           s       - Socket to be disconnected. 
....................  * 
....................  * Output:          A disconnect request is sent for given socket. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TCPDisconnect(TCP_SOCKET s) { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
605C:  MOVLB  2
605E:  MOVF   x0B,W
6060:  MULLW  24
6062:  MOVF   FF3,W
6064:  CLRF   03
6066:  ADDLW  8A
6068:  MOVWF  01
606A:  MOVLW  00
606C:  ADDWFC 03,F
606E:  MOVFF  01,20C
6072:  MOVFF  03,20D
....................  
....................    // If socket is not connected, may be it is already closed 
....................    // or in the process of closing.  Since we have called this 
....................    // explicitly, close it forcefully. 
....................    if (ps->smState != TCP_ESTABLISHED && ps->smState != TCP_SYN_RECEIVED) { 
6076:  MOVFF  20C,FE9
607A:  MOVFF  20D,FEA
607E:  MOVF   FEF,W
6080:  SUBLW  03
6082:  BZ    60A2
6084:  MOVFF  20C,FE9
6088:  MOVFF  20D,FEA
608C:  MOVF   FEF,W
608E:  SUBLW  02
6090:  BZ    60A2
....................       CloseSocket(ps); 
6092:  MOVFF  20D,23F
6096:  MOVFF  20C,23E
609A:  MOVLB  0
609C:  CALL   28BE
....................       return; 
60A0:  BRA    6192
....................    } 
....................  
....................    // Discard any outstanding data that is to be read. 
....................    TCPDiscard(s); 
60A2:  MOVFF  20B,20E
60A6:  MOVLB  0
60A8:  BRA    600C
....................  
....................    // Send FIN message. 
....................    SendTCP(&ps->remote, ps->localPort, ps->remotePort, ps->SND_SEQ, 
....................          ps->SND_ACK, FIN | ACK); 
60AA:  MOVLW  01
60AC:  MOVLB  2
60AE:  ADDWF  x0C,W
60B0:  MOVWF  01
60B2:  MOVLW  00
60B4:  ADDWFC x0D,W
60B6:  MOVWF  03
60B8:  MOVFF  01,20E
60BC:  MOVWF  x0F
60BE:  MOVLW  0B
60C0:  ADDWF  x0C,W
60C2:  MOVWF  FE9
60C4:  MOVLW  00
60C6:  ADDWFC x0D,W
60C8:  MOVWF  FEA
60CA:  MOVFF  FEC,211
60CE:  MOVF   FED,F
60D0:  MOVFF  FEF,210
60D4:  MOVLW  0D
60D6:  ADDWF  x0C,W
60D8:  MOVWF  FE9
60DA:  MOVLW  00
60DC:  ADDWFC x0D,W
60DE:  MOVWF  FEA
60E0:  MOVFF  FEC,213
60E4:  MOVF   FED,F
60E6:  MOVFF  FEF,212
60EA:  MOVLW  16
60EC:  ADDWF  x0C,W
60EE:  MOVWF  FE9
60F0:  MOVLW  00
60F2:  ADDWFC x0D,W
60F4:  MOVWF  FEA
60F6:  MOVFF  FEF,214
60FA:  MOVFF  FEC,215
60FE:  MOVFF  FEC,216
6102:  MOVFF  FEC,217
6106:  MOVLW  1A
6108:  ADDWF  x0C,W
610A:  MOVWF  FE9
610C:  MOVLW  00
610E:  ADDWFC x0D,W
6110:  MOVWF  FEA
6112:  MOVFF  FEF,218
6116:  MOVFF  FEC,219
611A:  MOVFF  FEC,21A
611E:  MOVFF  FEC,21B
6122:  MOVFF  03,243
6126:  MOVFF  01,242
612A:  MOVFF  211,245
612E:  MOVFF  210,244
6132:  MOVFF  213,247
6136:  MOVFF  212,246
613A:  MOVFF  217,24B
613E:  MOVFF  216,24A
6142:  MOVFF  215,249
6146:  MOVFF  214,248
614A:  MOVFF  21B,24F
614E:  MOVFF  21A,24E
6152:  MOVFF  219,24D
6156:  MOVFF  218,24C
615A:  MOVLW  11
615C:  MOVWF  x50
615E:  MOVLW  FF
6160:  MOVWF  x51
6162:  CLRF   x53
6164:  CLRF   x52
6166:  MOVLB  0
6168:  CALL   2DE4
....................    //DebugPrint("."); 
....................  
....................    ps->SND_SEQ++; 
616C:  MOVLW  16
616E:  MOVLB  2
6170:  ADDWF  x0C,W
6172:  MOVWF  FE9
6174:  MOVLW  00
6176:  ADDWFC x0D,W
6178:  MOVWF  FEA
617A:  MOVLW  01
617C:  ADDWF  FEE,F
617E:  MOVLW  00
6180:  ADDWFC FEE,F
6182:  ADDWFC FEE,F
6184:  ADDWFC FED,F
....................  
....................    ps->smState = TCP_FIN_WAIT_1; 
6186:  MOVFF  20C,FE9
618A:  MOVFF  20D,FEA
618E:  MOVLW  04
6190:  MOVWF  FEF
6192:  MOVLB  0
....................  
....................    return; 
.................... } 
6194:  GOTO   6B14 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPFlush(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket whose data is to be transmitted. 
....................  * 
....................  * Output:          All and any data associated with this socket 
....................  *                  is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPFlush(TCP_SOCKET s) { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
516C:  MOVLB  2
516E:  MOVF   x14,W
5170:  MULLW  24
5172:  MOVF   FF3,W
5174:  CLRF   03
5176:  ADDLW  8A
5178:  MOVWF  01
517A:  MOVLW  00
517C:  ADDWFC 03,F
517E:  MOVFF  01,215
5182:  MOVFF  03,216
....................  
....................    // Make sure that there is TxBuffer assigned to this socket. 
....................    if (ps->TxBuffer == INVALID_BUFFER) 
5186:  MOVLW  0F
5188:  ADDWF  x15,W
518A:  MOVWF  FE9
518C:  MOVLW  00
518E:  ADDWFC x16,W
5190:  MOVWF  FEA
5192:  INCFSZ FEF,W
5194:  BRA    519C
....................       return FALSE; 
5196:  MOVLW  00
5198:  MOVWF  01
519A:  BRA    5332
....................  
....................    if (ps->Flags.bIsPutReady == FALSE) 
519C:  MOVLW  23
519E:  ADDWF  x15,W
51A0:  MOVWF  FE9
51A2:  MOVLW  00
51A4:  ADDWFC x16,W
51A6:  MOVWF  FEA
51A8:  MOVLW  00
51AA:  BTFSC  FEF.1
51AC:  MOVLW  01
51AE:  XORLW  00
51B0:  BNZ   51B8
....................       return FALSE; 
51B2:  MOVLW  00
51B4:  MOVWF  01
51B6:  BRA    5332
....................  
....................    TransmitTCP(&ps->remote, ps->localPort, ps->remotePort, ps->SND_SEQ, 
....................          ps->SND_ACK, 
....................          ACK + PSH, // Use PSH to make sure the end application receives the data right away 
....................          ps->TxBuffer, ps->TxCount); 
51B8:  MOVLW  01
51BA:  ADDWF  x15,W
51BC:  MOVWF  01
51BE:  MOVLW  00
51C0:  ADDWFC x16,W
51C2:  MOVWF  03
51C4:  MOVFF  01,217
51C8:  MOVWF  x18
51CA:  MOVLW  0B
51CC:  ADDWF  x15,W
51CE:  MOVWF  FE9
51D0:  MOVLW  00
51D2:  ADDWFC x16,W
51D4:  MOVWF  FEA
51D6:  MOVFF  FEC,21A
51DA:  MOVF   FED,F
51DC:  MOVFF  FEF,219
51E0:  MOVLW  0D
51E2:  ADDWF  x15,W
51E4:  MOVWF  FE9
51E6:  MOVLW  00
51E8:  ADDWFC x16,W
51EA:  MOVWF  FEA
51EC:  MOVFF  FEC,21C
51F0:  MOVF   FED,F
51F2:  MOVFF  FEF,21B
51F6:  MOVLW  16
51F8:  ADDWF  x15,W
51FA:  MOVWF  FE9
51FC:  MOVLW  00
51FE:  ADDWFC x16,W
5200:  MOVWF  FEA
5202:  MOVFF  FEF,21D
5206:  MOVFF  FEC,21E
520A:  MOVFF  FEC,21F
520E:  MOVFF  FEC,220
5212:  MOVLW  1A
5214:  ADDWF  x15,W
5216:  MOVWF  FE9
5218:  MOVLW  00
521A:  ADDWFC x16,W
521C:  MOVWF  FEA
521E:  MOVFF  FEF,221
5222:  MOVFF  FEC,222
5226:  MOVFF  FEC,223
522A:  MOVFF  FEC,224
522E:  MOVLW  0F
5230:  ADDWF  x15,W
5232:  MOVWF  FE9
5234:  MOVLW  00
5236:  ADDWFC x16,W
5238:  MOVWF  FEA
523A:  MOVFF  FEF,225
523E:  MOVLW  10
5240:  ADDWF  x15,W
5242:  MOVWF  FE9
5244:  MOVLW  00
5246:  ADDWFC x16,W
5248:  MOVWF  FEA
524A:  MOVFF  FEC,227
524E:  MOVF   FED,F
5250:  MOVFF  FEF,226
5254:  MOVFF  03,243
5258:  MOVFF  01,242
525C:  MOVFF  21A,245
5260:  MOVFF  219,244
5264:  MOVFF  21C,247
5268:  MOVFF  21B,246
526C:  MOVFF  220,24B
5270:  MOVFF  21F,24A
5274:  MOVFF  21E,249
5278:  MOVFF  21D,248
527C:  MOVFF  224,24F
5280:  MOVFF  223,24E
5284:  MOVFF  222,24D
5288:  MOVFF  221,24C
528C:  MOVLW  18
528E:  MOVWF  x50
5290:  MOVFF  225,251
5294:  MOVFF  227,253
5298:  MOVFF  226,252
529C:  MOVLB  0
529E:  CALL   2DE4
....................  
....................    ps->SND_SEQ += (DWORD) ps->TxCount; 
52A2:  MOVLW  16
52A4:  MOVLB  2
52A6:  ADDWF  x15,W
52A8:  MOVWF  01
52AA:  MOVLW  00
52AC:  ADDWFC x16,W
52AE:  MOVWF  03
52B0:  MOVFF  01,217
52B4:  MOVWF  x18
52B6:  MOVWF  FEA
52B8:  MOVFF  01,FE9
52BC:  MOVFF  FEF,219
52C0:  MOVFF  FEC,21A
52C4:  MOVFF  FEC,21B
52C8:  MOVFF  FEC,21C
52CC:  MOVLW  10
52CE:  ADDWF  x15,W
52D0:  MOVWF  FE9
52D2:  MOVLW  00
52D4:  ADDWFC x16,W
52D6:  MOVWF  FEA
52D8:  MOVFF  FEC,03
52DC:  MOVF   FED,F
52DE:  MOVFF  FEF,00
52E2:  MOVFF  03,01
52E6:  CLRF   02
52E8:  CLRF   03
52EA:  MOVF   x19,W
52EC:  ADDWF  00,F
52EE:  MOVF   x1A,W
52F0:  ADDWFC 01,F
52F2:  MOVF   x1B,W
52F4:  ADDWFC 02,F
52F6:  MOVF   x1C,W
52F8:  ADDWFC 03,F
52FA:  MOVFF  218,FEA
52FE:  MOVFF  217,FE9
5302:  MOVFF  00,FEF
5306:  MOVFF  01,FEC
530A:  MOVFF  02,FEC
530E:  MOVFF  03,FEC
....................    ps->Flags.bIsPutReady = FALSE; 
5312:  MOVLW  23
5314:  ADDWF  x15,W
5316:  MOVWF  FE9
5318:  MOVLW  00
531A:  ADDWFC x16,W
531C:  MOVWF  FEA
531E:  BCF    FEF.1
....................    ps->Flags.bIsTxInProgress = FALSE; 
5320:  MOVLW  23
5322:  ADDWF  x15,W
5324:  MOVWF  FE9
5326:  MOVLW  00
5328:  ADDWFC x16,W
532A:  MOVWF  FEA
532C:  BCF    FEF.4
....................  
.................... #if TCP_NO_WAIT_FOR_ACK 
....................    if(ps->TxBuffer != INVALID_BUFFER) 
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
....................       ps->TxBuffer = INVALID_BUFFER; 
....................    } 
....................    ps->Flags.bIsPutReady = TRUE; 
.................... #endif 
....................  
....................    return TRUE; 
532E:  MOVLW  01
5330:  MOVWF  01
.................... } 
5332:  MOVLB  0
5334:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL TCPIsPutReady(TCP_SOCKET s) { 
....................    if (TCB[s].RemoteWindow == 0) 
*
4FA0:  MOVLB  2
4FA2:  MOVF   x0B,W
4FA4:  MULLW  24
4FA6:  MOVF   FF3,W
4FA8:  CLRF   x0D
4FAA:  MOVWF  x0C
4FAC:  MOVLW  14
4FAE:  ADDWF  x0C,W
4FB0:  MOVWF  01
4FB2:  MOVLW  00
4FB4:  ADDWFC x0D,W
4FB6:  MOVWF  03
4FB8:  MOVF   01,W
4FBA:  ADDLW  8A
4FBC:  MOVWF  FE9
4FBE:  MOVLW  00
4FC0:  ADDWFC 03,W
4FC2:  MOVWF  FEA
4FC4:  MOVFF  FEC,20D
4FC8:  MOVF   FED,F
4FCA:  MOVFF  FEF,20C
4FCE:  MOVF   x0C,F
4FD0:  BNZ   4FDC
4FD2:  MOVF   x0D,F
4FD4:  BNZ   4FDC
....................       return FALSE; 
4FD6:  MOVLW  00
4FD8:  MOVWF  01
4FDA:  BRA    503A
....................  
....................    if (TCB[s].TxBuffer == INVALID_BUFFER) 
4FDC:  MOVF   x0B,W
4FDE:  MULLW  24
4FE0:  MOVF   FF3,W
4FE2:  CLRF   x0D
4FE4:  MOVWF  x0C
4FE6:  MOVLW  0F
4FE8:  ADDWF  x0C,W
4FEA:  MOVWF  01
4FEC:  MOVLW  00
4FEE:  ADDWFC x0D,W
4FF0:  MOVWF  03
4FF2:  MOVF   01,W
4FF4:  ADDLW  8A
4FF6:  MOVWF  FE9
4FF8:  MOVLW  00
4FFA:  ADDWFC 03,W
4FFC:  MOVWF  FEA
4FFE:  INCFSZ FEF,W
5000:  BRA    5012
....................       return IPIsTxReady(FALSE); 
5002:  CLRF   x7A
5004:  MOVLB  0
5006:  CALL   29CE
500A:  MOVF   01,W
500C:  MOVLB  2
500E:  BRA    503A
....................    else 
5010:  BRA    503A
....................       return TCB[s].Flags.bIsPutReady; 
5012:  MOVF   x0B,W
5014:  MULLW  24
5016:  MOVF   FF3,W
5018:  CLRF   x0D
501A:  MOVWF  x0C
501C:  MOVLW  23
501E:  ADDWF  x0C,F
5020:  MOVLW  00
5022:  ADDWFC x0D,F
5024:  MOVLW  8A
5026:  ADDWF  x0C,W
5028:  MOVWF  FE9
502A:  MOVLW  00
502C:  ADDWFC x0D,W
502E:  MOVWF  FEA
5030:  MOVLW  00
5032:  BTFSC  FEF.1
5034:  MOVLW  01
5036:  MOVWF  01
5038:  BRA    503A
.................... } 
503A:  MOVLB  0
503C:  GOTO   631A (RETURN)
....................  
.................... int16 TCPPutAvailable(TCP_SOCKET s) { 
....................    int16 txCount, txAvail; 
....................  
....................    if (!TCPIsPutReady(s)) 
....................       return (0); 
....................  
....................    if (TCB[s].TxBuffer == INVALID_BUFFER) 
....................       txCount = 0; 
....................    else 
....................       txCount = TCB[s].TxCount; 
....................  
....................    txAvail = MAX_TCP_DATA_LEN - txCount; 
....................  
....................    txAvail = txAvail > TCB[s].RemoteWindow ? TCB[s].RemoteWindow : txAvail; 
....................  
....................    return (txAvail); 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer -OR- we ran out of space in the remote node's 
....................  *                  window.  In either case you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) { 
....................    SOCKET_INFO* ps; 
....................    WORD n; 
....................  
....................    ps = &TCB[s]; 
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if (ps->RemoteWindow == 0) 
....................       return 0; 
....................  
....................    if (ps->TxBuffer == INVALID_BUFFER) { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if (ps->TxBuffer == INVALID_BUFFER) 
....................          return 0; 
....................  
....................       ps->TxCount = 0; 
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
....................    } 
....................  
....................    n = TCPPutAvailable(s); 
....................  
....................    len = n < len ? n : len; 
....................    n = len; 
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................    while (n--) { 
....................       MACPut(*ptr++); 
....................       ps->RemoteWindow -= 1; 
....................       ps->TxCount += 1; 
....................    } 
....................  
....................    if (ps->TxCount >= MAX_TCP_DATA_LEN) 
....................       TCPFlush(s); 
....................  
....................    return (len); 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer and you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPPut(TCP_SOCKET s, BYTE byte) { 
....................    SOCKET_INFO* ps; 
....................    WORD tempCount; 
....................  
....................    ps = &TCB[s]; 
*
5336:  MOVLB  2
5338:  MOVF   x0E,W
533A:  MULLW  24
533C:  MOVF   FF3,W
533E:  CLRF   03
5340:  ADDLW  8A
5342:  MOVWF  01
5344:  MOVLW  00
5346:  ADDWFC 03,F
5348:  MOVFF  01,210
534C:  MOVFF  03,211
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if (ps->RemoteWindow == 0) 
5350:  MOVLW  14
5352:  ADDWF  x10,W
5354:  MOVWF  FE9
5356:  MOVLW  00
5358:  ADDWFC x11,W
535A:  MOVWF  FEA
535C:  MOVFF  FEC,215
5360:  MOVF   FED,F
5362:  MOVFF  FEF,214
5366:  MOVF   x14,F
5368:  BNZ   5374
536A:  MOVF   x15,F
536C:  BNZ   5374
....................       return FALSE; 
536E:  MOVLW  00
5370:  MOVWF  01
5372:  BRA    547A
....................  
....................    if (ps->TxBuffer == INVALID_BUFFER) { 
5374:  MOVLW  0F
5376:  ADDWF  x10,W
5378:  MOVWF  FE9
537A:  MOVLW  00
537C:  ADDWFC x11,W
537E:  MOVWF  FEA
5380:  INCFSZ FEF,W
5382:  BRA    53F6
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
5384:  MOVLW  0F
5386:  ADDWF  x10,W
5388:  MOVWF  01
538A:  MOVLW  00
538C:  ADDWFC x11,W
538E:  MOVWF  03
5390:  MOVFF  01,214
5394:  MOVWF  x15
5396:  CLRF   x7A
5398:  MOVLB  0
539A:  CALL   159C
539E:  MOVFF  215,FEA
53A2:  MOVFF  214,FE9
53A6:  MOVFF  01,FEF
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if (ps->TxBuffer == INVALID_BUFFER) 
53AA:  MOVLW  0F
53AC:  MOVLB  2
53AE:  ADDWF  x10,W
53B0:  MOVWF  FE9
53B2:  MOVLW  00
53B4:  ADDWFC x11,W
53B6:  MOVWF  FEA
53B8:  INCFSZ FEF,W
53BA:  BRA    53C2
....................          return FALSE; 
53BC:  MOVLW  00
53BE:  MOVWF  01
53C0:  BRA    547A
....................  
....................       ps->TxCount = 0; 
53C2:  MOVLW  10
53C4:  ADDWF  x10,W
53C6:  MOVWF  FE9
53C8:  MOVLW  00
53CA:  ADDWFC x11,W
53CC:  MOVWF  FEA
53CE:  CLRF   FEC
53D0:  MOVF   FED,F
53D2:  CLRF   FEF
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
53D4:  MOVLW  0F
53D6:  ADDWF  x10,W
53D8:  MOVWF  FE9
53DA:  MOVLW  00
53DC:  ADDWFC x11,W
53DE:  MOVWF  FEA
53E0:  MOVFF  FEF,214
53E4:  MOVFF  214,293
53E8:  CLRF   x95
53EA:  MOVLW  28
53EC:  MOVWF  x94
53EE:  MOVLB  0
53F0:  CALL   15C4
53F4:  MOVLB  2
....................    } 
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
53F6:  MOVLW  23
53F8:  ADDWF  x10,W
53FA:  MOVWF  FE9
53FC:  MOVLW  00
53FE:  ADDWFC x11,W
5400:  MOVWF  FEA
5402:  BSF    FEF.4
....................  
....................    MACPut(byte); 
5404:  MOVFF  20F,29D
5408:  MOVLB  0
540A:  CALL   168A
....................    ps->RemoteWindow--; 
540E:  MOVLW  14
5410:  MOVLB  2
5412:  ADDWF  x10,W
5414:  MOVWF  FE9
5416:  MOVLW  00
5418:  ADDWFC x11,W
541A:  MOVWF  FEA
541C:  MOVLW  FF
541E:  ADDWF  FEF,F
5420:  BC    5426
5422:  MOVF   FEE,F
5424:  DECF   FED,F
....................  
....................    tempCount = ps->TxCount; 
5426:  MOVLW  10
5428:  ADDWF  x10,W
542A:  MOVWF  FE9
542C:  MOVLW  00
542E:  ADDWFC x11,W
5430:  MOVWF  FEA
5432:  MOVFF  FEC,03
5436:  MOVF   FED,F
5438:  MOVFF  FEF,212
543C:  MOVFF  03,213
....................    tempCount++; 
5440:  INCF   x12,F
5442:  BTFSC  FD8.2
5444:  INCF   x13,F
....................    ps->TxCount = tempCount; 
5446:  MOVLW  10
5448:  ADDWF  x10,W
544A:  MOVWF  FE9
544C:  MOVLW  00
544E:  ADDWFC x11,W
5450:  MOVWF  FEA
5452:  MOVFF  213,FEC
5456:  MOVF   FED,F
5458:  MOVFF  212,FEF
....................    if (tempCount >= MAX_TCP_DATA_LEN) 
545C:  MOVF   x13,W
545E:  SUBLW  02
5460:  BC    5476
5462:  XORLW  FF
5464:  BNZ   546C
5466:  MOVF   x12,W
5468:  SUBLW  C9
546A:  BC    5476
....................       TCPFlush(s); 
546C:  MOVFF  20E,214
5470:  MOVLB  0
5472:  RCALL  516C
5474:  MOVLB  2
....................  
....................    return TRUE; 
5476:  MOVLW  01
5478:  MOVWF  01
.................... } 
547A:  MOVLB  0
547C:  GOTO   548A (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPDiscard(TCP_SOCKET s) { 
....................    SOCKET_INFO* ps; 
....................  
....................    ps = &TCB[s]; 
*
600C:  MOVLB  2
600E:  MOVF   x0E,W
6010:  MULLW  24
6012:  MOVF   FF3,W
6014:  CLRF   03
6016:  ADDLW  8A
6018:  MOVWF  01
601A:  MOVLW  00
601C:  ADDWFC 03,F
601E:  MOVFF  01,20F
6022:  MOVFF  03,210
....................  
....................    // This socket must contain data for it to be discarded. 
....................    if (!ps->Flags.bIsGetReady) 
6026:  MOVLW  23
6028:  ADDWF  x0F,W
602A:  MOVWF  FE9
602C:  MOVLW  00
602E:  ADDWFC x10,W
6030:  MOVWF  FEA
6032:  BTFSC  FEF.3
6034:  BRA    603C
....................       return FALSE; 
6036:  MOVLW  00
6038:  MOVWF  01
603A:  BRA    6056
....................  
....................    MACDiscardRx(); 
603C:  MOVLB  0
603E:  CALL   1138
....................    ps->Flags.bIsGetReady = FALSE; 
6042:  MOVLW  23
6044:  MOVLB  2
6046:  ADDWF  x0F,W
6048:  MOVWF  FE9
604A:  MOVLW  00
604C:  ADDWFC x10,W
604E:  MOVWF  FEA
6050:  BCF    FEF.3
....................  
....................    return TRUE; 
6052:  MOVLW  01
6054:  MOVWF  01
.................... } 
6056:  MOVLB  0
6058:  GOTO   60AA (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count) { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
....................  
....................    if (ps->Flags.bIsGetReady) { 
....................       if (ps->Flags.bFirstRead) { 
....................          // Position read pointer to begining of TCP data 
....................          IPSetRxBuffer(sizeof(TCP_HEADER)); 
....................  
....................          ps->Flags.bFirstRead = FALSE; 
....................       } 
....................  
....................       ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................       return MACGetArray(buff, count); 
....................    } 
....................    else 
....................       return 0; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPGet(TCP_SOCKET s, BYTE *data) { 
....................    SOCKET_INFO* ps; 
....................  
....................    ps = &TCB[s]; 
*
5546:  MOVLB  2
5548:  MOVF   x0B,W
554A:  MULLW  24
554C:  MOVF   FF3,W
554E:  CLRF   03
5550:  ADDLW  8A
5552:  MOVWF  01
5554:  MOVLW  00
5556:  ADDWFC 03,F
5558:  MOVFF  01,20E
555C:  MOVFF  03,20F
....................  
....................    if (ps->Flags.bIsGetReady) { 
5560:  MOVLW  23
5562:  ADDWF  x0E,W
5564:  MOVWF  FE9
5566:  MOVLW  00
5568:  ADDWFC x0F,W
556A:  MOVWF  FEA
556C:  BTFSS  FEF.3
556E:  BRA    5612
....................       if (ps->Flags.bFirstRead) { 
5570:  MOVLW  23
5572:  ADDWF  x0E,W
5574:  MOVWF  FE9
5576:  MOVLW  00
5578:  ADDWFC x0F,W
557A:  MOVWF  FEA
557C:  BTFSS  FEF.2
557E:  BRA    559C
....................          // Position read pointer to begining of correct 
....................          // buffer. 
....................          IPSetRxBuffer(sizeof(TCP_HEADER)); 
5580:  CLRF   x22
5582:  MOVLW  14
5584:  MOVWF  x21
5586:  MOVLB  0
5588:  CALL   246C
....................  
....................          ps->Flags.bFirstRead = FALSE; 
558C:  MOVLW  23
558E:  MOVLB  2
5590:  ADDWF  x0E,W
5592:  MOVWF  FE9
5594:  MOVLW  00
5596:  ADDWFC x0F,W
5598:  MOVWF  FEA
559A:  BCF    FEF.2
....................       } 
....................  
....................       if (ps->RxCount == 0) { 
559C:  MOVLW  12
559E:  ADDWF  x0E,W
55A0:  MOVWF  FE9
55A2:  MOVLW  00
55A4:  ADDWFC x0F,W
55A6:  MOVWF  FEA
55A8:  MOVFF  FEC,211
55AC:  MOVF   FED,F
55AE:  MOVFF  FEF,210
55B2:  MOVF   x10,F
55B4:  BNZ   55D6
55B6:  MOVF   x11,F
55B8:  BNZ   55D6
....................          MACDiscardRx(); 
55BA:  MOVLB  0
55BC:  CALL   1138
....................          ps->Flags.bIsGetReady = FALSE; 
55C0:  MOVLW  23
55C2:  MOVLB  2
55C4:  ADDWF  x0E,W
55C6:  MOVWF  FE9
55C8:  MOVLW  00
55CA:  ADDWFC x0F,W
55CC:  MOVWF  FEA
55CE:  BCF    FEF.3
....................          return FALSE; 
55D0:  MOVLW  00
55D2:  MOVWF  01
55D4:  BRA    5616
....................       } 
....................  
....................       ps->RxCount--; 
55D6:  MOVLW  12
55D8:  ADDWF  x0E,W
55DA:  MOVWF  FE9
55DC:  MOVLW  00
55DE:  ADDWFC x0F,W
55E0:  MOVWF  FEA
55E2:  MOVLW  FF
55E4:  ADDWF  FEF,F
55E6:  BC    55EC
55E8:  MOVF   FEE,F
55EA:  DECF   FED,F
....................       *data = MACGet(); 
55EC:  MOVFF  20D,03
55F0:  MOVFF  20C,210
55F4:  MOVFF  20D,211
55F8:  MOVLB  0
55FA:  CALL   225C
55FE:  MOVFF  211,FEA
5602:  MOVFF  210,FE9
5606:  MOVFF  01,FEF
....................       return TRUE; 
560A:  MOVLW  01
560C:  MOVWF  01
560E:  MOVLB  2
5610:  BRA    5616
....................    } 
....................    return FALSE; 
5612:  MOVLW  00
5614:  MOVWF  01
.................... } 
5616:  MOVLB  0
5618:  GOTO   6A82 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPIsGetReady(TCP_SOCKET s) { 
....................    /* 
....................     * A socket is said to be "Get" ready when it has already 
....................     * received some data.  Sometime, a socket may be closed, 
....................     * but it still may contain data.  Thus in order to ensure 
....................     * reuse of a socket, caller must make sure that it reads 
....................     * a socket, if is ready. 
....................     */ 
....................    return (TCB[s].Flags.bIsGetReady); 
*
5518:  MOVLB  2
551A:  MOVF   x0B,W
551C:  MULLW  24
551E:  MOVF   FF3,W
5520:  CLRF   x0D
5522:  MOVWF  x0C
5524:  MOVLW  23
5526:  ADDWF  x0C,F
5528:  MOVLW  00
552A:  ADDWFC x0D,F
552C:  MOVLW  8A
552E:  ADDWF  x0C,W
5530:  MOVWF  FE9
5532:  MOVLW  00
5534:  ADDWFC x0D,W
5536:  MOVWF  FEA
5538:  MOVLW  00
553A:  BTFSC  FEF.3
553C:  MOVLW  01
553E:  MOVWF  01
.................... } 
5540:  MOVLB  0
5542:  GOTO   6A1C (RETURN)
....................  
.................... //// internal functions ///// 
....................  
.................... void DebugTCPDisplayState(TCP_STATE st) { 
....................    switch (st) { 
....................    case TCP_LISTEN: 
....................       debug_tcp("LISTEN"); 
....................       break; 
....................    case TCP_SYN_SENT: 
....................       debug_tcp("SYN_SENT"); 
....................       break; 
....................    case TCP_SYN_RECEIVED: 
....................       debug_tcp("SYN_RECVD"); 
....................       break; 
....................    case TCP_ESTABLISHED: 
....................       debug_tcp("ESTABLISHED"); 
....................       break; 
....................    case TCP_FIN_WAIT_1: 
....................       debug_tcp("FIN_WAIT_1"); 
....................       break; 
....................    case TCP_FIN_WAIT_2: 
....................       debug_tcp("FIN_WAIT_2"); 
....................       break; 
....................    case TCP_CLOSING: 
....................       debug_tcp("CLOSING"); 
....................       break; 
....................    case TCP_TIME_WAIT: 
....................       debug_tcp("TIME_WAIT"); 
....................       break; 
....................    case TCP_CLOSE_WAIT: 
....................       debug_tcp("CLOSE_WAIT"); 
....................       break; 
....................    case TCP_LAST_ACK: 
....................       debug_tcp("LAST_ACK"); 
....................       break; 
....................    case TCP_CLOSED: 
....................       debug_tcp("CLOSED"); 
....................       break; 
....................    default: 
....................       debug_tcp("UNKNOWN %U",st); 
....................       break; 
....................    } 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPTick(void) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Each socket FSM is executed for any timeout 
....................  *                  situation. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TCPTick(void) { 
....................    TCP_SOCKET s; 
....................    TICKTYPE diffTicks; 
....................    TICKTYPE tick; 
....................    SOCKET_INFO* ps; 
....................    DWORD seq; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................  
....................    flags = 0x00; 
*
3F9A:  MOVLB  1
3F9C:  CLRF   xFF
....................    // Periodically all "not closed" sockets must perform timed operations 
....................    for (s = 0; s < MAX_SOCKETS; s++) { 
3F9E:  CLRF   xF4
3FA0:  MOVF   xF4,W
3FA2:  SUBLW  04
3FA4:  BTFSS  FD8.0
3FA6:  BRA    4454
....................       ps = &TCB[s]; 
3FA8:  MOVF   xF4,W
3FAA:  MULLW  24
3FAC:  MOVF   FF3,W
3FAE:  CLRF   03
3FB0:  ADDLW  8A
3FB2:  MOVWF  01
3FB4:  MOVLW  00
3FB6:  ADDWFC 03,F
3FB8:  MOVFF  01,1F9
3FBC:  MOVFF  03,1FA
....................  
....................       //debugLastState = TCB[s].smState; 
....................  
....................       if (ps->Flags.bIsGetReady || ps->Flags.bIsTxInProgress) 
3FC0:  MOVLW  23
3FC2:  ADDWF  xF9,W
3FC4:  MOVWF  FE9
3FC6:  MOVLW  00
3FC8:  ADDWFC xFA,W
3FCA:  MOVWF  FEA
3FCC:  BTFSC  FEF.3
3FCE:  BRA    3FE0
3FD0:  MOVLW  23
3FD2:  ADDWF  xF9,W
3FD4:  MOVWF  FE9
3FD6:  MOVLW  00
3FD8:  ADDWFC xFA,W
3FDA:  MOVWF  FEA
3FDC:  BTFSS  FEF.4
3FDE:  BRA    3FE2
....................          continue; 
3FE0:  BRA    4450
....................  
....................       // Closed or Passively Listening socket do not care 
....................       // about timeout conditions. 
....................       if ((ps->smState == TCP_CLOSED) 
....................             || (ps->smState == TCP_LISTEN && ps->Flags.bServer == TRUE)) 
3FE2:  MOVFF  1F9,FE9
3FE6:  MOVFF  1FA,FEA
3FEA:  MOVF   FEF,W
3FEC:  SUBLW  0A
3FEE:  BZ    4012
3FF0:  MOVFF  1F9,FE9
3FF4:  MOVFF  1FA,FEA
3FF8:  MOVF   FEF,F
3FFA:  BNZ   4014
3FFC:  MOVLW  23
3FFE:  ADDWF  xF9,W
4000:  MOVWF  FE9
4002:  MOVLW  00
4004:  ADDWFC xFA,W
4006:  MOVWF  FEA
4008:  MOVLW  00
400A:  BTFSC  FEF.0
400C:  MOVLW  01
400E:  SUBLW  01
4010:  BNZ   4014
....................          continue; 
4012:  BRA    4450
....................  
....................       //TODO: review this 
....................       //DSR ADD 063004 
....................       //i do this because if i am a server, i don't want to timeout. 
....................       if ((ps->smState == TCP_ESTABLISHED) && (ps->Flags.bServer == TRUE)) 
4014:  MOVFF  1F9,FE9
4018:  MOVFF  1FA,FEA
401C:  MOVF   FEF,W
401E:  SUBLW  03
4020:  BNZ   403A
4022:  MOVLW  23
4024:  ADDWF  xF9,W
4026:  MOVWF  FE9
4028:  MOVLW  00
402A:  ADDWFC xFA,W
402C:  MOVWF  FEA
402E:  MOVLW  00
4030:  BTFSC  FEF.0
4032:  MOVLW  01
4034:  SUBLW  01
4036:  BNZ   403A
....................          continue; 
4038:  BRA    4450
....................  
....................       tick = TickGet(); 
403A:  MOVLB  0
403C:  CALL   10B0
4040:  MOVFF  02,1F8
4044:  MOVFF  01,1F7
....................  
....................       // Calculate timeout value for this socket. 
....................       diffTicks = TickGetDiff(tick, ps->startTick); 
4048:  MOVLW  1F
404A:  MOVLB  1
404C:  ADDWF  xF9,W
404E:  MOVWF  FE9
4050:  MOVLW  00
4052:  ADDWFC xFA,W
4054:  MOVWF  FEA
4056:  MOVFF  FEC,03
405A:  MOVF   FED,F
405C:  MOVFF  FEF,01
4060:  MOVF   xF8,W
4062:  SUBWF  03,W
4064:  BNC   406E
4066:  BNZ   4072
4068:  MOVF   01,W
406A:  SUBWF  xF7,W
406C:  BNC   4072
406E:  MOVLW  00
4070:  BRA    4074
4072:  MOVLW  01
4074:  CLRF   03
4076:  IORWF  03,W
4078:  BZ    40BC
407A:  MOVLW  1F
407C:  ADDWF  xF9,W
407E:  MOVWF  FE9
4080:  MOVLW  00
4082:  ADDWFC xFA,W
4084:  MOVWF  FEA
4086:  MOVFF  FEC,03
408A:  MOVF   FED,F
408C:  MOVF   FEF,W
408E:  SUBLW  FF
4090:  MOVLB  2
4092:  MOVWF  x00
4094:  MOVLW  FF
4096:  SUBFWB 03,W
4098:  MOVWF  x01
409A:  MOVLB  1
409C:  MOVF   xF7,W
409E:  MOVLB  2
40A0:  ADDWF  x00,F
40A2:  MOVLB  1
40A4:  MOVF   xF8,W
40A6:  MOVLB  2
40A8:  ADDWFC x01,F
40AA:  MOVLW  01
40AC:  ADDWF  x00,W
40AE:  MOVWF  01
40B0:  MOVLW  00
40B2:  ADDWFC x01,W
40B4:  MOVWF  03
40B6:  MOVF   01,W
40B8:  BRA    40DC
40BA:  MOVLB  1
40BC:  MOVLW  1F
40BE:  ADDWF  xF9,W
40C0:  MOVWF  FE9
40C2:  MOVLW  00
40C4:  ADDWFC xFA,W
40C6:  MOVWF  FEA
40C8:  MOVFF  FEC,03
40CC:  MOVF   FED,F
40CE:  MOVF   FEF,W
40D0:  SUBWF  xF7,W
40D2:  MOVWF  00
40D4:  MOVF   03,W
40D6:  SUBWFB xF8,W
40D8:  MOVWF  03
40DA:  MOVF   00,W
40DC:  MOVLB  1
40DE:  MOVWF  xF5
40E0:  MOVFF  03,1F6
....................  
....................       // If timeout has not occured, do not do anything. 
....................       if (diffTicks <= ps->TimeOut) 
40E4:  MOVLW  21
40E6:  ADDWF  xF9,W
40E8:  MOVWF  FE9
40EA:  MOVLW  00
40EC:  ADDWFC xFA,W
40EE:  MOVWF  FEA
40F0:  MOVFF  FEC,03
40F4:  MOVF   FED,F
40F6:  MOVFF  FEF,01
40FA:  MOVF   xF6,W
40FC:  SUBWF  03,W
40FE:  BNC   410A
4100:  BNZ   4108
4102:  MOVF   xF5,W
4104:  SUBWF  01,W
4106:  BNC   410A
....................          continue; 
4108:  BRA    4450
....................  
....................       // Most states require retransmission, so check for transmitter 
....................       // availability right here - common for all. 
....................       if (!IPIsTxReady(TRUE)) 
410A:  MOVLW  01
410C:  MOVLB  2
410E:  MOVWF  x7A
4110:  MOVLB  0
4112:  CALL   29CE
4116:  MOVF   01,F
4118:  BNZ   411C
....................          return; 
411A:  BRA    4454
....................  
....................       // Restart timeout reference. 
....................       ps->startTick = TickGet(); 
411C:  MOVLW  1F
411E:  MOVLB  1
4120:  ADDWF  xF9,W
4122:  MOVWF  01
4124:  MOVLW  00
4126:  ADDWFC xFA,W
4128:  MOVWF  03
412A:  MOVFF  01,200
412E:  MOVLB  2
4130:  MOVWF  x01
4132:  MOVLB  0
4134:  CALL   10B0
4138:  MOVFF  201,FEA
413C:  MOVFF  200,FE9
4140:  MOVFF  02,FEC
4144:  MOVF   FED,F
4146:  MOVFF  01,FEF
....................  
....................       // Update timeout value if there is need to wait longer. 
....................       ps->TimeOut <<= 1; 
414A:  MOVLW  21
414C:  MOVLB  1
414E:  ADDWF  xF9,W
4150:  MOVWF  FE9
4152:  MOVLW  00
4154:  ADDWFC xFA,W
4156:  MOVWF  FEA
4158:  BCF    FD8.0
415A:  RLCF   FEF,W
415C:  MOVWF  02
415E:  RLCF   FEC,W
4160:  MOVWF  03
4162:  MOVF   02,W
4164:  MOVF   FED,F
4166:  MOVWF  FEF
4168:  MOVFF  03,FEC
....................  
....................       // This will be one more attempt. 
....................       ps->RetryCount++; 
416C:  MOVLW  1E
416E:  ADDWF  xF9,W
4170:  MOVWF  FE9
4172:  MOVLW  00
4174:  ADDWFC xFA,W
4176:  MOVWF  FEA
4178:  INCF   FEF,F
....................  
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch (ps->smState) { 
417A:  MOVFF  1F9,FE9
417E:  MOVFF  1FA,FEA
4182:  MOVLW  01
4184:  SUBWF  FEF,W
4186:  ADDLW  F7
4188:  BTFSC  FD8.0
418A:  BRA    4328
418C:  ADDLW  09
418E:  MOVLB  0
4190:  GOTO   445A
....................       case TCP_SYN_SENT: 
....................          // Keep sending SYN until we hear from remote node. 
....................          // This may be for infinite time, in that case 
....................          // caller must detect it and do something. 
....................          // Bug Fix: 11/1/02 
....................          flags = SYN; 
4194:  MOVLW  02
4196:  MOVLB  1
4198:  MOVWF  xFF
....................          break; 
419A:  BRA    4328
....................  
....................       case TCP_SYN_RECEIVED: 
....................          // We must receive ACK before timeout expires. 
....................          // If not, resend SYN+ACK. 
....................          // Abort, if maximum attempts counts are reached. 
....................          if (ps->RetryCount <= MAX_RETRY_COUNTS) { 
419C:  MOVLW  1E
419E:  MOVLB  1
41A0:  ADDWF  xF9,W
41A2:  MOVWF  FE9
41A4:  MOVLW  00
41A6:  ADDWFC xFA,W
41A8:  MOVWF  FEA
41AA:  MOVF   FEF,W
41AC:  SUBLW  03
41AE:  BNC   41B6
....................             flags = SYN | ACK; 
41B0:  MOVLW  12
41B2:  MOVWF  xFF
....................          } 
....................          else { 
41B4:  BRA    41E2
....................             if (ps->Flags.bServer) { 
41B6:  MOVLW  23
41B8:  ADDWF  xF9,W
41BA:  MOVWF  FE9
41BC:  MOVLW  00
41BE:  ADDWFC xFA,W
41C0:  MOVWF  FEA
41C2:  BTFSS  FEF.0
41C4:  BRA    41D2
....................                ps->smState = TCP_LISTEN; 
41C6:  MOVFF  1F9,FE9
41CA:  MOVFF  1FA,FEA
41CE:  CLRF   FEF
....................             } 
....................             else { 
41D0:  BRA    41E2
....................                flags = SYN; 
41D2:  MOVLW  02
41D4:  MOVWF  xFF
....................                ps->smState = TCP_SYN_SENT; 
41D6:  MOVFF  1F9,FE9
41DA:  MOVFF  1FA,FEA
41DE:  MOVLW  01
41E0:  MOVWF  FEF
....................             } 
....................          } 
....................          break; 
41E2:  BRA    4328
....................  
....................       case TCP_ESTABLISHED: 
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          // Don't let this connection idle for very long time. 
....................          // If we did not receive or send any message before timeout 
....................          // expires, close this connection. 
....................          if (ps->RetryCount <= MAX_RETRY_COUNTS) { 
41E4:  MOVLW  1E
41E6:  MOVLB  1
41E8:  ADDWF  xF9,W
41EA:  MOVWF  FE9
41EC:  MOVLW  00
41EE:  ADDWFC xFA,W
41F0:  MOVWF  FEA
41F2:  MOVF   FEF,W
41F4:  SUBLW  03
41F6:  BNC   423C
....................             if (ps->TxBuffer != INVALID_BUFFER) { 
41F8:  MOVLW  0F
41FA:  ADDWF  xF9,W
41FC:  MOVWF  FE9
41FE:  MOVLW  00
4200:  ADDWFC xFA,W
4202:  MOVWF  FEA
4204:  INCFSZ FEF,W
4206:  BRA    420A
4208:  BRA    4232
....................                MACSetTxBuffer(ps->TxBuffer, 0); 
420A:  MOVLW  0F
420C:  ADDWF  xF9,W
420E:  MOVWF  FE9
4210:  MOVLW  00
4212:  ADDWFC xFA,W
4214:  MOVWF  FEA
4216:  MOVFF  FEF,200
421A:  MOVFF  200,293
421E:  MOVLB  2
4220:  CLRF   x95
4222:  CLRF   x94
4224:  MOVLB  0
4226:  CALL   15C4
....................                MACFlush(); 
422A:  CALL   1820
....................             } 
....................             else 
422E:  BRA    4238
4230:  MOVLB  1
....................                flags = ACK; 
4232:  MOVLW  10
4234:  MOVWF  xFF
4236:  MOVLB  0
....................          } 
....................          else { 
4238:  BRA    4296
423A:  MOVLB  1
....................             // Forget about previous transmission. 
....................             if (ps->TxBuffer != INVALID_BUFFER) { 
423C:  MOVLW  0F
423E:  ADDWF  xF9,W
4240:  MOVWF  FE9
4242:  MOVLW  00
4244:  ADDWFC xFA,W
4246:  MOVWF  FEA
4248:  INCFSZ FEF,W
424A:  BRA    424E
424C:  BRA    4286
....................                MACDiscardTx(ps->TxBuffer); 
424E:  MOVLW  0F
4250:  ADDWF  xF9,W
4252:  MOVWF  FE9
4254:  MOVLW  00
4256:  ADDWFC xFA,W
4258:  MOVWF  FEA
425A:  MOVFF  FEF,200
425E:  CLRF   19
4260:  BTFSC  FF2.7
4262:  BSF    19.7
4264:  BCF    FF2.7
4266:  MOVFF  200,2AC
426A:  MOVLB  0
426C:  CALL   0004
4270:  BTFSC  19.7
4272:  BSF    FF2.7
....................                ps->TxBuffer = INVALID_BUFFER; 
4274:  MOVLW  0F
4276:  MOVLB  1
4278:  ADDWF  xF9,W
427A:  MOVWF  FE9
427C:  MOVLW  00
427E:  ADDWFC xFA,W
4280:  MOVWF  FEA
4282:  MOVLW  FF
4284:  MOVWF  FEF
....................             } 
....................  
.................... #endif 
....................             // Request closure. 
....................             flags = FIN | ACK; 
4286:  MOVLW  11
4288:  MOVWF  xFF
....................             //DebugPrint("!"); 
....................  
....................             ps->smState = TCP_FIN_WAIT_1; 
428A:  MOVFF  1F9,FE9
428E:  MOVFF  1FA,FEA
4292:  MOVLW  04
4294:  MOVWF  FEF
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          } 
.................... #endif 
....................          break; 
4296:  MOVLB  1
4298:  BRA    4328
....................  
....................       case TCP_FIN_WAIT_1: 
....................          if (ps->RetryCount <= MAX_RETRY_COUNTS) { 
429A:  MOVLW  1E
429C:  MOVLB  1
429E:  ADDWF  xF9,W
42A0:  MOVWF  FE9
42A2:  MOVLW  00
42A4:  ADDWFC xFA,W
42A6:  MOVWF  FEA
42A8:  MOVF   FEF,W
42AA:  SUBLW  03
42AC:  BNC   42B4
....................             // Send another FIN 
....................             flags = FIN; 
42AE:  MOVLW  01
42B0:  MOVWF  xFF
....................          } 
....................          else { 
42B2:  BRA    42C4
....................             // Close on our own, we can't seem to communicate 
....................             // with the remote node anymore 
....................             CloseSocket(ps); 
42B4:  MOVFF  1FA,23F
42B8:  MOVFF  1F9,23E
42BC:  MOVLB  0
42BE:  CALL   28BE
42C2:  MOVLB  1
....................          } 
....................          break; 
42C4:  BRA    4328
....................  
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_CLOSING: 
....................          // Close on our own, we can't seem to communicate 
....................          // with the remote node anymore 
....................          CloseSocket(ps); 
42C6:  MOVFF  1FA,23F
42CA:  MOVFF  1F9,23E
42CE:  CALL   28BE
....................          break; 
42D2:  MOVLB  1
42D4:  BRA    4328
....................  
....................       case TCP_TIME_WAIT: 
....................          // Wait around for a while (2MSL) and then goto closed state 
....................          CloseSocket(ps); 
42D6:  MOVFF  1FA,23F
42DA:  MOVFF  1F9,23E
42DE:  CALL   28BE
....................          break; 
42E2:  MOVLB  1
42E4:  BRA    4328
....................  
....................       case TCP_CLOSE_WAIT: 
....................          flags = FIN; 
42E6:  MOVLW  01
42E8:  MOVLB  1
42EA:  MOVWF  xFF
....................          ps->smState = TCP_LAST_ACK; 
42EC:  MOVFF  1F9,FE9
42F0:  MOVFF  1FA,FEA
42F4:  MOVLW  09
42F6:  MOVWF  FEF
....................          break; 
42F8:  BRA    4328
....................  
....................       case TCP_LAST_ACK: 
....................          // Send some more FINs or close anyway 
....................          if (ps->RetryCount <= MAX_RETRY_COUNTS) 
42FA:  MOVLW  1E
42FC:  MOVLB  1
42FE:  ADDWF  xF9,W
4300:  MOVWF  FE9
4302:  MOVLW  00
4304:  ADDWFC xFA,W
4306:  MOVWF  FEA
4308:  MOVF   FEF,W
430A:  SUBLW  03
430C:  BNC   4314
....................             flags = FIN; 
430E:  MOVLW  01
4310:  MOVWF  xFF
....................          else 
4312:  BRA    4324
....................             CloseSocket(ps); 
4314:  MOVFF  1FA,23F
4318:  MOVFF  1F9,23E
431C:  MOVLB  0
431E:  CALL   28BE
4322:  MOVLB  1
....................          break; 
4324:  BRA    4328
4326:  MOVLB  1
....................       } 
....................  
....................       if (flags) { 
4328:  MOVF   xFF,F
432A:  BTFSC  FD8.2
432C:  BRA    4450
....................          if (flags & ACK) 
432E:  BTFSS  xFF.4
4330:  BRA    4360
....................             seq = ps->SND_SEQ; 
4332:  MOVLW  16
4334:  ADDWF  xF9,W
4336:  MOVWF  FE9
4338:  MOVLW  00
433A:  ADDWFC xFA,W
433C:  MOVWF  FEA
433E:  MOVFF  FEF,00
4342:  MOVFF  FEC,01
4346:  MOVFF  FEC,02
434A:  MOVFF  FEC,03
434E:  MOVFF  03,1FE
4352:  MOVFF  02,1FD
4356:  MOVFF  01,1FC
435A:  MOVFF  00,1FB
....................          else { 
435E:  BRA    43A4
....................             //seq = ps->SND_SEQ++;  //currently buggy in CCS 
....................             seq = ps->SND_SEQ; 
4360:  MOVLW  16
4362:  ADDWF  xF9,W
4364:  MOVWF  FE9
4366:  MOVLW  00
4368:  ADDWFC xFA,W
436A:  MOVWF  FEA
436C:  MOVFF  FEF,00
4370:  MOVFF  FEC,01
4374:  MOVFF  FEC,02
4378:  MOVFF  FEC,03
437C:  MOVFF  03,1FE
4380:  MOVFF  02,1FD
4384:  MOVFF  01,1FC
4388:  MOVFF  00,1FB
....................             ps->SND_SEQ++; 
438C:  MOVLW  16
438E:  ADDWF  xF9,W
4390:  MOVWF  FE9
4392:  MOVLW  00
4394:  ADDWFC xFA,W
4396:  MOVWF  FEA
4398:  MOVLW  01
439A:  ADDWF  FEE,F
439C:  MOVLW  00
439E:  ADDWFC FEE,F
43A0:  ADDWFC FEE,F
43A2:  ADDWFC FED,F
....................          } 
....................  
....................          SendTCP(&ps->remote, ps->localPort, ps->remotePort, seq, 
....................                ps->SND_ACK, flags); 
43A4:  MOVLW  01
43A6:  ADDWF  xF9,W
43A8:  MOVWF  01
43AA:  MOVLW  00
43AC:  ADDWFC xFA,W
43AE:  MOVWF  03
43B0:  MOVFF  01,200
43B4:  MOVLB  2
43B6:  MOVWF  x01
43B8:  MOVLW  0B
43BA:  MOVLB  1
43BC:  ADDWF  xF9,W
43BE:  MOVWF  FE9
43C0:  MOVLW  00
43C2:  ADDWFC xFA,W
43C4:  MOVWF  FEA
43C6:  MOVFF  FEC,203
43CA:  MOVF   FED,F
43CC:  MOVFF  FEF,202
43D0:  MOVLW  0D
43D2:  ADDWF  xF9,W
43D4:  MOVWF  FE9
43D6:  MOVLW  00
43D8:  ADDWFC xFA,W
43DA:  MOVWF  FEA
43DC:  MOVFF  FEC,205
43E0:  MOVF   FED,F
43E2:  MOVFF  FEF,204
43E6:  MOVLW  1A
43E8:  ADDWF  xF9,W
43EA:  MOVWF  FE9
43EC:  MOVLW  00
43EE:  ADDWFC xFA,W
43F0:  MOVWF  FEA
43F2:  MOVFF  FEF,206
43F6:  MOVFF  FEC,207
43FA:  MOVFF  FEC,208
43FE:  MOVFF  FEC,209
4402:  MOVFF  03,243
4406:  MOVFF  01,242
440A:  MOVFF  203,245
440E:  MOVFF  202,244
4412:  MOVFF  205,247
4416:  MOVFF  204,246
441A:  MOVFF  1FE,24B
441E:  MOVFF  1FD,24A
4422:  MOVFF  1FC,249
4426:  MOVFF  1FB,248
442A:  MOVFF  209,24F
442E:  MOVFF  208,24E
4432:  MOVFF  207,24D
4436:  MOVFF  206,24C
443A:  MOVFF  1FF,250
443E:  MOVLW  FF
4440:  MOVLB  2
4442:  MOVWF  x51
4444:  CLRF   x53
4446:  CLRF   x52
4448:  MOVLB  0
444A:  CALL   2DE4
444E:  MOVLB  1
....................       } 
....................  
....................       /*if (debugLastState != ps->smState) 
....................        { 
....................        debug_tcp("\r\nTCP TICK %u - ", s); 
....................        DebugTCPDisplayState(debugLastState); 
....................        debug_tcp(" -> "); 
....................        DebugTCPDisplayState(ps->smState); 
....................        }*/ 
....................    } 
4450:  INCF   xF4,F
4452:  BRA    3FA0
4454:  MOVLB  0
.................... } 
4456:  GOTO   462A (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPProcess(NODE_INFO* remote, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  len         - Total length of TCP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPProcess(NODE_INFO *remote, IP_ADDR *localIP, WORD len) { 
....................    TCP_HEADER TCPHeader; 
....................    PSEUDO_HEADER pseudoHeader; 
....................    TCP_SOCKET socket; 
....................    WORD_VAL checksum1; 
....................    WORD_VAL checksum2; 
....................    BYTE optionsSize; 
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress = remote->IPAddr; 
*
3B04:  MOVLW  06
3B06:  MOVLB  1
3B08:  ADDWF  xF4,W
3B0A:  MOVWF  FE9
3B0C:  MOVLW  00
3B0E:  ADDWFC xF5,W
3B10:  MOVWF  FEA
3B12:  MOVFF  FEF,00
3B16:  MOVFF  FEC,01
3B1A:  MOVFF  FEC,02
3B1E:  MOVFF  FEC,03
3B22:  MOVFF  03,211
3B26:  MOVFF  02,210
3B2A:  MOVFF  01,20F
3B2E:  MOVFF  00,20E
....................    pseudoHeader.DestAddress = *localIP; 
3B32:  MOVFF  1F6,FE9
3B36:  MOVFF  1F7,FEA
3B3A:  MOVFF  FEF,00
3B3E:  MOVFF  FEC,01
3B42:  MOVFF  FEC,02
3B46:  MOVFF  FEC,03
3B4A:  MOVFF  03,215
3B4E:  MOVFF  02,214
3B52:  MOVFF  01,213
3B56:  MOVFF  00,212
....................    pseudoHeader.Zero = 0x0; 
3B5A:  MOVLB  2
3B5C:  CLRF   x16
....................    pseudoHeader.Protocol = IP_PROT_TCP; 
3B5E:  MOVLW  06
3B60:  MOVWF  x17
....................    pseudoHeader.TCPLength = len; 
3B62:  MOVFF  1F9,219
3B66:  MOVFF  1F8,218
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
3B6A:  MOVFF  219,29A
3B6E:  MOVFF  218,299
3B72:  MOVLB  0
3B74:  CALL   1254
3B78:  MOVFF  02,219
3B7C:  MOVFF  01,218
....................  
....................    checksum1.Val = ~CalcIPChecksum((BYTE*) &pseudoHeader, 
....................          sizeof(pseudoHeader)); 
3B80:  MOVLW  02
3B82:  MOVLB  2
3B84:  MOVWF  x21
3B86:  MOVLW  0E
3B88:  MOVFF  221,27D
3B8C:  MOVWF  x7C
3B8E:  CLRF   x7F
3B90:  MOVLW  0C
3B92:  MOVWF  x7E
3B94:  MOVLB  0
3B96:  CALL   2166
3B9A:  MOVFF  01,21B
3B9E:  MOVLB  2
3BA0:  COMF   x1B,F
3BA2:  MOVFF  02,21C
3BA6:  COMF   x1C,F
....................  
....................    // Now calculate TCP packet checksum in NIC RAM - should match 
....................    // pesudo header checksum 
....................    checksum2.Val = CalcIPBufferChecksum(len); 
3BA8:  MOVFF  1F9,27B
3BAC:  MOVFF  1F8,27A
3BB0:  MOVLB  0
3BB2:  CALL   22A0
3BB6:  MOVFF  02,21E
3BBA:  MOVFF  01,21D
....................  
....................    // Compare checksums.  Note that the endianness is different. 
....................    if (checksum1.v[0] != checksum2.v[1] || checksum1.v[1] != checksum2.v[0]) { 
3BBE:  MOVLB  2
3BC0:  MOVF   x1E,W
3BC2:  SUBWF  x1B,W
3BC4:  BNZ   3BCC
3BC6:  MOVF   x1D,W
3BC8:  SUBWF  x1C,W
3BCA:  BZ    3BDA
....................       MACDiscardRx(); 
3BCC:  MOVLB  0
3BCE:  CALL   1138
....................       return TRUE; 
3BD2:  MOVLW  01
3BD4:  MOVWF  01
3BD6:  BRA    3CBE
3BD8:  MOVLB  2
....................    } 
....................  
....................    // Retrieve TCP header. 
....................    IPSetRxBuffer(0); 
3BDA:  CLRF   x22
3BDC:  CLRF   x21
3BDE:  MOVLB  0
3BE0:  CALL   246C
....................    MACGetArray((BYTE*) &TCPHeader, sizeof(TCPHeader)); 
3BE4:  MOVLW  01
3BE6:  MOVLB  2
3BE8:  MOVWF  x21
3BEA:  MOVLW  FA
3BEC:  MOVFF  221,289
3BF0:  MOVWF  x88
3BF2:  CLRF   x8B
3BF4:  MOVLW  14
3BF6:  MOVWF  x8A
3BF8:  MOVLB  0
3BFA:  CALL   11D8
....................    SwapTCPHeader(&TCPHeader); 
3BFE:  MOVLW  01
3C00:  MOVLB  2
3C02:  MOVWF  x7B
3C04:  MOVLW  FA
3C06:  MOVWF  x7A
3C08:  MOVLB  0
3C0A:  CALL   24A8
....................  
....................    // Skip over options and retrieve all data bytes. 
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2) - sizeof(TCPHeader)); 
3C0E:  MOVLB  2
3C10:  SWAPF  x06,W
3C12:  ANDLW  0F
3C14:  MOVWF  00
3C16:  RLCF   00,W
3C18:  MOVWF  x20
3C1A:  RLCF   x20,F
3C1C:  MOVLW  FC
3C1E:  ANDWF  x20,F
3C20:  MOVLW  14
3C22:  SUBWF  x20,W
3C24:  MOVWF  x1F
....................    len = len - optionsSize - sizeof(TCPHeader); 
3C26:  MOVF   x1F,W
3C28:  MOVLB  1
3C2A:  SUBWF  xF8,W
3C2C:  MOVLB  2
3C2E:  MOVWF  x20
3C30:  MOVLW  00
3C32:  MOVLB  1
3C34:  SUBWFB xF9,W
3C36:  MOVLB  2
3C38:  MOVWF  x21
3C3A:  MOVLW  14
3C3C:  SUBWF  x20,W
3C3E:  MOVLB  1
3C40:  MOVWF  xF8
3C42:  MOVLW  00
3C44:  MOVLB  2
3C46:  SUBWFB x21,W
3C48:  MOVLB  1
3C4A:  MOVWF  xF9
....................  
....................    // Position packet read pointer to start of data area. 
....................    IPSetRxBuffer((TCPHeader.DataOffset.Val << 2)); 
3C4C:  MOVLB  2
3C4E:  SWAPF  x06,W
3C50:  ANDLW  0F
3C52:  MOVWF  00
3C54:  RLCF   00,W
3C56:  MOVWF  x20
3C58:  RLCF   x20,F
3C5A:  MOVLW  FC
3C5C:  ANDWF  x20,F
3C5E:  CLRF   x22
3C60:  MOVFF  220,221
3C64:  MOVLB  0
3C66:  CALL   246C
....................  
....................    // Find matching socket. 
....................    socket = FindMatching_TCP_Socket(&TCPHeader, remote); 
3C6A:  MOVLW  01
3C6C:  MOVLB  2
3C6E:  MOVWF  x21
3C70:  MOVLW  FA
3C72:  MOVWF  x20
3C74:  MOVFF  1F5,223
3C78:  MOVFF  1F4,222
3C7C:  MOVLB  0
3C7E:  GOTO   26CE
3C82:  MOVFF  01,21A
....................    if (socket != INVALID_SOCKET) { 
3C86:  MOVLB  2
3C88:  MOVF   x1A,W
3C8A:  SUBLW  FE
3C8C:  BZ    3CB4
....................       HandleTCPSeg(socket, remote, &TCPHeader, len); 
3C8E:  MOVFF  21A,220
3C92:  MOVFF  1F5,222
3C96:  MOVFF  1F4,221
3C9A:  MOVLW  01
3C9C:  MOVWF  x24
3C9E:  MOVLW  FA
3CA0:  MOVWF  x23
3CA2:  MOVFF  1F9,226
3CA6:  MOVFF  1F8,225
3CAA:  MOVLB  0
3CAC:  GOTO   3012
....................    } 
....................    else { 
3CB0:  BRA    3CBA
3CB2:  MOVLB  2
....................       // If this is an unknown socket, or we don't have any 
....................       // listening sockets available, discard it we can't 
....................       // process it right now 
....................       MACDiscardRx(); 
3CB4:  MOVLB  0
3CB6:  CALL   1138
....................  
.................... //      // Send a RESET to the remote node is it knows that we 
.................... //      // are not available 
.................... //      TCPHeader.AckNumber += len; 
.................... //      if( TCPHeader.Flags.bits.flagSYN || 
.................... //         TCPHeader.Flags.bits.flagFIN ) 
.................... //         TCPHeader.AckNumber++; 
.................... // 
.................... //      SendTCP(remote, 
.................... //         TCPHeader.DestPort, 
.................... //         TCPHeader.SourcePort, 
.................... //         TCPHeader.AckNumber, 
.................... //         TCPHeader.SeqNumber, 
.................... //         RST); 
....................    } 
....................  
....................    return TRUE; 
3CBA:  MOVLW  01
3CBC:  MOVWF  01
.................... } 
3CBE:  GOTO   4570 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        static void TransmitTCP(NODE_INFO* remote 
....................  *                                          TCP_PORT localPort, 
....................  *                                          TCP_PORT remotePort, 
....................  *                                          DWORD seq, 
....................  *                                          DWORD ack, 
....................  *                                          BYTE flags, 
....................  *                                          BUFFER buffer, 
....................  *                                          WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  localPort   - Source port number 
....................  *                  remotePort  - Destination port number 
....................  *                  seq         - Segment sequence number 
....................  *                  ack         - Segment acknowledge number 
....................  *                  flags       - Segment flags 
....................  *                  buffer      - Buffer to which this segment 
....................  *                                is to be transmitted 
....................  *                  len         - Total data length for this segment. 
....................  * 
....................  * Output:          A TCP segment is assembled and put to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void TransmitTCP(NODE_INFO *remote, TCP_PORT localPort, 
....................       TCP_PORT remotePort, DWORD tseq, DWORD tack, BYTE flags, BUFFER buff, 
....................       WORD len) { 
....................    WORD_VAL checkSum; 
....................    TCP_HEADER header; 
....................    TCP_OPTIONS options; 
....................    PSEUDO_HEADER pseudoHeader; 
....................  
....................    /* 
....................    debug_tcp("\r\n\nTCP OUT => LP:%LX RP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X", 
....................          localPort, 
....................          remotePort, 
....................          tseq, 
....................          tack, 
....................          len, 
....................          flags 
....................    ); 
....................    */ 
....................  
....................    //  Make sure that this Tx buffer isn't currently being transmitted 
....................    while (!IPIsTxReady(TRUE)) 
....................       ;   //TODO: This may need to be conditionally false 
*
2DE4:  MOVLW  01
2DE6:  MOVLB  2
2DE8:  MOVWF  x7A
2DEA:  MOVLB  0
2DEC:  RCALL  29CE
2DEE:  MOVF   01,F
2DF0:  BZ    2DE4
....................  
....................    // Obtain an AutoFree buffer if this packet is a control packet 
....................    // only (contains no application data in an already allocated 
....................    // buffer) 
....................    if (buff == INVALID_BUFFER) 
2DF2:  MOVLB  2
2DF4:  INCFSZ x51,W
2DF6:  BRA    2E08
....................       buff = MACGetTxBuffer(TRUE); 
2DF8:  MOVLW  01
2DFA:  MOVWF  x7A
2DFC:  MOVLB  0
2DFE:  CALL   159C
2E02:  MOVFF  01,251
2E06:  MOVLB  2
....................  
....................    if (buff == INVALID_BUFFER) 
2E08:  INCFSZ x51,W
2E0A:  BRA    2E0E
....................       return; 
2E0C:  BRA    300E
....................  
....................    IPSetTxBuffer(buff, 0); 
2E0E:  MOVFF  251,293
2E12:  CLRF   x95
2E14:  MOVLW  14
2E16:  MOVWF  x94
2E18:  MOVLB  0
2E1A:  CALL   15C4
....................  
....................    header.SourcePort = localPort; 
2E1E:  MOVFF  245,257
2E22:  MOVFF  244,256
....................    header.DestPort = remotePort; 
2E26:  MOVFF  247,259
2E2A:  MOVFF  246,258
....................    header.SeqNumber = tseq; 
2E2E:  MOVFF  24B,25D
2E32:  MOVFF  24A,25C
2E36:  MOVFF  249,25B
2E3A:  MOVFF  248,25A
....................    header.AckNumber = tack; 
2E3E:  MOVFF  24F,261
2E42:  MOVFF  24E,260
2E46:  MOVFF  24D,25F
2E4A:  MOVFF  24C,25E
....................    header.Flags.bits.Reserved2 = 0; 
2E4E:  MOVLW  3F
2E50:  MOVLB  2
2E52:  ANDWF  x63,W
2E54:  MOVWF  x63
....................    header.DataOffset.Reserved3 = 0; 
2E56:  MOVLW  F0
2E58:  ANDWF  x62,W
2E5A:  MOVWF  x62
....................    header.Flags.b = flags; 
2E5C:  MOVFF  250,263
....................    // Receive window = MAC Free buffer size - TCP header (20) - IP header (20) 
....................    //                  - ETHERNET header (14 if using NIC) . 
....................    header.Window = MACGetFreeRxSize(); 
2E60:  MOVLB  0
2E62:  BRA    29F2
2E64:  MOVFF  02,265
2E68:  MOVFF  01,264
.................... #if STACK_USE_SLIP 
....................    /* 
....................     * Limit one segment at a time from remote host. 
....................     * This limit increases overall throughput as remote host does not 
....................     * flood us with packets and later retry with significant delay. 
....................     */ 
....................    if ( header.Window >= MAC_RX_BUFFER_SIZE ) 
....................    header.Window = MAC_RX_BUFFER_SIZE; 
....................  
....................    else if ( header.Window > 54 ) 
....................    { 
....................       header.Window -= 54; 
....................    } 
....................    else 
....................    header.Window = 0; 
.................... #else 
....................    if (header.Window > 40) { 
2E6C:  MOVLB  2
2E6E:  MOVF   x65,F
2E70:  BNZ   2E78
2E72:  MOVF   x64,W
2E74:  SUBLW  28
2E76:  BC    2E82
....................       header.Window -= 40; 
2E78:  MOVLW  28
2E7A:  SUBWF  x64,F
2E7C:  MOVLW  00
2E7E:  SUBWFB x65,F
....................    } 
....................    else 
2E80:  BRA    2E86
....................       header.Window = 0; 
2E82:  CLRF   x65
2E84:  CLRF   x64
.................... #endif 
....................  
....................    header.Checksum = 0; 
2E86:  CLRF   x67
2E88:  CLRF   x66
....................    header.UrgentPointer = 0; 
2E8A:  CLRF   x69
2E8C:  CLRF   x68
....................  
....................    SwapTCPHeader(&header); 
2E8E:  MOVLW  02
2E90:  MOVWF  x7B
2E92:  MOVLW  56
2E94:  MOVWF  x7A
2E96:  MOVLB  0
2E98:  CALL   24A8
....................  
....................    len += sizeof(header); 
2E9C:  MOVLW  14
2E9E:  MOVLB  2
2EA0:  ADDWF  x52,F
2EA2:  MOVLW  00
2EA4:  ADDWFC x53,F
....................  
....................    if (flags & SYN) { 
2EA6:  BTFSS  x50.1
2EA8:  BRA    2EC8
....................       len += sizeof(options); 
2EAA:  MOVLW  04
2EAC:  ADDWF  x52,F
2EAE:  MOVLW  00
2EB0:  ADDWFC x53,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE; 
2EB2:  MOVLW  02
2EB4:  MOVWF  x6A
....................       options.Length = 0x04; 
2EB6:  MOVLW  04
2EB8:  MOVWF  x6B
....................  
....................       // Load MSS in already swapped order. 
....................       options.MaxSegSize.v[0] = (MAC_RX_BUFFER_SIZE >> 8); // 0x05; 
2EBA:  MOVWF  x6C
....................       options.MaxSegSize.v[1] = (MAC_RX_BUFFER_SIZE & 0xff); // 0xb4; 
2EBC:  CLRF   x6D
....................  
....................       header.DataOffset.Val = (sizeof(header) + sizeof(options)) >> 2; 
2EBE:  MOVLW  0F
2EC0:  ANDWF  x62,W
2EC2:  IORLW  60
2EC4:  MOVWF  x62
....................    } 
....................    else 
2EC6:  BRA    2ED0
....................       header.DataOffset.Val = sizeof(header) >> 2; 
2EC8:  MOVLW  0F
2ECA:  ANDWF  x62,W
2ECC:  IORLW  50
2ECE:  MOVWF  x62
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress = AppConfig.MyIPAddr; 
2ED0:  MOVFF  46,271
2ED4:  MOVFF  45,270
2ED8:  MOVFF  44,26F
2EDC:  MOVFF  43,26E
....................    pseudoHeader.DestAddress = remote->IPAddr; 
2EE0:  MOVLW  06
2EE2:  ADDWF  x42,W
2EE4:  MOVWF  FE9
2EE6:  MOVLW  00
2EE8:  ADDWFC x43,W
2EEA:  MOVWF  FEA
2EEC:  MOVFF  FEF,00
2EF0:  MOVFF  FEC,01
2EF4:  MOVFF  FEC,02
2EF8:  MOVFF  FEC,03
2EFC:  MOVFF  03,275
2F00:  MOVFF  02,274
2F04:  MOVFF  01,273
2F08:  MOVFF  00,272
....................    pseudoHeader.Zero = 0x0; 
2F0C:  CLRF   x76
....................    pseudoHeader.Protocol = IP_PROT_TCP; 
2F0E:  MOVLW  06
2F10:  MOVWF  x77
....................    pseudoHeader.TCPLength = len; 
2F12:  MOVFF  253,279
2F16:  MOVFF  252,278
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
2F1A:  MOVFF  279,29A
2F1E:  MOVFF  278,299
2F22:  MOVLB  0
2F24:  CALL   1254
2F28:  MOVFF  02,279
2F2C:  MOVFF  01,278
....................  
....................    header.Checksum = ~CalcIPChecksum((BYTE*) &pseudoHeader, 
....................          sizeof(pseudoHeader)); 
2F30:  MOVLW  02
2F32:  MOVLB  2
2F34:  MOVWF  x7B
2F36:  MOVLW  6E
2F38:  MOVFF  27B,27D
2F3C:  MOVWF  x7C
2F3E:  CLRF   x7F
2F40:  MOVLW  0C
2F42:  MOVWF  x7E
2F44:  MOVLB  0
2F46:  CALL   2166
2F4A:  MOVFF  01,266
2F4E:  MOVLB  2
2F50:  COMF   x66,F
2F52:  MOVFF  02,267
2F56:  COMF   x67,F
....................    checkSum.Val = header.Checksum; 
2F58:  MOVFF  267,255
2F5C:  MOVFF  266,254
....................  
....................    // Write IP header. 
....................    IPPutHeader(remote, IP_PROT_TCP, len); 
2F60:  MOVFF  243,27B
2F64:  MOVFF  242,27A
2F68:  MOVLW  06
2F6A:  MOVWF  x7C
2F6C:  MOVFF  253,27E
2F70:  MOVFF  252,27D
2F74:  MOVLB  0
2F76:  RCALL  2CB4
....................    IPPutArray((BYTE* )&header, sizeof(header)); 
2F78:  MOVLW  02
2F7A:  MOVLB  2
2F7C:  MOVWF  x7B
2F7E:  MOVLW  56
2F80:  MOVFF  27B,29F
2F84:  MOVWF  x9E
2F86:  CLRF   xA1
2F88:  MOVLW  14
2F8A:  MOVWF  xA0
2F8C:  MOVLB  0
2F8E:  CALL   16C0
....................  
....................    if (flags & SYN) 
2F92:  MOVLB  2
2F94:  BTFSS  x50.1
2F96:  BRA    2FB2
....................       IPPutArray((BYTE* )&options, sizeof(options)); 
2F98:  MOVLW  02
2F9A:  MOVWF  x7B
2F9C:  MOVLW  6A
2F9E:  MOVFF  27B,29F
2FA2:  MOVWF  x9E
2FA4:  CLRF   xA1
2FA6:  MOVLW  04
2FA8:  MOVWF  xA0
2FAA:  MOVLB  0
2FAC:  CALL   16C0
2FB0:  MOVLB  2
....................  
....................    IPSetTxBuffer(buff, 0); 
2FB2:  MOVFF  251,293
2FB6:  CLRF   x95
2FB8:  MOVLW  14
2FBA:  MOVWF  x94
2FBC:  MOVLB  0
2FBE:  CALL   15C4
....................  
....................    checkSum.Val = CalcIPBufferChecksum(len); 
2FC2:  MOVFF  253,27B
2FC6:  MOVFF  252,27A
2FCA:  CALL   22A0
2FCE:  MOVFF  02,255
2FD2:  MOVFF  01,254
....................  
....................    // Update the checksum. 
....................    IPSetTxBuffer(buff, 16); 
2FD6:  MOVFF  251,293
2FDA:  MOVLB  2
2FDC:  CLRF   x95
2FDE:  MOVLW  24
2FE0:  MOVWF  x94
2FE2:  MOVLB  0
2FE4:  CALL   15C4
....................    MACPut(checkSum.v[1]); 
2FE8:  MOVFF  255,29D
2FEC:  CALL   168A
....................    MACPut(checkSum.v[0]); 
2FF0:  MOVFF  254,29D
2FF4:  CALL   168A
....................    MACSetTxBuffer(buff, 0); 
2FF8:  MOVFF  251,293
2FFC:  MOVLB  2
2FFE:  CLRF   x95
3000:  CLRF   x94
3002:  MOVLB  0
3004:  CALL   15C4
....................  
....................    MACFlush(); 
3008:  CALL   1820
300C:  MOVLB  2
....................  
.................... #if !TCP_NO_WAIT_FOR_ACK /*&& !defined(DEBUG)*/ 
....................    // If we send the packet again, the remote node might think that we timed 
....................    // out and retransmitted.  It could thus immediately send back an ACK and 
....................    // dramatically improve throuput. 
....................    //while(!IPIsTxReady(TRUE)); 
....................    //MACFlush(); 
.................... #endif 
.................... } 
300E:  MOVLB  0
3010:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................  *                                      NODE_INFO* remote) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           h           - TCP Header to be matched against. 
....................  *                  remote      - Node who sent this header. 
....................  * 
....................  * Output:          A socket that matches with given header and remote 
....................  *                  node is searched. 
....................  *                  If such socket is found, its index is returned 
....................  *                  else INVALID_SOCKET is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, NODE_INFO *remote) { 
....................    SOCKET_INFO *ps; 
....................    TCP_SOCKET s; 
....................    TCP_SOCKET partialMatch; 
....................  
....................    partialMatch = INVALID_SOCKET; 
*
26CE:  MOVLW  FE
26D0:  MOVLB  2
26D2:  MOVWF  x27
....................  
....................    for (s = 0; s < MAX_SOCKETS; s++) { 
26D4:  CLRF   x26
26D6:  MOVF   x26,W
26D8:  SUBLW  04
26DA:  BTFSS  FD8.0
26DC:  BRA    27D2
....................       ps = &TCB[s]; 
26DE:  MOVF   x26,W
26E0:  MULLW  24
26E2:  MOVF   FF3,W
26E4:  CLRF   03
26E6:  ADDLW  8A
26E8:  MOVWF  01
26EA:  MOVLW  00
26EC:  ADDWFC 03,F
26EE:  MOVFF  01,224
26F2:  MOVFF  03,225
....................  
....................       if (ps->smState != TCP_CLOSED) { 
26F6:  MOVFF  224,FE9
26FA:  MOVFF  225,FEA
26FE:  MOVF   FEF,W
2700:  SUBLW  0A
2702:  BZ    27CE
....................          if (ps->localPort == h->DestPort) { 
2704:  MOVLW  0B
2706:  ADDWF  x24,W
2708:  MOVWF  FE9
270A:  MOVLW  00
270C:  ADDWFC x25,W
270E:  MOVWF  FEA
2710:  MOVFF  FEC,229
2714:  MOVF   FED,F
2716:  MOVFF  FEF,228
271A:  MOVLW  02
271C:  ADDWF  x20,W
271E:  MOVWF  FE9
2720:  MOVLW  00
2722:  ADDWFC x21,W
2724:  MOVWF  FEA
2726:  MOVFF  FEC,03
272A:  MOVF   FED,F
272C:  MOVF   FEF,W
272E:  SUBWF  x28,W
2730:  BNZ   27CE
2732:  MOVF   03,W
2734:  SUBWF  x29,W
2736:  BNZ   27CE
....................             if (ps->smState == TCP_LISTEN) 
2738:  MOVFF  224,FE9
273C:  MOVFF  225,FEA
2740:  MOVF   FEF,F
2742:  BNZ   2748
....................                partialMatch = s; 
2744:  MOVFF  226,227
....................  
....................             if (ps->remotePort == h->SourcePort 
....................                   && ps->remote.IPAddr.Val == remote->IPAddr.Val) { 
2748:  MOVLW  0D
274A:  ADDWF  x24,W
274C:  MOVWF  FE9
274E:  MOVLW  00
2750:  ADDWFC x25,W
2752:  MOVWF  FEA
2754:  MOVFF  FEC,229
2758:  MOVF   FED,F
275A:  MOVFF  FEF,228
275E:  MOVFF  220,FE9
2762:  MOVFF  221,FEA
2766:  MOVFF  FEC,03
276A:  MOVF   FED,F
276C:  MOVF   FEF,W
276E:  SUBWF  x28,W
2770:  BNZ   27CE
2772:  MOVF   03,W
2774:  SUBWF  x29,W
2776:  BNZ   27CE
2778:  MOVLW  07
277A:  ADDWF  x24,W
277C:  MOVWF  FE9
277E:  MOVLW  00
2780:  ADDWFC x25,W
2782:  MOVWF  FEA
2784:  MOVFF  FEF,228
2788:  MOVFF  FEC,229
278C:  MOVFF  FEC,22A
2790:  MOVFF  FEC,22B
2794:  MOVLW  06
2796:  ADDWF  x22,W
2798:  MOVWF  FE9
279A:  MOVLW  00
279C:  ADDWFC x23,W
279E:  MOVWF  FEA
27A0:  MOVFF  FEF,00
27A4:  MOVFF  FEC,01
27A8:  MOVFF  FEC,02
27AC:  MOVFF  FEC,03
27B0:  MOVF   00,W
27B2:  SUBWF  x28,W
27B4:  BNZ   27CE
27B6:  MOVF   01,W
27B8:  SUBWF  x29,W
27BA:  BNZ   27CE
27BC:  MOVF   02,W
27BE:  SUBWF  x2A,W
27C0:  BNZ   27CE
27C2:  MOVF   03,W
27C4:  SUBWF  x2B,W
27C6:  BNZ   27CE
....................                return s; 
27C8:  MOVFF  226,01
27CC:  BRA    28B8
....................             } 
....................          } 
....................       } 
....................    } 
27CE:  INCF   x26,F
27D0:  BRA    26D6
....................  
....................    // We are not listening on this port 
....................    if (partialMatch == INVALID_SOCKET) 
27D2:  MOVF   x27,W
27D4:  SUBLW  FE
27D6:  BNZ   27DE
....................       return INVALID_SOCKET; 
27D8:  MOVLW  FE
27DA:  MOVWF  01
27DC:  BRA    28B8
....................  
....................    // Copy the remote node IP/MAC address and source TCP port 
....................    // number into our TCB and return this socket to the caller 
....................    ps = &TCB[partialMatch]; 
27DE:  MOVF   x27,W
27E0:  MULLW  24
27E2:  MOVF   FF3,W
27E4:  CLRF   03
27E6:  ADDLW  8A
27E8:  MOVWF  01
27EA:  MOVLW  00
27EC:  ADDWFC 03,F
27EE:  MOVFF  01,224
27F2:  MOVFF  03,225
....................    memcpy((void*) &ps->remote, (void*) remote, sizeof(*remote)); 
27F6:  MOVLW  01
27F8:  ADDWF  x24,W
27FA:  MOVWF  01
27FC:  MOVLW  00
27FE:  ADDWFC x25,W
2800:  MOVWF  03
2802:  MOVFF  01,228
2806:  MOVWF  x29
2808:  MOVWF  FEA
280A:  MOVFF  01,FE9
280E:  MOVFF  223,FE2
2812:  MOVFF  222,FE1
2816:  MOVLW  0A
2818:  MOVWF  01
281A:  MOVFF  FE6,FEE
281E:  DECFSZ 01,F
2820:  BRA    281A
....................    ps->remotePort = h->SourcePort; 
2822:  MOVLW  0D
2824:  ADDWF  x24,W
2826:  MOVWF  01
2828:  MOVLW  00
282A:  ADDWFC x25,W
282C:  MOVFF  220,FE9
2830:  MOVFF  221,FEA
2834:  MOVFF  FEC,03
2838:  MOVF   FED,F
283A:  MOVFF  FEF,22A
283E:  MOVWF  FEA
2840:  MOVFF  01,FE9
2844:  MOVFF  03,FEC
2848:  MOVF   FED,F
284A:  MOVFF  22A,FEF
....................    ps->Flags.bIsGetReady = FALSE; 
284E:  MOVLW  23
2850:  ADDWF  x24,W
2852:  MOVWF  FE9
2854:  MOVLW  00
2856:  ADDWFC x25,W
2858:  MOVWF  FEA
285A:  BCF    FEF.3
....................    if (ps->TxBuffer != INVALID_BUFFER) { 
285C:  MOVLW  0F
285E:  ADDWF  x24,W
2860:  MOVWF  FE9
2862:  MOVLW  00
2864:  ADDWFC x25,W
2866:  MOVWF  FEA
2868:  INCFSZ FEF,W
286A:  BRA    286E
286C:  BRA    28A6
....................       MACDiscardTx(ps->TxBuffer); 
286E:  MOVLW  0F
2870:  ADDWF  x24,W
2872:  MOVWF  FE9
2874:  MOVLW  00
2876:  ADDWFC x25,W
2878:  MOVWF  FEA
287A:  MOVFF  FEF,228
287E:  CLRF   19
2880:  BTFSC  FF2.7
2882:  BSF    19.7
2884:  BCF    FF2.7
2886:  MOVFF  228,2AC
288A:  MOVLB  0
288C:  CALL   0004
2890:  BTFSC  19.7
2892:  BSF    FF2.7
....................       ps->TxBuffer = INVALID_BUFFER; 
2894:  MOVLW  0F
2896:  MOVLB  2
2898:  ADDWF  x24,W
289A:  MOVWF  FE9
289C:  MOVLW  00
289E:  ADDWFC x25,W
28A0:  MOVWF  FEA
28A2:  MOVLW  FF
28A4:  MOVWF  FEF
....................    } 
....................    ps->Flags.bIsPutReady = TRUE; 
28A6:  MOVLW  23
28A8:  ADDWF  x24,W
28AA:  MOVWF  FE9
28AC:  MOVLW  00
28AE:  ADDWFC x25,W
28B0:  MOVWF  FEA
28B2:  BSF    FEF.1
....................  
....................    return partialMatch; 
28B4:  MOVFF  227,01
.................... } 
28B8:  MOVLB  0
28BA:  GOTO   3C82 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapTCPHeader(TCP_HEADER* header) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           header      - TCP Header to be swapped. 
....................  * 
....................  * Output:          Given header is swapped. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapTCPHeader(TCP_HEADER* header) { 
....................    header->SourcePort = swaps(header->SourcePort); 
*
24A8:  MOVLB  2
24AA:  MOVFF  27A,01
24AE:  MOVFF  27B,03
24B2:  MOVFF  27A,27C
24B6:  MOVFF  27B,27D
24BA:  MOVFF  27A,FE9
24BE:  MOVFF  27B,FEA
24C2:  MOVFF  FEC,27F
24C6:  MOVF   FED,F
24C8:  MOVFF  FEF,27E
24CC:  MOVFF  27F,29A
24D0:  MOVFF  27E,299
24D4:  MOVLB  0
24D6:  CALL   1254
24DA:  MOVFF  27D,FEA
24DE:  MOVFF  27C,FE9
24E2:  MOVFF  02,FEC
24E6:  MOVF   FED,F
24E8:  MOVFF  01,FEF
....................    header->DestPort = swaps(header->DestPort); 
24EC:  MOVLW  02
24EE:  MOVLB  2
24F0:  ADDWF  x7A,W
24F2:  MOVWF  01
24F4:  MOVLW  00
24F6:  ADDWFC x7B,W
24F8:  MOVWF  03
24FA:  MOVFF  01,27C
24FE:  MOVWF  x7D
2500:  MOVLW  02
2502:  ADDWF  x7A,W
2504:  MOVWF  FE9
2506:  MOVLW  00
2508:  ADDWFC x7B,W
250A:  MOVWF  FEA
250C:  MOVFF  FEC,27F
2510:  MOVF   FED,F
2512:  MOVFF  FEF,27E
2516:  MOVFF  27F,29A
251A:  MOVFF  27E,299
251E:  MOVLB  0
2520:  CALL   1254
2524:  MOVFF  27D,FEA
2528:  MOVFF  27C,FE9
252C:  MOVFF  02,FEC
2530:  MOVF   FED,F
2532:  MOVFF  01,FEF
....................    header->SeqNumber = swapl(header->SeqNumber); 
2536:  MOVLW  04
2538:  MOVLB  2
253A:  ADDWF  x7A,W
253C:  MOVWF  01
253E:  MOVLW  00
2540:  ADDWFC x7B,W
2542:  MOVWF  03
2544:  MOVFF  01,27C
2548:  MOVWF  x7D
254A:  MOVLW  04
254C:  ADDWF  x7A,W
254E:  MOVWF  FE9
2550:  MOVLW  00
2552:  ADDWFC x7B,W
2554:  MOVWF  FEA
2556:  MOVFF  FEF,27E
255A:  MOVFF  FEC,27F
255E:  MOVFF  FEC,280
2562:  MOVFF  FEC,281
2566:  MOVFF  281,285
256A:  MOVFF  280,284
256E:  MOVFF  27F,283
2572:  MOVFF  27E,282
2576:  MOVLB  0
2578:  RCALL  2486
257A:  MOVFF  27D,FEA
257E:  MOVFF  27C,FE9
2582:  MOVFF  00,FEF
2586:  MOVFF  01,FEC
258A:  MOVFF  02,FEC
258E:  MOVFF  03,FEC
....................    header->AckNumber = swapl(header->AckNumber); 
2592:  MOVLW  08
2594:  MOVLB  2
2596:  ADDWF  x7A,W
2598:  MOVWF  01
259A:  MOVLW  00
259C:  ADDWFC x7B,W
259E:  MOVWF  03
25A0:  MOVFF  01,27C
25A4:  MOVWF  x7D
25A6:  MOVLW  08
25A8:  ADDWF  x7A,W
25AA:  MOVWF  FE9
25AC:  MOVLW  00
25AE:  ADDWFC x7B,W
25B0:  MOVWF  FEA
25B2:  MOVFF  FEF,27E
25B6:  MOVFF  FEC,27F
25BA:  MOVFF  FEC,280
25BE:  MOVFF  FEC,281
25C2:  MOVFF  281,285
25C6:  MOVFF  280,284
25CA:  MOVFF  27F,283
25CE:  MOVFF  27E,282
25D2:  MOVLB  0
25D4:  RCALL  2486
25D6:  MOVFF  27D,FEA
25DA:  MOVFF  27C,FE9
25DE:  MOVFF  00,FEF
25E2:  MOVFF  01,FEC
25E6:  MOVFF  02,FEC
25EA:  MOVFF  03,FEC
....................    header->Window = swaps(header->Window); 
25EE:  MOVLW  0E
25F0:  MOVLB  2
25F2:  ADDWF  x7A,W
25F4:  MOVWF  01
25F6:  MOVLW  00
25F8:  ADDWFC x7B,W
25FA:  MOVWF  03
25FC:  MOVFF  01,27C
2600:  MOVWF  x7D
2602:  MOVLW  0E
2604:  ADDWF  x7A,W
2606:  MOVWF  FE9
2608:  MOVLW  00
260A:  ADDWFC x7B,W
260C:  MOVWF  FEA
260E:  MOVFF  FEC,27F
2612:  MOVF   FED,F
2614:  MOVFF  FEF,27E
2618:  MOVFF  27F,29A
261C:  MOVFF  27E,299
2620:  MOVLB  0
2622:  CALL   1254
2626:  MOVFF  27D,FEA
262A:  MOVFF  27C,FE9
262E:  MOVFF  02,FEC
2632:  MOVF   FED,F
2634:  MOVFF  01,FEF
....................    header->Checksum = swaps(header->Checksum); 
2638:  MOVLW  10
263A:  MOVLB  2
263C:  ADDWF  x7A,W
263E:  MOVWF  01
2640:  MOVLW  00
2642:  ADDWFC x7B,W
2644:  MOVWF  03
2646:  MOVFF  01,27C
264A:  MOVWF  x7D
264C:  MOVLW  10
264E:  ADDWF  x7A,W
2650:  MOVWF  FE9
2652:  MOVLW  00
2654:  ADDWFC x7B,W
2656:  MOVWF  FEA
2658:  MOVFF  FEC,27F
265C:  MOVF   FED,F
265E:  MOVFF  FEF,27E
2662:  MOVFF  27F,29A
2666:  MOVFF  27E,299
266A:  MOVLB  0
266C:  CALL   1254
2670:  MOVFF  27D,FEA
2674:  MOVFF  27C,FE9
2678:  MOVFF  02,FEC
267C:  MOVF   FED,F
267E:  MOVFF  01,FEF
....................    header->UrgentPointer = swaps(header->UrgentPointer); 
2682:  MOVLW  12
2684:  MOVLB  2
2686:  ADDWF  x7A,W
2688:  MOVWF  01
268A:  MOVLW  00
268C:  ADDWFC x7B,W
268E:  MOVWF  03
2690:  MOVFF  01,27C
2694:  MOVWF  x7D
2696:  MOVLW  12
2698:  ADDWF  x7A,W
269A:  MOVWF  FE9
269C:  MOVLW  00
269E:  ADDWFC x7B,W
26A0:  MOVWF  FEA
26A2:  MOVFF  FEC,27F
26A6:  MOVF   FED,F
26A8:  MOVFF  FEF,27E
26AC:  MOVFF  27F,29A
26B0:  MOVFF  27E,299
26B4:  MOVLB  0
26B6:  CALL   1254
26BA:  MOVFF  27D,FEA
26BE:  MOVFF  27C,FE9
26C2:  MOVFF  02,FEC
26C6:  MOVF   FED,F
26C8:  MOVFF  01,FEF
.................... } 
26CC:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        static void CloseSocket(SOCKET_INFO* ps) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           ps  - Pointer to a socket info that is to be 
....................  *                          closed. 
....................  * 
....................  * Output:          Given socket information is reset and any 
....................  *                  buffer held by this socket is discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void CloseSocket(SOCKET_INFO* ps) { 
.................... 	//debug_tcp("\r\nTCP SOCKET CLOSED"); 
....................  
....................    if (ps->TxBuffer != INVALID_BUFFER) { 
*
28BE:  MOVLW  0F
28C0:  MOVLB  2
28C2:  ADDWF  x3E,W
28C4:  MOVWF  FE9
28C6:  MOVLW  00
28C8:  ADDWFC x3F,W
28CA:  MOVWF  FEA
28CC:  INCFSZ FEF,W
28CE:  BRA    28D2
28D0:  BRA    2918
....................       MACDiscardTx(ps->TxBuffer); 
28D2:  MOVLW  0F
28D4:  ADDWF  x3E,W
28D6:  MOVWF  FE9
28D8:  MOVLW  00
28DA:  ADDWFC x3F,W
28DC:  MOVWF  FEA
28DE:  MOVFF  FEF,240
28E2:  CLRF   19
28E4:  BTFSC  FF2.7
28E6:  BSF    19.7
28E8:  BCF    FF2.7
28EA:  MOVFF  240,2AC
28EE:  MOVLB  0
28F0:  CALL   0004
28F4:  BTFSC  19.7
28F6:  BSF    FF2.7
....................       ps->TxBuffer = INVALID_BUFFER; 
28F8:  MOVLW  0F
28FA:  MOVLB  2
28FC:  ADDWF  x3E,W
28FE:  MOVWF  FE9
2900:  MOVLW  00
2902:  ADDWFC x3F,W
2904:  MOVWF  FEA
2906:  MOVLW  FF
2908:  MOVWF  FEF
....................       ps->Flags.bIsPutReady = TRUE; 
290A:  MOVLW  23
290C:  ADDWF  x3E,W
290E:  MOVWF  FE9
2910:  MOVLW  00
2912:  ADDWFC x3F,W
2914:  MOVWF  FEA
2916:  BSF    FEF.1
....................    } 
....................  
....................    ps->remote.IPAddr.Val = 0x00; 
2918:  MOVLW  07
291A:  ADDWF  x3E,W
291C:  MOVWF  FE9
291E:  MOVLW  00
2920:  ADDWFC x3F,W
2922:  MOVWF  FEA
2924:  MOVF   FEE,F
2926:  MOVF   FEE,F
2928:  CLRF   FEC
292A:  MOVF   FED,F
292C:  CLRF   FEF
292E:  MOVF   FED,F
2930:  CLRF   FEF
2932:  MOVF   FED,F
2934:  CLRF   FEF
....................    ps->remotePort = 0x00; 
2936:  MOVLW  0D
2938:  ADDWF  x3E,W
293A:  MOVWF  FE9
293C:  MOVLW  00
293E:  ADDWFC x3F,W
2940:  MOVWF  FEA
2942:  CLRF   FEC
2944:  MOVF   FED,F
2946:  CLRF   FEF
....................    if (ps->Flags.bIsGetReady) { 
2948:  MOVLW  23
294A:  ADDWF  x3E,W
294C:  MOVWF  FE9
294E:  MOVLW  00
2950:  ADDWFC x3F,W
2952:  MOVWF  FEA
2954:  BTFSS  FEF.3
2956:  BRA    2960
....................       MACDiscardRx(); 
2958:  MOVLB  0
295A:  CALL   1138
295E:  MOVLB  2
....................    } 
....................    ps->Flags.bIsGetReady = FALSE; 
2960:  MOVLW  23
2962:  ADDWF  x3E,W
2964:  MOVWF  FE9
2966:  MOVLW  00
2968:  ADDWFC x3F,W
296A:  MOVWF  FEA
296C:  BCF    FEF.3
....................    ps->TimeOut = TCP_START_TIMEOUT_VAL; 
296E:  MOVLW  21
2970:  ADDWF  x3E,W
2972:  MOVWF  FE9
2974:  MOVLW  00
2976:  ADDWFC x3F,W
2978:  MOVWF  FEA
297A:  CLRF   FEC
297C:  MOVF   FED,F
297E:  MOVLW  24
2980:  MOVWF  FEF
....................  
....................    ps->Flags.bIsTxInProgress = FALSE; 
2982:  MOVLW  23
2984:  ADDWF  x3E,W
2986:  MOVWF  FE9
2988:  MOVLW  00
298A:  ADDWFC x3F,W
298C:  MOVWF  FEA
298E:  BCF    FEF.4
....................  
....................    if (ps->Flags.bServer) { 
2990:  MOVLW  23
2992:  ADDWF  x3E,W
2994:  MOVWF  FE9
2996:  MOVLW  00
2998:  ADDWFC x3F,W
299A:  MOVWF  FEA
299C:  BTFSS  FEF.0
299E:  BRA    29AC
....................       ps->smState = TCP_LISTEN; 
29A0:  MOVFF  23E,FE9
29A4:  MOVFF  23F,FEA
29A8:  CLRF   FEF
....................    } 
....................    else { 
29AA:  BRA    29B8
....................       ps->smState = TCP_CLOSED; 
29AC:  MOVFF  23E,FE9
29B0:  MOVFF  23F,FEA
29B4:  MOVLW  0A
29B6:  MOVWF  FEF
....................    } 
....................  
....................    ps->TxCount = 0; 
29B8:  MOVLW  10
29BA:  ADDWF  x3E,W
29BC:  MOVWF  FE9
29BE:  MOVLW  00
29C0:  ADDWFC x3F,W
29C2:  MOVWF  FEA
29C4:  CLRF   FEC
29C6:  MOVF   FED,F
29C8:  CLRF   FEF
....................  
....................    return; 
.................... } 
29CA:  MOVLB  0
29CC:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        static void HandleTCPSeg(TCP_SOCKET s, 
....................  *                                      NODE_INFO *remote, 
....................  *                                      TCP_HEADER* h, 
....................  *                                      WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPProcess() is the caller. 
....................  * 
....................  * Input:           s           - Socket that owns this segment 
....................  *                  remote      - Remote node info 
....................  *                  h           - TCP Header 
....................  *                  len         - Total buffer length. 
....................  * 
....................  * Output:          TCP FSM is executed on given socket with 
....................  *                  given TCP segment. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void HandleTCPSeg(TCP_SOCKET s, NODE_INFO *remote, TCP_HEADER *h, 
....................       WORD len) { 
....................    DWORD ack; 
....................    DWORD seq; 
....................    DWORD prevAck, prevSeq; 
....................    SOCKET_INFO *ps; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................    signed int32 
....................    temp; 
....................  
....................    ps = &TCB[s]; 
*
3012:  MOVLB  2
3014:  MOVF   x20,W
3016:  MULLW  24
3018:  MOVF   FF3,W
301A:  CLRF   03
301C:  ADDLW  8A
301E:  MOVWF  01
3020:  MOVLW  00
3022:  ADDWFC 03,F
3024:  MOVFF  01,237
3028:  MOVFF  03,238
....................    //debugLastState = TCB[s].smState; 
....................  
....................    flags = 0x00; 
302C:  CLRF   x39
....................  
....................    // Clear timeout info 
....................    ps->RetryCount = 0; 
302E:  MOVLW  1E
3030:  ADDWF  x37,W
3032:  MOVWF  FE9
3034:  MOVLW  00
3036:  ADDWFC x38,W
3038:  MOVWF  FEA
303A:  CLRF   FEF
....................    ps->startTick = TickGet(); 
303C:  MOVLW  1F
303E:  ADDWF  x37,W
3040:  MOVWF  01
3042:  MOVLW  00
3044:  ADDWFC x38,W
3046:  MOVWF  03
3048:  MOVFF  01,23E
304C:  MOVWF  x3F
304E:  MOVLB  0
3050:  CALL   10B0
3054:  MOVFF  23F,FEA
3058:  MOVFF  23E,FE9
305C:  MOVFF  02,FEC
3060:  MOVF   FED,F
3062:  MOVFF  01,FEF
....................    ps->TimeOut = TCP_START_TIMEOUT_VAL; 
3066:  MOVLW  21
3068:  MOVLB  2
306A:  ADDWF  x37,W
306C:  MOVWF  FE9
306E:  MOVLW  00
3070:  ADDWFC x38,W
3072:  MOVWF  FEA
3074:  CLRF   FEC
3076:  MOVF   FED,F
3078:  MOVLW  24
307A:  MOVWF  FEF
....................  
....................    /* 
....................    debug_tcp("\r\nTCP IN <= SP:%LX DP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X\r\n", 
....................          h->SourcePort, 
....................          h->DestPort, 
....................          h->SeqNumber, 
....................          h->AckNumber, 
....................          len, 
....................          h->Flags 
....................    ); 
....................    */ 
....................  
....................    // Reset FSM, if RST is received. 
....................    if (h->Flags.bits.flagRST) { 
307C:  MOVLW  0D
307E:  ADDWF  x23,W
3080:  MOVWF  FE9
3082:  MOVLW  00
3084:  ADDWFC x24,W
3086:  MOVWF  FEA
3088:  BTFSS  FEF.2
308A:  BRA    30C8
....................       MACDiscardRx(); 
308C:  MOVLB  0
308E:  CALL   1138
....................       ps->smState = ps->Flags.bServer ? TCP_LISTEN : TCP_SYN_SENT; 
3092:  MOVLB  2
3094:  MOVFF  237,01
3098:  MOVFF  238,03
309C:  MOVFF  237,23E
30A0:  MOVFF  238,23F
30A4:  MOVLW  23
30A6:  ADDWF  x37,W
30A8:  MOVWF  FE9
30AA:  MOVLW  00
30AC:  ADDWFC x38,W
30AE:  MOVWF  FEA
30B0:  BTFSS  FEF.0
30B2:  BRA    30B8
30B4:  MOVLW  00
30B6:  BRA    30BA
30B8:  MOVLW  01
30BA:  MOVFF  23F,FEA
30BE:  MOVFF  23E,FE9
30C2:  MOVWF  FEF
....................       return; 
30C4:  GOTO   3AFE
....................    } 
....................  
....................    seq = ps->SND_SEQ; 
30C8:  MOVLW  16
30CA:  ADDWF  x37,W
30CC:  MOVWF  FE9
30CE:  MOVLW  00
30D0:  ADDWFC x38,W
30D2:  MOVWF  FEA
30D4:  MOVFF  FEF,00
30D8:  MOVFF  FEC,01
30DC:  MOVFF  FEC,02
30E0:  MOVFF  FEC,03
30E4:  MOVFF  03,22E
30E8:  MOVFF  02,22D
30EC:  MOVFF  01,22C
30F0:  MOVFF  00,22B
....................  
....................    temp = (signed int32)h->Window - ((signed int32)seq - (signed int32)h->AckNumber) - (signed int32)ps->TxCount; 
30F4:  MOVLW  0E
30F6:  ADDWF  x23,W
30F8:  MOVWF  FE9
30FA:  MOVLW  00
30FC:  ADDWFC x24,W
30FE:  MOVWF  FEA
3100:  MOVFF  FEC,03
3104:  MOVF   FED,F
3106:  MOVFF  FEF,23E
310A:  MOVFF  03,23F
310E:  CLRF   x40
3110:  CLRF   x41
3112:  MOVLW  08
3114:  ADDWF  x23,W
3116:  MOVWF  FE9
3118:  MOVLW  00
311A:  ADDWFC x24,W
311C:  MOVWF  FEA
311E:  MOVFF  FEF,00
3122:  MOVFF  FEC,01
3126:  MOVFF  FEC,02
312A:  MOVFF  FEC,03
312E:  MOVF   00,W
3130:  SUBWF  x2B,W
3132:  MOVWF  00
3134:  MOVF   01,W
3136:  SUBWFB x2C,W
3138:  MOVWF  01
313A:  MOVF   02,W
313C:  SUBWFB x2D,W
313E:  MOVWF  02
3140:  MOVF   03,W
3142:  SUBWFB x2E,W
3144:  MOVWF  03
3146:  MOVF   00,W
3148:  SUBWF  x3E,F
314A:  MOVF   01,W
314C:  SUBWFB x3F,F
314E:  MOVF   02,W
3150:  SUBWFB x40,F
3152:  MOVF   03,W
3154:  SUBWFB x41,F
3156:  MOVLW  10
3158:  ADDWF  x37,W
315A:  MOVWF  FE9
315C:  MOVLW  00
315E:  ADDWFC x38,W
3160:  MOVWF  FEA
3162:  MOVFF  FEC,03
3166:  MOVF   FED,F
3168:  MOVFF  FEF,00
316C:  MOVFF  03,01
3170:  CLRF   02
3172:  CLRF   03
3174:  MOVF   00,W
3176:  SUBWF  x3E,W
3178:  MOVWF  x3A
317A:  MOVF   01,W
317C:  SUBWFB x3F,W
317E:  MOVWF  x3B
3180:  MOVF   02,W
3182:  SUBWFB x40,W
3184:  MOVWF  x3C
3186:  MOVF   03,W
3188:  SUBWFB x41,W
318A:  MOVWF  x3D
....................    if (temp < 0) { 
318C:  BTFSC  x3D.7
318E:  BRA    3192
3190:  BRA    31A6
....................       ps->RemoteWindow = 0; 
3192:  MOVLW  14
3194:  ADDWF  x37,W
3196:  MOVWF  FE9
3198:  MOVLW  00
319A:  ADDWFC x38,W
319C:  MOVWF  FEA
319E:  CLRF   FEC
31A0:  MOVF   FED,F
31A2:  CLRF   FEF
....................       /* 
....................       debug_tcp("\r\nRW1 => %LX, res=%LX W=%LX S=%LX A=%LX C=%LX\r\n", 
....................             ps->RemoteWindow, 
....................             temp, 
....................             h->Window, 
....................             seq, 
....................             h->AckNumber, 
....................             ps->TxCount 
....................       ); 
....................       */ 
....................    } 
....................    else { 
31A4:  BRA    31BA
....................       ps->RemoteWindow = ack; 
31A6:  MOVLW  14
31A8:  ADDWF  x37,W
31AA:  MOVWF  FE9
31AC:  MOVLW  00
31AE:  ADDWFC x38,W
31B0:  MOVWF  FEA
31B2:  MOVFF  227,FEF
31B6:  MOVFF  228,FEC
....................       //debug_tcp("\r\nRW2 => %LX\r\n", ps->RemoteWindow); 
....................    } 
....................  
....................    // Handle TCP_SYN_SENT state 
....................    // The TCP_SYN_SENT state occurs when an application 
....................    // calls TCPConnect().  After an initial SYN is sent, 
....................    // we expect a SYN + ACK before establishing the 
....................    // connection. 
....................    if (ps->smState == TCP_SYN_SENT) { 
31BA:  MOVFF  237,FE9
31BE:  MOVFF  238,FEA
31C2:  DECFSZ FEF,W
31C4:  BRA    3342
....................       // Check if this is a SYN packet.  Unsynchronized, we cannot 
....................       // handle any other packet types. 
....................       if (!h->Flags.bits.flagSYN) { 
31C6:  MOVLW  0D
31C8:  ADDWF  x23,W
31CA:  MOVWF  FE9
31CC:  MOVLW  00
31CE:  ADDWFC x24,W
31D0:  MOVWF  FEA
31D2:  BTFSC  FEF.1
31D4:  BRA    31FA
....................          MACDiscardRx(); 
31D6:  MOVLB  0
31D8:  CALL   1138
....................  
....................          // Send out a RESET if the remote node thinks a connection is already established 
....................          if (h->Flags.bits.flagACK) { 
31DC:  MOVLW  0D
31DE:  MOVLB  2
31E0:  ADDWF  x23,W
31E2:  MOVWF  FE9
31E4:  MOVLW  00
31E6:  ADDWFC x24,W
31E8:  MOVWF  FEA
31EA:  BTFSS  FEF.4
31EC:  BRA    31F6
....................             flags = RST; 
31EE:  MOVLW  04
31F0:  MOVWF  x39
....................             goto SendTCPControlPacket; 
31F2:  GOTO   3A86
....................          } 
....................  
....................          return; 
31F6:  GOTO   3AFE
....................       } 
....................  
....................       // We now have a sequence number for the remote node 
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
31FA:  MOVLW  1A
31FC:  ADDWF  x37,W
31FE:  MOVWF  01
3200:  MOVLW  00
3202:  ADDWFC x38,W
3204:  MOVFF  01,23E
3208:  MOVWF  x3F
320A:  MOVLW  04
320C:  ADDWF  x23,W
320E:  MOVWF  FE9
3210:  MOVLW  00
3212:  ADDWFC x24,W
3214:  MOVWF  FEA
3216:  MOVFF  FEF,240
321A:  MOVFF  FEC,241
321E:  MOVFF  FEC,242
3222:  MOVFF  FEC,243
3226:  MOVF   x25,W
3228:  ADDWF  x40,F
322A:  MOVF   x26,W
322C:  ADDWFC x41,F
322E:  MOVLW  00
3230:  ADDWFC x42,F
3232:  ADDWFC x43,F
3234:  MOVLW  01
3236:  ADDWF  x40,W
3238:  MOVWF  00
323A:  MOVLW  00
323C:  ADDWFC x41,W
323E:  MOVWF  01
3240:  MOVLW  00
3242:  ADDWFC x42,W
3244:  MOVWF  02
3246:  MOVLW  00
3248:  ADDWFC x43,W
324A:  MOVFF  23F,FEA
324E:  MOVFF  23E,FE9
3252:  MOVFF  00,FEF
3256:  MOVFF  01,FEC
325A:  MOVFF  02,FEC
325E:  MOVWF  FEC
....................       ack = ps->SND_ACK; 
3260:  MOVLW  1A
3262:  ADDWF  x37,W
3264:  MOVWF  FE9
3266:  MOVLW  00
3268:  ADDWFC x38,W
326A:  MOVWF  FEA
326C:  MOVFF  FEF,00
3270:  MOVFF  FEC,01
3274:  MOVFF  FEC,02
3278:  MOVFF  FEC,03
327C:  MOVFF  03,22A
3280:  MOVFF  02,229
3284:  MOVFF  01,228
3288:  MOVFF  00,227
....................  
....................       // If there is no ACK, we must go to TCP_SYN_RECEIVED.  With an ACK, 
....................       // we can establish the connection now. 
....................       if (!h->Flags.bits.flagACK) { 
328C:  MOVLW  0D
328E:  ADDWF  x23,W
3290:  MOVWF  FE9
3292:  MOVLW  00
3294:  ADDWFC x24,W
3296:  MOVWF  FEA
3298:  BTFSC  FEF.4
329A:  BRA    32B8
....................          ps->smState = TCP_SYN_RECEIVED; 
329C:  MOVFF  237,FE9
32A0:  MOVFF  238,FEA
32A4:  MOVLW  02
32A6:  MOVWF  FEF
....................          MACDiscardRx(); 
32A8:  MOVLB  0
32AA:  CALL   1138
....................          // Send out a SYN+ACK for simultaneous connection open 
....................          flags = SYN | ACK; 
32AE:  MOVLW  12
32B0:  MOVLB  2
32B2:  MOVWF  x39
....................          goto SendTCPControlPacket; 
32B4:  GOTO   3A86
....................       } 
....................  
....................       // We received SYN+ACK, establish the connection now 
....................       ps->smState = TCP_ESTABLISHED; 
32B8:  MOVFF  237,FE9
32BC:  MOVFF  238,FEA
32C0:  MOVLW  03
32C2:  MOVWF  FEF
....................       // Send out an ACK 
....................       flags = ACK; 
32C4:  MOVLW  10
32C6:  MOVWF  x39
....................  
....................       ps->RemoteWindow = h->Window; 
32C8:  MOVLW  14
32CA:  ADDWF  x37,W
32CC:  MOVWF  01
32CE:  MOVLW  00
32D0:  ADDWFC x38,W
32D2:  MOVWF  03
32D4:  MOVWF  x3F
32D6:  MOVLW  0E
32D8:  ADDWF  x23,W
32DA:  MOVWF  FE9
32DC:  MOVLW  00
32DE:  ADDWFC x24,W
32E0:  MOVWF  FEA
32E2:  MOVFF  FEC,03
32E6:  MOVF   FED,F
32E8:  MOVFF  FEF,240
32EC:  MOVFF  23F,FEA
32F0:  MOVFF  01,FE9
32F4:  MOVFF  03,FEC
32F8:  MOVF   FED,F
32FA:  MOVFF  240,FEF
....................       //debug_tcp("\r\nRW3 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // Check for application data and make it 
....................       // available, if present 
....................       if (len) { 
32FE:  MOVF   x25,W
3300:  IORWF  x26,W
3302:  BZ    3338
....................          ps->Flags.bIsGetReady = TRUE; 
3304:  MOVLW  23
3306:  ADDWF  x37,W
3308:  MOVWF  FE9
330A:  MOVLW  00
330C:  ADDWFC x38,W
330E:  MOVWF  FEA
3310:  BSF    FEF.3
....................          ps->RxCount = len; 
3312:  MOVLW  12
3314:  ADDWF  x37,W
3316:  MOVWF  FE9
3318:  MOVLW  00
331A:  ADDWFC x38,W
331C:  MOVWF  FEA
331E:  MOVFF  226,FEC
3322:  MOVF   FED,F
3324:  MOVFF  225,FEF
....................          ps->Flags.bFirstRead = TRUE; 
3328:  MOVLW  23
332A:  ADDWF  x37,W
332C:  MOVWF  FE9
332E:  MOVLW  00
3330:  ADDWFC x38,W
3332:  MOVWF  FEA
3334:  BSF    FEF.2
....................       } 
....................       else   // No application data in this packet 
3336:  BRA    3340
....................       { 
....................          MACDiscardRx(); 
3338:  MOVLB  0
333A:  CALL   1138
333E:  MOVLB  2
....................       } 
....................       goto SendTCPControlPacket; 
3340:  BRA    3A86
....................    } 
....................  
....................    // Handle TCP_LISTEN state 
....................    if (ps->smState == TCP_LISTEN) { 
3342:  MOVFF  237,FE9
3346:  MOVFF  238,FEA
334A:  MOVF   FEF,F
334C:  BTFSS  FD8.2
334E:  BRA    34E4
....................       MACDiscardRx(); 
3350:  MOVLB  0
3352:  CALL   1138
....................  
....................       // Send a RST if this isn't a SYN packet 
....................       if (!h->Flags.bits.flagSYN) { 
3356:  MOVLW  0D
3358:  MOVLB  2
335A:  ADDWF  x23,W
335C:  MOVWF  FE9
335E:  MOVLW  00
3360:  ADDWFC x24,W
3362:  MOVWF  FEA
3364:  BTFSC  FEF.1
3366:  BRA    336E
....................          flags = RST; 
3368:  MOVLW  04
336A:  MOVWF  x39
....................          goto SendTCPControlPacket; 
336C:  BRA    3A86
....................       } 
....................  
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
336E:  MOVLW  1A
3370:  ADDWF  x37,W
3372:  MOVWF  01
3374:  MOVLW  00
3376:  ADDWFC x38,W
3378:  MOVFF  01,23E
337C:  MOVWF  x3F
337E:  MOVLW  04
3380:  ADDWF  x23,W
3382:  MOVWF  FE9
3384:  MOVLW  00
3386:  ADDWFC x24,W
3388:  MOVWF  FEA
338A:  MOVFF  FEF,240
338E:  MOVFF  FEC,241
3392:  MOVFF  FEC,242
3396:  MOVFF  FEC,243
339A:  MOVF   x25,W
339C:  ADDWF  x40,F
339E:  MOVF   x26,W
33A0:  ADDWFC x41,F
33A2:  MOVLW  00
33A4:  ADDWFC x42,F
33A6:  ADDWFC x43,F
33A8:  MOVLW  01
33AA:  ADDWF  x40,W
33AC:  MOVWF  00
33AE:  MOVLW  00
33B0:  ADDWFC x41,W
33B2:  MOVWF  01
33B4:  MOVLW  00
33B6:  ADDWFC x42,W
33B8:  MOVWF  02
33BA:  MOVLW  00
33BC:  ADDWFC x43,W
33BE:  MOVFF  23F,FEA
33C2:  MOVFF  23E,FE9
33C6:  MOVFF  00,FEF
33CA:  MOVFF  01,FEC
33CE:  MOVFF  02,FEC
33D2:  MOVWF  FEC
....................       ps->RemoteWindow = h->Window; 
33D4:  MOVLW  14
33D6:  ADDWF  x37,W
33D8:  MOVWF  01
33DA:  MOVLW  00
33DC:  ADDWFC x38,W
33DE:  MOVWF  03
33E0:  MOVWF  x3F
33E2:  MOVLW  0E
33E4:  ADDWF  x23,W
33E6:  MOVWF  FE9
33E8:  MOVLW  00
33EA:  ADDWFC x24,W
33EC:  MOVWF  FEA
33EE:  MOVFF  FEC,03
33F2:  MOVF   FED,F
33F4:  MOVFF  FEF,240
33F8:  MOVFF  23F,FEA
33FC:  MOVFF  01,FE9
3400:  MOVFF  03,FEC
3404:  MOVF   FED,F
3406:  MOVFF  240,FEF
....................       //debug_tcp("\r\nRW4 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // This socket has received connection request (SYN). 
....................       // Remember calling node, assign next segment seq. number 
....................       // for this potential connection. 
....................       memcpy((void*) &ps->remote, (void*) remote, sizeof(*remote)); 
340A:  MOVLW  01
340C:  ADDWF  x37,W
340E:  MOVWF  01
3410:  MOVLW  00
3412:  ADDWFC x38,W
3414:  MOVWF  03
3416:  MOVFF  01,23E
341A:  MOVWF  x3F
341C:  MOVWF  FEA
341E:  MOVFF  01,FE9
3422:  MOVFF  222,FE2
3426:  MOVFF  221,FE1
342A:  MOVLW  0A
342C:  MOVWF  01
342E:  MOVFF  FE6,FEE
3432:  DECFSZ 01,F
3434:  BRA    342E
....................       ps->remotePort = h->SourcePort; 
3436:  MOVLW  0D
3438:  ADDWF  x37,W
343A:  MOVWF  01
343C:  MOVLW  00
343E:  ADDWFC x38,W
3440:  MOVFF  223,FE9
3444:  MOVFF  224,FEA
3448:  MOVFF  FEC,03
344C:  MOVF   FED,F
344E:  MOVFF  FEF,240
3452:  MOVWF  FEA
3454:  MOVFF  01,FE9
3458:  MOVFF  03,FEC
345C:  MOVF   FED,F
345E:  MOVFF  240,FEF
....................  
....................       // Grant connection request. 
....................       ps->smState = TCP_SYN_RECEIVED; 
3462:  MOVFF  237,FE9
3466:  MOVFF  238,FEA
346A:  MOVLW  02
346C:  MOVWF  FEF
....................       //seq = ps->SND_SEQ++;  //currently buggy in ccs 
....................       seq = ps->SND_SEQ; 
346E:  MOVLW  16
3470:  ADDWF  x37,W
3472:  MOVWF  FE9
3474:  MOVLW  00
3476:  ADDWFC x38,W
3478:  MOVWF  FEA
347A:  MOVFF  FEF,00
347E:  MOVFF  FEC,01
3482:  MOVFF  FEC,02
3486:  MOVFF  FEC,03
348A:  MOVFF  03,22E
348E:  MOVFF  02,22D
3492:  MOVFF  01,22C
3496:  MOVFF  00,22B
....................       ps->SND_SEQ++; 
349A:  MOVLW  16
349C:  ADDWF  x37,W
349E:  MOVWF  FE9
34A0:  MOVLW  00
34A2:  ADDWFC x38,W
34A4:  MOVWF  FEA
34A6:  MOVLW  01
34A8:  ADDWF  FEE,F
34AA:  MOVLW  00
34AC:  ADDWFC FEE,F
34AE:  ADDWFC FEE,F
34B0:  ADDWFC FED,F
....................       ack = ps->SND_ACK; 
34B2:  MOVLW  1A
34B4:  ADDWF  x37,W
34B6:  MOVWF  FE9
34B8:  MOVLW  00
34BA:  ADDWFC x38,W
34BC:  MOVWF  FEA
34BE:  MOVFF  FEF,00
34C2:  MOVFF  FEC,01
34C6:  MOVFF  FEC,02
34CA:  MOVFF  FEC,03
34CE:  MOVFF  03,22A
34D2:  MOVFF  02,229
34D6:  MOVFF  01,228
34DA:  MOVFF  00,227
....................       flags = SYN | ACK; 
34DE:  MOVLW  12
34E0:  MOVWF  x39
....................       goto SendTCPControlPacket; 
34E2:  BRA    3A86
....................    } 
....................  
....................    // Remember current seq and ack for our connection so that if 
....................    // we have to silently discard this packet, we can go back to 
....................    // previous ack and seq numbers. 
....................    prevAck = ps->SND_ACK; 
34E4:  MOVLW  1A
34E6:  ADDWF  x37,W
34E8:  MOVWF  FE9
34EA:  MOVLW  00
34EC:  ADDWFC x38,W
34EE:  MOVWF  FEA
34F0:  MOVFF  FEF,00
34F4:  MOVFF  FEC,01
34F8:  MOVFF  FEC,02
34FC:  MOVFF  FEC,03
3500:  MOVFF  03,232
3504:  MOVFF  02,231
3508:  MOVFF  01,230
350C:  MOVFF  00,22F
....................    prevSeq = ps->SND_SEQ; 
3510:  MOVLW  16
3512:  ADDWF  x37,W
3514:  MOVWF  FE9
3516:  MOVLW  00
3518:  ADDWFC x38,W
351A:  MOVWF  FEA
351C:  MOVFF  FEF,00
3520:  MOVFF  FEC,01
3524:  MOVFF  FEC,02
3528:  MOVFF  FEC,03
352C:  MOVFF  03,236
3530:  MOVFF  02,235
3534:  MOVFF  01,234
3538:  MOVFF  00,233
....................  
....................    ack = h->SeqNumber; 
353C:  MOVLW  04
353E:  ADDWF  x23,W
3540:  MOVWF  FE9
3542:  MOVLW  00
3544:  ADDWFC x24,W
3546:  MOVWF  FEA
3548:  MOVFF  FEF,00
354C:  MOVFF  FEC,01
3550:  MOVFF  FEC,02
3554:  MOVFF  FEC,03
3558:  MOVFF  03,22A
355C:  MOVFF  02,229
3560:  MOVFF  01,228
3564:  MOVFF  00,227
....................    ack += (DWORD) len; 
3568:  CLRF   02
356A:  CLRF   03
356C:  MOVF   x25,W
356E:  ADDWF  x27,F
3570:  MOVF   x26,W
3572:  ADDWFC x28,F
3574:  MOVF   02,W
3576:  ADDWFC x29,F
3578:  MOVF   03,W
357A:  ADDWFC x2A,F
....................    seq = ps->SND_SEQ; 
357C:  MOVLW  16
357E:  ADDWF  x37,W
3580:  MOVWF  FE9
3582:  MOVLW  00
3584:  ADDWFC x38,W
3586:  MOVWF  FEA
3588:  MOVFF  FEF,00
358C:  MOVFF  FEC,01
3590:  MOVFF  FEC,02
3594:  MOVFF  FEC,03
3598:  MOVFF  03,22E
359C:  MOVFF  02,22D
35A0:  MOVFF  01,22C
35A4:  MOVFF  00,22B
....................  
....................    // State is something other than TCP_LISTEN, handle it. 
....................    { 
....................       // Check to see if the incomming sequence number is what 
....................       // we expect (last transmitted ACK value).  Throw this packet 
....................       // away if it is wrong. 
....................       if (h->SeqNumber == prevAck) { 
35A8:  MOVLW  04
35AA:  ADDWF  x23,W
35AC:  MOVWF  FE9
35AE:  MOVLW  00
35B0:  ADDWFC x24,W
35B2:  MOVWF  FEA
35B4:  MOVFF  FEF,23E
35B8:  MOVFF  FEC,23F
35BC:  MOVFF  FEC,240
35C0:  MOVFF  FEC,241
35C4:  MOVF   x2F,W
35C6:  SUBWF  x3E,W
35C8:  BTFSS  FD8.2
35CA:  BRA    3A6A
35CC:  MOVF   x30,W
35CE:  SUBWF  x3F,W
35D0:  BTFSS  FD8.2
35D2:  BRA    3A6A
35D4:  MOVF   x31,W
35D6:  SUBWF  x40,W
35D8:  BTFSS  FD8.2
35DA:  BRA    3A6A
35DC:  MOVF   x32,W
35DE:  SUBWF  x41,W
35E0:  BTFSS  FD8.2
35E2:  BRA    3A6A
....................          // After receiving a SYNchronization request, we expect an 
....................          // ACK to our transmitted SYN 
....................          if (ps->smState == TCP_SYN_RECEIVED) { 
35E4:  MOVFF  237,FE9
35E8:  MOVFF  238,FEA
35EC:  MOVF   FEF,W
35EE:  SUBLW  02
35F0:  BNZ   3678
....................             if (h->Flags.bits.flagACK) { 
35F2:  MOVLW  0D
35F4:  ADDWF  x23,W
35F6:  MOVWF  FE9
35F8:  MOVLW  00
35FA:  ADDWFC x24,W
35FC:  MOVWF  FEA
35FE:  BTFSS  FEF.4
3600:  BRA    366E
....................                // ACK received as expected, this connection is 
....................                // now established 
....................                ps->SND_ACK = ack; 
3602:  MOVLW  1A
3604:  ADDWF  x37,W
3606:  MOVWF  FE9
3608:  MOVLW  00
360A:  ADDWFC x38,W
360C:  MOVWF  FEA
360E:  MOVFF  227,FEF
3612:  MOVFF  228,FEC
3616:  MOVFF  229,FEC
361A:  MOVFF  22A,FEC
....................                ps->smState = TCP_ESTABLISHED; 
361E:  MOVFF  237,FE9
3622:  MOVFF  238,FEA
3626:  MOVLW  03
3628:  MOVWF  FEF
....................  
....................                // Check if this first packet has application data 
....................                // in it.  Make it available if so. 
....................                if (len) { 
362A:  MOVF   x25,W
362C:  IORWF  x26,W
362E:  BZ    3664
....................                   ps->Flags.bIsGetReady = TRUE; 
3630:  MOVLW  23
3632:  ADDWF  x37,W
3634:  MOVWF  FE9
3636:  MOVLW  00
3638:  ADDWFC x38,W
363A:  MOVWF  FEA
363C:  BSF    FEF.3
....................                   ps->RxCount = len; 
363E:  MOVLW  12
3640:  ADDWF  x37,W
3642:  MOVWF  FE9
3644:  MOVLW  00
3646:  ADDWFC x38,W
3648:  MOVWF  FEA
364A:  MOVFF  226,FEC
364E:  MOVF   FED,F
3650:  MOVFF  225,FEF
....................                   ps->Flags.bFirstRead = TRUE; 
3654:  MOVLW  23
3656:  ADDWF  x37,W
3658:  MOVWF  FE9
365A:  MOVLW  00
365C:  ADDWFC x38,W
365E:  MOVWF  FEA
3660:  BSF    FEF.2
....................                } 
....................                else 
3662:  BRA    366C
....................                   MACDiscardRx(); 
3664:  MOVLB  0
3666:  CALL   1138
366A:  MOVLB  2
....................             } 
....................             else   // No ACK to our SYN 
366C:  BRA    3676
....................             { 
....................                MACDiscardRx(); 
366E:  MOVLB  0
3670:  CALL   1138
3674:  MOVLB  2
....................             } 
....................          } 
....................          // Connection is established, closing, or otherwise 
....................          else { 
3676:  BRA    3A68
....................  
....................             // Save the seq+len value of the packet for our future 
....................             // ACK transmission, and so out of sequence packets 
....................             // can be detected in the future. 
....................             ps->SND_ACK = ack; 
3678:  MOVLW  1A
367A:  ADDWF  x37,W
367C:  MOVWF  FE9
367E:  MOVLW  00
3680:  ADDWFC x38,W
3682:  MOVWF  FEA
3684:  MOVFF  227,FEF
3688:  MOVFF  228,FEC
368C:  MOVFF  229,FEC
3690:  MOVFF  22A,FEC
....................  
....................             // Handle packets received while connection established. 
....................             if (ps->smState == TCP_ESTABLISHED) { 
3694:  MOVFF  237,FE9
3698:  MOVFF  238,FEA
369C:  MOVF   FEF,W
369E:  SUBLW  03
36A0:  BTFSS  FD8.2
36A2:  BRA    387A
....................                // If this packet has the ACK set, mark all 
....................                // previous TX packets as no longer needed for 
....................                // possible retransmission. 
....................                // TODO: Make this more sophisticated so that partial ACKs due to fragmentation are handled correctly.  i.e. Keep a real output stream buffer with slidable window capability. 
....................                if (h->Flags.bits.flagACK && !ps->Flags.bIsPutReady) { 
36A4:  MOVLW  0D
36A6:  ADDWF  x23,W
36A8:  MOVWF  FE9
36AA:  MOVLW  00
36AC:  ADDWFC x24,W
36AE:  MOVWF  FEA
36B0:  BTFSS  FEF.4
36B2:  BRA    371C
36B4:  MOVLW  23
36B6:  ADDWF  x37,W
36B8:  MOVWF  FE9
36BA:  MOVLW  00
36BC:  ADDWFC x38,W
36BE:  MOVWF  FEA
36C0:  BTFSC  FEF.1
36C2:  BRA    371C
....................                   if (ps->TxBuffer != INVALID_BUFFER) { 
36C4:  MOVLW  0F
36C6:  ADDWF  x37,W
36C8:  MOVWF  FE9
36CA:  MOVLW  00
36CC:  ADDWFC x38,W
36CE:  MOVWF  FEA
36D0:  INCFSZ FEF,W
36D2:  BRA    36D6
36D4:  BRA    371C
....................                      MACDiscardTx(ps->TxBuffer); 
36D6:  MOVLW  0F
36D8:  ADDWF  x37,W
36DA:  MOVWF  FE9
36DC:  MOVLW  00
36DE:  ADDWFC x38,W
36E0:  MOVWF  FEA
36E2:  MOVFF  FEF,23E
36E6:  CLRF   19
36E8:  BTFSC  FF2.7
36EA:  BSF    19.7
36EC:  BCF    FF2.7
36EE:  MOVFF  23E,2AC
36F2:  MOVLB  0
36F4:  CALL   0004
36F8:  BTFSC  19.7
36FA:  BSF    FF2.7
....................                      ps->TxBuffer = INVALID_BUFFER; 
36FC:  MOVLW  0F
36FE:  MOVLB  2
3700:  ADDWF  x37,W
3702:  MOVWF  FE9
3704:  MOVLW  00
3706:  ADDWFC x38,W
3708:  MOVWF  FEA
370A:  MOVLW  FF
370C:  MOVWF  FEF
....................                      ps->Flags.bIsPutReady = TRUE; 
370E:  MOVLW  23
3710:  ADDWF  x37,W
3712:  MOVWF  FE9
3714:  MOVLW  00
3716:  ADDWFC x38,W
3718:  MOVWF  FEA
371A:  BSF    FEF.1
....................                   } 
....................                } 
....................  
....................                // Check if the remote node is closing the connection 
....................                if (h->Flags.bits.flagFIN) { 
371C:  MOVLW  0D
371E:  ADDWF  x23,W
3720:  MOVWF  FE9
3722:  MOVLW  00
3724:  ADDWFC x24,W
3726:  MOVWF  FEA
3728:  BTFSS  FEF.0
372A:  BRA    37E2
....................                   //DebugPrint("|"); 
....................                   flags = FIN | ACK; 
372C:  MOVLW  11
372E:  MOVWF  x39
....................                   //seq = ps->SND_SEQ++; //currently buggy in CCS 
....................                   seq = ps->SND_SEQ; 
3730:  MOVLW  16
3732:  ADDWF  x37,W
3734:  MOVWF  FE9
3736:  MOVLW  00
3738:  ADDWFC x38,W
373A:  MOVWF  FEA
373C:  MOVFF  FEF,00
3740:  MOVFF  FEC,01
3744:  MOVFF  FEC,02
3748:  MOVFF  FEC,03
374C:  MOVFF  03,22E
3750:  MOVFF  02,22D
3754:  MOVFF  01,22C
3758:  MOVFF  00,22B
....................                   ps->SND_SEQ++; 
375C:  MOVLW  16
375E:  ADDWF  x37,W
3760:  MOVWF  FE9
3762:  MOVLW  00
3764:  ADDWFC x38,W
3766:  MOVWF  FEA
3768:  MOVLW  01
376A:  ADDWF  FEE,F
376C:  MOVLW  00
376E:  ADDWFC FEE,F
3770:  ADDWFC FEE,F
3772:  ADDWFC FED,F
....................                   //ack = ++ps->SND_ACK;   /////TODO HUGE BUG HERE? 
....................                   ps->SND_ACK += 1; 
3774:  MOVLW  1A
3776:  ADDWF  x37,W
3778:  MOVWF  FE9
377A:  MOVLW  00
377C:  ADDWFC x38,W
377E:  MOVWF  FEA
3780:  MOVLW  01
3782:  ADDWF  FEF,W
3784:  MOVWF  00
3786:  MOVLW  00
3788:  ADDWFC FEC,W
378A:  MOVWF  01
378C:  MOVLW  00
378E:  ADDWFC FEC,W
3790:  MOVWF  02
3792:  MOVLW  00
3794:  ADDWFC FEC,W
3796:  MOVF   FED,F
3798:  MOVF   FED,F
379A:  MOVF   FED,F
379C:  MOVFF  00,FEF
37A0:  MOVFF  01,FEC
37A4:  MOVFF  02,FEC
37A8:  MOVWF  FEC
....................                   ack = ps->SND_ACK; 
37AA:  MOVLW  1A
37AC:  ADDWF  x37,W
37AE:  MOVWF  FE9
37B0:  MOVLW  00
37B2:  ADDWFC x38,W
37B4:  MOVWF  FEA
37B6:  MOVFF  FEF,00
37BA:  MOVFF  FEC,01
37BE:  MOVFF  FEC,02
37C2:  MOVFF  FEC,03
37C6:  MOVFF  03,22A
37CA:  MOVFF  02,229
37CE:  MOVFF  01,228
37D2:  MOVFF  00,227
....................                   ps->smState = TCP_LAST_ACK; 
37D6:  MOVFF  237,FE9
37DA:  MOVFF  238,FEA
37DE:  MOVLW  09
37E0:  MOVWF  FEF
....................                } 
....................  
....................                // Check if there is any application data in 
....................                // this packet. 
....................                if (len) { 
37E2:  MOVF   x25,W
37E4:  IORWF  x26,W
37E6:  BZ    3870
....................                   // There is data.  Make it available if we 
....................                   // don't already have data available. 
....................                   if (!ps->Flags.bIsGetReady) { 
37E8:  MOVLW  23
37EA:  ADDWF  x37,W
37EC:  MOVWF  FE9
37EE:  MOVLW  00
37F0:  ADDWFC x38,W
37F2:  MOVWF  FEA
37F4:  BTFSC  FEF.3
37F6:  BRA    382E
....................                      ps->Flags.bIsGetReady = TRUE; 
37F8:  MOVLW  23
37FA:  ADDWF  x37,W
37FC:  MOVWF  FE9
37FE:  MOVLW  00
3800:  ADDWFC x38,W
3802:  MOVWF  FEA
3804:  BSF    FEF.3
....................                      ps->RxCount = len; 
3806:  MOVLW  12
3808:  ADDWF  x37,W
380A:  MOVWF  FE9
380C:  MOVLW  00
380E:  ADDWFC x38,W
3810:  MOVWF  FEA
3812:  MOVFF  226,FEC
3816:  MOVF   FED,F
3818:  MOVFF  225,FEF
....................                      ps->Flags.bFirstRead = TRUE; 
381C:  MOVLW  23
381E:  ADDWF  x37,W
3820:  MOVWF  FE9
3822:  MOVLW  00
3824:  ADDWFC x38,W
3826:  MOVWF  FEA
3828:  BSF    FEF.2
....................  
....................                      // 4/1/02 
....................                      flags |= ACK; 
382A:  BSF    x39.4
....................                   } 
....................                   // There is data, but we cannot handle it at this time. 
....................                   else { 
382C:  BRA    386E
....................                      //DebugPrint("D"); 
....................                      // Since we cannot accept this packet, 
....................                      // restore to previous seq and ack. 
....................                      // and do not send anything back. 
....................                      // Host has to resend this packet when 
....................                      // we are ready. 
....................                      ps->SND_SEQ = prevSeq; 
382E:  MOVLW  16
3830:  ADDWF  x37,W
3832:  MOVWF  FE9
3834:  MOVLW  00
3836:  ADDWFC x38,W
3838:  MOVWF  FEA
383A:  MOVFF  233,FEF
383E:  MOVFF  234,FEC
3842:  MOVFF  235,FEC
3846:  MOVFF  236,FEC
....................                      ps->SND_ACK = prevAck; 
384A:  MOVLW  1A
384C:  ADDWF  x37,W
384E:  MOVWF  FE9
3850:  MOVLW  00
3852:  ADDWFC x38,W
3854:  MOVWF  FEA
3856:  MOVFF  22F,FEF
385A:  MOVFF  230,FEC
385E:  MOVFF  231,FEC
3862:  MOVFF  232,FEC
....................  
....................                      MACDiscardRx(); 
3866:  MOVLB  0
3868:  CALL   1138
386C:  MOVLB  2
....................                   } 
....................                } 
....................                // There is no data in this packet, and thus it 
....................                // can be thrown away. 
....................                else { 
386E:  BRA    3878
....................                   MACDiscardRx(); 
3870:  MOVLB  0
3872:  CALL   1138
3876:  MOVLB  2
....................                } 
....................             } 
....................             // Connection is not established; check if we've sent 
....................             // a FIN and expect our last ACK 
....................             else if (ps->smState == TCP_LAST_ACK) { 
3878:  BRA    3A68
387A:  MOVFF  237,FE9
387E:  MOVFF  238,FEA
3882:  MOVF   FEF,W
3884:  SUBLW  09
3886:  BNZ   38B2
....................                MACDiscardRx(); 
3888:  MOVLB  0
388A:  CALL   1138
....................  
....................                if (h->Flags.bits.flagACK) { 
388E:  MOVLW  0D
3890:  MOVLB  2
3892:  ADDWF  x23,W
3894:  MOVWF  FE9
3896:  MOVLW  00
3898:  ADDWFC x24,W
389A:  MOVWF  FEA
389C:  BTFSS  FEF.4
389E:  BRA    38B0
....................                   CloseSocket(ps); 
38A0:  MOVFF  238,23F
38A4:  MOVFF  237,23E
38A8:  MOVLB  0
38AA:  CALL   28BE
38AE:  MOVLB  2
....................                } 
....................             } 
....................             else if (ps->smState == TCP_FIN_WAIT_1) { 
38B0:  BRA    3A68
38B2:  MOVFF  237,FE9
38B6:  MOVFF  238,FEA
38BA:  MOVF   FEF,W
38BC:  SUBLW  04
38BE:  BNZ   3994
....................                MACDiscardRx(); 
38C0:  MOVLB  0
38C2:  CALL   1138
....................  
....................                if (h->Flags.bits.flagFIN) { 
38C6:  MOVLW  0D
38C8:  MOVLB  2
38CA:  ADDWF  x23,W
38CC:  MOVWF  FE9
38CE:  MOVLW  00
38D0:  ADDWFC x24,W
38D2:  MOVWF  FEA
38D4:  BTFSS  FEF.0
38D6:  BRA    3972
....................                   flags = ACK; 
38D8:  MOVLW  10
38DA:  MOVWF  x39
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................                   ps->SND_ACK += 1; 
38DC:  MOVLW  1A
38DE:  ADDWF  x37,W
38E0:  MOVWF  FE9
38E2:  MOVLW  00
38E4:  ADDWFC x38,W
38E6:  MOVWF  FEA
38E8:  MOVLW  01
38EA:  ADDWF  FEF,W
38EC:  MOVWF  00
38EE:  MOVLW  00
38F0:  ADDWFC FEC,W
38F2:  MOVWF  01
38F4:  MOVLW  00
38F6:  ADDWFC FEC,W
38F8:  MOVWF  02
38FA:  MOVLW  00
38FC:  ADDWFC FEC,W
38FE:  MOVF   FED,F
3900:  MOVF   FED,F
3902:  MOVF   FED,F
3904:  MOVFF  00,FEF
3908:  MOVFF  01,FEC
390C:  MOVFF  02,FEC
3910:  MOVWF  FEC
....................                   ack = ps->SND_ACK; 
3912:  MOVLW  1A
3914:  ADDWF  x37,W
3916:  MOVWF  FE9
3918:  MOVLW  00
391A:  ADDWFC x38,W
391C:  MOVWF  FEA
391E:  MOVFF  FEF,00
3922:  MOVFF  FEC,01
3926:  MOVFF  FEC,02
392A:  MOVFF  FEC,03
392E:  MOVFF  03,22A
3932:  MOVFF  02,229
3936:  MOVFF  01,228
393A:  MOVFF  00,227
....................                   if (h->Flags.bits.flagACK) { 
393E:  MOVLW  0D
3940:  ADDWF  x23,W
3942:  MOVWF  FE9
3944:  MOVLW  00
3946:  ADDWFC x24,W
3948:  MOVWF  FEA
394A:  BTFSS  FEF.4
394C:  BRA    3960
....................                      CloseSocket(ps); 
394E:  MOVFF  238,23F
3952:  MOVFF  237,23E
3956:  MOVLB  0
3958:  CALL   28BE
....................                   } 
....................                   else { 
395C:  BRA    396E
395E:  MOVLB  2
....................                      ps->smState = TCP_CLOSING; 
3960:  MOVFF  237,FE9
3964:  MOVFF  238,FEA
3968:  MOVLW  06
396A:  MOVWF  FEF
396C:  MOVLB  0
....................                   } 
....................                } 
....................                else if (h->Flags.bits.flagACK) { 
396E:  BRA    3990
3970:  MOVLB  2
3972:  MOVLW  0D
3974:  ADDWF  x23,W
3976:  MOVWF  FE9
3978:  MOVLW  00
397A:  ADDWFC x24,W
397C:  MOVWF  FEA
397E:  BTFSS  FEF.4
3980:  BRA    398E
....................                   ps->smState = TCP_FIN_WAIT_2; 
3982:  MOVFF  237,FE9
3986:  MOVFF  238,FEA
398A:  MOVLW  05
398C:  MOVWF  FEF
398E:  MOVLB  0
....................                } 
....................             } 
....................             else if (ps->smState == TCP_FIN_WAIT_2) { 
3990:  BRA    3A66
3992:  MOVLB  2
3994:  MOVFF  237,FE9
3998:  MOVFF  238,FEA
399C:  MOVF   FEF,W
399E:  SUBLW  05
39A0:  BNZ   3A32
....................                MACDiscardRx(); 
39A2:  MOVLB  0
39A4:  CALL   1138
....................  
....................                if (h->Flags.bits.flagFIN) { 
39A8:  MOVLW  0D
39AA:  MOVLB  2
39AC:  ADDWF  x23,W
39AE:  MOVWF  FE9
39B0:  MOVLW  00
39B2:  ADDWFC x24,W
39B4:  MOVWF  FEA
39B6:  BTFSS  FEF.0
39B8:  BRA    3A30
....................                   flags = ACK; 
39BA:  MOVLW  10
39BC:  MOVWF  x39
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................                   ps->SND_ACK += 1; 
39BE:  MOVLW  1A
39C0:  ADDWF  x37,W
39C2:  MOVWF  FE9
39C4:  MOVLW  00
39C6:  ADDWFC x38,W
39C8:  MOVWF  FEA
39CA:  MOVLW  01
39CC:  ADDWF  FEF,W
39CE:  MOVWF  00
39D0:  MOVLW  00
39D2:  ADDWFC FEC,W
39D4:  MOVWF  01
39D6:  MOVLW  00
39D8:  ADDWFC FEC,W
39DA:  MOVWF  02
39DC:  MOVLW  00
39DE:  ADDWFC FEC,W
39E0:  MOVF   FED,F
39E2:  MOVF   FED,F
39E4:  MOVF   FED,F
39E6:  MOVFF  00,FEF
39EA:  MOVFF  01,FEC
39EE:  MOVFF  02,FEC
39F2:  MOVWF  FEC
....................                   ack = ps->SND_ACK; 
39F4:  MOVLW  1A
39F6:  ADDWF  x37,W
39F8:  MOVWF  FE9
39FA:  MOVLW  00
39FC:  ADDWFC x38,W
39FE:  MOVWF  FEA
3A00:  MOVFF  FEF,00
3A04:  MOVFF  FEC,01
3A08:  MOVFF  FEC,02
3A0C:  MOVFF  FEC,03
3A10:  MOVFF  03,22A
3A14:  MOVFF  02,229
3A18:  MOVFF  01,228
3A1C:  MOVFF  00,227
....................                   CloseSocket(ps); 
3A20:  MOVFF  238,23F
3A24:  MOVFF  237,23E
3A28:  MOVLB  0
3A2A:  CALL   28BE
3A2E:  MOVLB  2
....................                } 
....................             } 
....................             else if (ps->smState == TCP_CLOSING) { 
3A30:  BRA    3A68
3A32:  MOVFF  237,FE9
3A36:  MOVFF  238,FEA
3A3A:  MOVF   FEF,W
3A3C:  SUBLW  06
3A3E:  BNZ   3A68
....................                MACDiscardRx(); 
3A40:  MOVLB  0
3A42:  CALL   1138
....................  
....................                if (h->Flags.bits.flagACK) { 
3A46:  MOVLW  0D
3A48:  MOVLB  2
3A4A:  ADDWF  x23,W
3A4C:  MOVWF  FE9
3A4E:  MOVLW  00
3A50:  ADDWFC x24,W
3A52:  MOVWF  FEA
3A54:  BTFSS  FEF.4
3A56:  BRA    3A68
....................                   CloseSocket(ps); 
3A58:  MOVFF  238,23F
3A5C:  MOVFF  237,23E
3A60:  MOVLB  0
3A62:  CALL   28BE
3A66:  MOVLB  2
....................                } 
....................             } 
....................          } 
....................       } 
....................       // This packet's sequence number does not match what we were 
....................       // expecting (the last value we ACKed).  Throw this packet 
....................       // away.  This may happen if packets are delivered out of order. 
....................       // Not enough memory is available on our PIC or Ethernet 
....................       // controller to implement a robust stream reconstruction 
....................       // buffer.  As a result, the remote node will just have to 
....................       // retransmit its packets starting with the proper sequence number. 
....................       else { 
3A68:  BRA    3A86
....................          MACDiscardRx(); 
3A6A:  MOVLB  0
3A6C:  CALL   1138
....................  
....................          // Send a new ACK out in case if the previous one was lost 
....................          // (ACKs aren't ACKed).  This is required to prevent an 
....................          // unlikely but possible situation which would cause the 
....................          // connection to time out if the ACK was lost and the 
....................          // remote node keeps sending us older data than we are 
....................          // expecting. 
....................          flags = ACK; 
3A70:  MOVLW  10
3A72:  MOVLB  2
3A74:  MOVWF  x39
....................          ack = prevAck; 
3A76:  MOVFF  232,22A
3A7A:  MOVFF  231,229
3A7E:  MOVFF  230,228
3A82:  MOVFF  22F,227
....................       } 
....................    } 
....................  
....................    SendTCPControlPacket: if (flags) { 
3A86:  MOVF   x39,F
3A88:  BZ    3AFE
....................       SendTCP(remote, h->DestPort, h->SourcePort, seq, ack, flags); 
3A8A:  MOVLW  02
3A8C:  ADDWF  x23,W
3A8E:  MOVWF  FE9
3A90:  MOVLW  00
3A92:  ADDWFC x24,W
3A94:  MOVWF  FEA
3A96:  MOVFF  FEC,23F
3A9A:  MOVF   FED,F
3A9C:  MOVFF  FEF,23E
3AA0:  MOVFF  223,FE9
3AA4:  MOVFF  224,FEA
3AA8:  MOVFF  FEC,241
3AAC:  MOVF   FED,F
3AAE:  MOVFF  FEF,240
3AB2:  MOVFF  222,243
3AB6:  MOVFF  221,242
3ABA:  MOVFF  23F,245
3ABE:  MOVFF  23E,244
3AC2:  MOVFF  241,247
3AC6:  MOVFF  240,246
3ACA:  MOVFF  22E,24B
3ACE:  MOVFF  22D,24A
3AD2:  MOVFF  22C,249
3AD6:  MOVFF  22B,248
3ADA:  MOVFF  22A,24F
3ADE:  MOVFF  229,24E
3AE2:  MOVFF  228,24D
3AE6:  MOVFF  227,24C
3AEA:  MOVFF  239,250
3AEE:  MOVLW  FF
3AF0:  MOVWF  x51
3AF2:  CLRF   x53
3AF4:  CLRF   x52
3AF6:  MOVLB  0
3AF8:  CALL   2DE4
3AFC:  MOVLB  2
....................    } 
....................  
....................    /*if (debugLastState != ps->smState) 
....................     { 
....................     debug_tcp("\r\nHANDLE TCP SEG %U - ", s); 
....................     DebugTCPDisplayState(debugLastState); 
....................     debug_tcp(" -> "); 
....................     DebugTCPDisplayState(ps->smState); 
....................     }*/ 
.................... } 
3AFE:  MOVLB  0
3B00:  GOTO   3CB0 (RETURN)
....................  
.................... #endif 
....................  
.................... #if STACK_USE_ICMP 
.................... #include "tcpip/icmp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.C 
....................  * Dependencies:    ICMP.h 
....................  *                  string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/30/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/29/04 SwapICMPPacket() no longer static 
....................  * Howard Schlunder      9/9/04   Added ENC28J60 DMA checksum support 
....................  * Howard Schlunder      1/5/06   Increased DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/icmp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    07/13/06 Increased MAX_ICMP_DATA to 64 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ICMP_H 
.................... #define ICMP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // Windows ping uses 32 bytes, while MAC uses 56 bytes. 
.................... //#define MAX_ICMP_DATA       (32) 
.................... #define MAX_ICMP_DATA       (64) 
....................  
.................... #define MAX_ICMP_DATA_LEN   (MAX_ICMP_DATA) 
....................  
....................  
.................... typedef enum _ICMP_CODE 
.................... { 
....................     ICMP_ECHO_REPLY = 0, 
....................     ICMP_ECHO_REQUEST = 8 
.................... } ICMP_CODE, ICMP_REQUESTS; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPIsTxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is ready 
....................  *                  FALSE if transmit buffer is not ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define ICMPIsTxReady()     MACIsTxReady(TRUE) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... //#define debug_icmp 
.................... //#define debug_icmp   debug_printf 
.................... #define debug_icmp(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................  
.................... //#define MAX_ICMP_DATA       32 //moved to icmp.h 
....................  
.................... /* 
....................  * ICMP packet definition 
....................  */ 
.................... typedef struct _ICMP_PACKET 
.................... { 
....................     BYTE    Type; 
....................     BYTE    Code; 
....................     WORD    Checksum; 
....................     WORD    Identifier; 
....................     WORD    SequenceNumber; 
....................     BYTE    Data[MAX_ICMP_DATA]; 
.................... } ICMP_PACKET; 
.................... #define ICMP_HEADER_SIZE    (sizeof(ICMP_PACKET) - MAX_ICMP_DATA) 
....................  
.................... static void SwapICMPPacket(ICMP_PACKET* p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq) 
.................... { 
....................     ICMP_PACKET packet; 
....................     WORD CalcChecksum; 
....................     WORD ReceivedChecksum; 
.................... #if !defined(MCHP_MAC) 
....................     WORD checksums[2]; 
.................... #endif 
....................  
....................     debug_icmp(debug_putc, "\r\nICMP GET "); 
....................  
....................     // Obtain the ICMP Header 
....................     MACGetArray((BYTE*)&packet, ICMP_HEADER_SIZE); 
*
3DA2:  MOVLW  02
3DA4:  MOVLB  2
3DA6:  MOVWF  x4D
3DA8:  CLRF   x4C
3DAA:  MOVWF  x89
3DAC:  MOVFF  24C,288
3DB0:  CLRF   x8B
3DB2:  MOVLW  08
3DB4:  MOVWF  x8A
3DB6:  MOVLB  0
3DB8:  CALL   11D8
....................  
....................  
.................... #if defined(MCHP_MAC) 
....................    // Calculate the checksum using the Microchip MAC's DMA module 
....................    // The checksum data includes the precomputed checksum in the 
....................    // header, so a valid packet will always have a checksum of 
....................    // 0x0000 if the packet is not disturbed. 
....................    ReceivedChecksum = 0x0000; 
3DBC:  MOVLB  2
3DBE:  CLRF   x4B
3DC0:  CLRF   x4A
....................    CalcChecksum = MACCalcRxChecksum(0+sizeof(IP_HEADER), *len); 
3DC2:  MOVFF  1FB,03
3DC6:  MOVFF  1FA,FE9
3DCA:  MOVFF  1FB,FEA
3DCE:  MOVFF  FEF,24C
3DD2:  MOVLB  2
3DD4:  CLRF   x4E
3DD6:  MOVLW  14
3DD8:  MOVWF  x4D
3DDA:  CLRF   x50
3DDC:  MOVFF  24C,24F
3DE0:  MOVLB  0
3DE2:  CALL   1D76
3DE6:  MOVFF  02,249
3DEA:  MOVFF  01,248
.................... #endif 
....................  
....................    // Obtain the ICMP data payload 
....................     *len -= ICMP_HEADER_SIZE; 
3DEE:  MOVLB  1
3DF0:  MOVFF  1FA,FE9
3DF4:  MOVFF  1FB,FEA
3DF8:  MOVLW  08
3DFA:  SUBWF  FEF,W
3DFC:  MOVWF  FEF
....................     MACGetArray(data, *len); 
3DFE:  MOVFF  1FB,03
3E02:  MOVFF  1FA,FE9
3E06:  MOVFF  1FB,FEA
3E0A:  MOVFF  FEF,24C
3E0E:  MOVFF  1F9,289
3E12:  MOVFF  1F8,288
3E16:  MOVLB  2
3E18:  CLRF   x8B
3E1A:  MOVFF  24C,28A
3E1E:  MOVLB  0
3E20:  CALL   11D8
....................  
....................  
.................... #if !defined(MCHP_MAC) 
....................    // Calculte the checksum in local memory without hardware help 
....................     ReceivedChecksum = packet.Checksum; 
....................     packet.Checksum = 0; 
....................  
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&packet, ICMP_HEADER_SIZE); 
....................     checksums[1] = ~CalcIPChecksum(data, *len); 
....................  
....................     CalcChecksum = CalcIPChecksum((BYTE*)checksums, 2 * sizeof(WORD)); 
.................... #endif 
....................  
....................     SwapICMPPacket(&packet); 
3E24:  MOVLW  02
3E26:  MOVLB  2
3E28:  MOVWF  x4D
3E2A:  CLRF   x4C
3E2C:  MOVLB  0
3E2E:  RCALL  3CC2
....................  
....................     *code = packet.Type; 
3E30:  MOVLB  1
3E32:  MOVFF  1F6,FE9
3E36:  MOVFF  1F7,FEA
3E3A:  MOVFF  200,FEF
....................     *id = packet.Identifier; 
3E3E:  MOVFF  1FC,FE9
3E42:  MOVFF  1FD,FEA
3E46:  MOVFF  205,FEC
3E4A:  MOVF   FED,F
3E4C:  MOVFF  204,FEF
....................     *seq = packet.SequenceNumber; 
3E50:  MOVFF  1FE,FE9
3E54:  MOVFF  1FF,FEA
3E58:  MOVFF  207,FEC
3E5C:  MOVF   FED,F
3E5E:  MOVFF  206,FEF
....................  
....................     debug_icmp(debug_putc, "%U", CalcChecksum == ReceivedChecksum); 
....................  
....................     return ( CalcChecksum == ReceivedChecksum ); 
3E62:  MOVLB  2
3E64:  MOVF   x4A,W
3E66:  SUBWF  x48,W
3E68:  BNZ   3E70
3E6A:  MOVF   x4B,W
3E6C:  SUBWF  x49,W
3E6E:  BZ    3E74
3E70:  MOVLW  00
3E72:  BRA    3E76
3E74:  MOVLW  01
3E76:  MOVWF  01
.................... } 
3E78:  MOVLB  0
3E7A:  GOTO   45C0 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq) 
.................... { 
....................     ICMP_PACKET   packet; 
....................     WORD ICMPLen; 
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
3E7E:  MOVLW  01
3E80:  MOVLB  2
3E82:  MOVWF  x7A
3E84:  MOVLB  0
3E86:  CALL   159C
3E8A:  MOVFF  01,248
....................  
....................    // Abort if there is no where in the Ethernet controller to 
....................    // store this packet. 
....................    if(MyTxBuffer == INVALID_BUFFER) 
3E8E:  MOVLB  2
3E90:  INCFSZ x48,W
3E92:  BRA    3E96
....................       return; 
3E94:  BRA    3F94
....................  
....................    IPSetTxBuffer(MyTxBuffer, 0); 
3E96:  MOVFF  248,293
3E9A:  CLRF   x95
3E9C:  MOVLW  14
3E9E:  MOVWF  x94
3EA0:  MOVLB  0
3EA2:  CALL   15C4
....................  
....................  
....................    ICMPLen = ICMP_HEADER_SIZE + (WORD)len; 
3EA6:  CLRF   03
3EA8:  MOVLB  1
3EAA:  MOVF   xF9,W
3EAC:  ADDLW  08
3EAE:  MOVLB  2
3EB0:  MOVWF  x46
3EB2:  MOVLW  00
3EB4:  ADDWFC 03,W
3EB6:  MOVWF  x47
....................  
....................     packet.Code             = 0; 
3EB8:  MOVLB  1
3EBA:  CLRF   xFF
....................     packet.Type             = code; 
3EBC:  MOVFF  1F6,1FE
....................     packet.Checksum         = 0; 
3EC0:  MOVLB  2
3EC2:  CLRF   x01
3EC4:  CLRF   x00
....................     packet.Identifier       = id; 
3EC6:  MOVFF  1FB,203
3ECA:  MOVFF  1FA,202
....................     packet.SequenceNumber   = seq; 
3ECE:  MOVFF  1FD,205
3ED2:  MOVFF  1FC,204
....................  
....................     memcpy((void*)packet.Data, (void*)data, len); 
3ED6:  MOVLW  02
3ED8:  MOVWF  FEA
3EDA:  MOVLW  06
3EDC:  MOVWF  FE9
3EDE:  MOVFF  1F8,FE2
3EE2:  MOVFF  1F7,FE1
3EE6:  MOVLB  1
3EE8:  MOVF   xF9,W
3EEA:  MOVWF  01
3EEC:  BZ    3EF6
3EEE:  MOVFF  FE6,FEE
3EF2:  DECFSZ 01,F
3EF4:  BRA    3EEE
....................  
....................     SwapICMPPacket(&packet); 
3EF6:  MOVLW  01
3EF8:  MOVLB  2
3EFA:  MOVWF  x4D
3EFC:  MOVLW  FE
3EFE:  MOVWF  x4C
3F00:  MOVLB  0
3F02:  RCALL  3CC2
....................  
.................... #if !defined(MCHP_MAC) 
....................     packet.Checksum         = CalcIPChecksum((BYTE*)&packet, 
....................                                     ICMPLen); 
.................... #endif 
....................  
....................     IPPutHeader(remote, 
....................                 IP_PROT_ICMP, 
....................                 (WORD)(ICMP_HEADER_SIZE + len)); 
3F04:  MOVLW  08
3F06:  MOVLB  1
3F08:  ADDWF  xF9,W
3F0A:  MOVLB  2
3F0C:  CLRF   x4A
3F0E:  MOVWF  x49
3F10:  MOVFF  1F5,27B
3F14:  MOVFF  1F4,27A
3F18:  MOVLW  01
3F1A:  MOVWF  x7C
3F1C:  MOVFF  24A,27E
3F20:  MOVFF  249,27D
3F24:  MOVLB  0
3F26:  CALL   2CB4
....................  
....................     IPPutArray((BYTE*)&packet, ICMPLen); 
3F2A:  MOVLW  01
3F2C:  MOVLB  2
3F2E:  MOVWF  x4A
3F30:  MOVLW  FE
3F32:  MOVFF  24A,29F
3F36:  MOVWF  x9E
3F38:  MOVFF  247,2A1
3F3C:  MOVFF  246,2A0
3F40:  MOVLB  0
3F42:  CALL   16C0
....................  
.................... #if defined(MCHP_MAC) 
....................     // Calculate and write the ICMP checksum using the Microchip MAC's DMA 
....................    packet.Checksum = MACCalcTxChecksum(sizeof(IP_HEADER), ICMPLen); 
3F46:  MOVLB  2
3F48:  CLRF   x94
3F4A:  MOVLW  14
3F4C:  MOVWF  x93
3F4E:  MOVFF  247,296
3F52:  MOVFF  246,295
3F56:  MOVLB  0
3F58:  CALL   2B80
3F5C:  MOVFF  02,201
3F60:  MOVFF  01,200
....................    IPSetTxBuffer(MyTxBuffer, 2); 
3F64:  MOVFF  248,293
3F68:  MOVLB  2
3F6A:  CLRF   x95
3F6C:  MOVLW  16
3F6E:  MOVWF  x94
3F70:  MOVLB  0
3F72:  CALL   15C4
....................    MACPutArray((BYTE*)&packet.Checksum, 2); 
3F76:  MOVLW  02
3F78:  MOVLB  2
3F7A:  MOVWF  x4A
3F7C:  CLRF   x49
3F7E:  MOVWF  x9F
3F80:  MOVFF  249,29E
3F84:  CLRF   xA1
3F86:  MOVWF  xA0
3F88:  MOVLB  0
3F8A:  CALL   16C0
.................... #endif 
....................  
....................  
....................     MACFlush(); 
3F8E:  CALL   1820
3F92:  MOVLB  2
.................... } 
3F94:  MOVLB  0
3F96:  GOTO   4618 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void SwapICMPPacket(ICMP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p - ICMP packet header 
....................  * 
....................  * Output:          ICMP packet is swapped 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void SwapICMPPacket(ICMP_PACKET* p) 
.................... { 
....................     p->Identifier           = swaps(p->Identifier); 
*
3CC2:  MOVLW  04
3CC4:  MOVLB  2
3CC6:  ADDWF  x4C,W
3CC8:  MOVWF  01
3CCA:  MOVLW  00
3CCC:  ADDWFC x4D,W
3CCE:  MOVWF  03
3CD0:  MOVFF  01,24E
3CD4:  MOVWF  x4F
3CD6:  MOVLW  04
3CD8:  ADDWF  x4C,W
3CDA:  MOVWF  FE9
3CDC:  MOVLW  00
3CDE:  ADDWFC x4D,W
3CE0:  MOVWF  FEA
3CE2:  MOVFF  FEC,251
3CE6:  MOVF   FED,F
3CE8:  MOVFF  FEF,250
3CEC:  MOVFF  251,29A
3CF0:  MOVFF  250,299
3CF4:  MOVLB  0
3CF6:  CALL   1254
3CFA:  MOVFF  24F,FEA
3CFE:  MOVFF  24E,FE9
3D02:  MOVFF  02,FEC
3D06:  MOVF   FED,F
3D08:  MOVFF  01,FEF
....................     p->SequenceNumber       = swaps(p->SequenceNumber); 
3D0C:  MOVLW  06
3D0E:  MOVLB  2
3D10:  ADDWF  x4C,W
3D12:  MOVWF  01
3D14:  MOVLW  00
3D16:  ADDWFC x4D,W
3D18:  MOVWF  03
3D1A:  MOVFF  01,24E
3D1E:  MOVWF  x4F
3D20:  MOVLW  06
3D22:  ADDWF  x4C,W
3D24:  MOVWF  FE9
3D26:  MOVLW  00
3D28:  ADDWFC x4D,W
3D2A:  MOVWF  FEA
3D2C:  MOVFF  FEC,251
3D30:  MOVF   FED,F
3D32:  MOVFF  FEF,250
3D36:  MOVFF  251,29A
3D3A:  MOVFF  250,299
3D3E:  MOVLB  0
3D40:  CALL   1254
3D44:  MOVFF  24F,FEA
3D48:  MOVFF  24E,FE9
3D4C:  MOVFF  02,FEC
3D50:  MOVF   FED,F
3D52:  MOVFF  01,FEF
....................     p->Checksum             = swaps(p->Checksum); 
3D56:  MOVLW  02
3D58:  MOVLB  2
3D5A:  ADDWF  x4C,W
3D5C:  MOVWF  01
3D5E:  MOVLW  00
3D60:  ADDWFC x4D,W
3D62:  MOVWF  03
3D64:  MOVFF  01,24E
3D68:  MOVWF  x4F
3D6A:  MOVLW  02
3D6C:  ADDWF  x4C,W
3D6E:  MOVWF  FE9
3D70:  MOVLW  00
3D72:  ADDWFC x4D,W
3D74:  MOVWF  FEA
3D76:  MOVFF  FEC,251
3D7A:  MOVF   FED,F
3D7C:  MOVFF  FEF,250
3D80:  MOVFF  251,29A
3D84:  MOVFF  250,299
3D88:  MOVLB  0
3D8A:  CALL   1254
3D8E:  MOVFF  24F,FEA
3D92:  MOVFF  24E,FE9
3D96:  MOVFF  02,FEC
3D9A:  MOVF   FED,F
3D9C:  MOVFF  01,FEF
.................... } 
3DA0:  RETLW  00
....................  
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
.................... #include "tcpip/udp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #include "tcpip/dhcp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
.................... #include "tcpip/telnet2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
.................... #include "tcpip/arptsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.c 
....................  * Dependencies:    compiler.h 
....................  *                  string.h 
....................  *                  ARP.h 
....................  *                  ARPTsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A macdiscardrx() added to arpprocess() to handle times when an eth packet with arp has padding bytes at the end 
....................  * Darren Rook (CCS)    06/28/04 ArpInit clears cache like in 2.20 
....................  * Darren Rook (CCS)    06/29/04 smArp, Cache no longer static 
....................  * Darren Rook (CCS)    07/12/06 MACDiscardRx spelled wrong (case) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  *                               I am assuming STACK_CLIENT_MODE is TRUE for ARP. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/arptsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ARP_TSK_H 
.................... #define ARP_TSK_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arptask 
.................... //#define debug_arptask   debug_printf 
....................  
.................... /* 
....................  * ARP Task FSM States 
....................  */ 
.................... typedef enum _ARP_STATE 
.................... { 
....................     SM_ARP_IDLE, 
....................     SM_ARP_REPLY 
.................... } ARP_STATE; 
....................  
....................  
.................... /* 
....................  * This ARP task caches one ARP response. 
....................  */ 
.................... static ARP_STATE smARP; 
....................  
.................... static NODE_INFO Cache; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void) 
.................... { 
....................     smARP = SM_ARP_IDLE; 
*
05BE:  BCF    x83.1
....................  
....................     Cache.MACAddr.v[0] = 0xff; 
05C0:  MOVLW  FF
05C2:  MOVLB  1
05C4:  MOVWF  x40
....................     Cache.MACAddr.v[1] = 0xff; 
05C6:  MOVWF  x41
....................     Cache.MACAddr.v[2] = 0xff; 
05C8:  MOVWF  x42
....................     Cache.MACAddr.v[3] = 0xff; 
05CA:  MOVWF  x43
....................     Cache.MACAddr.v[4] = 0xff; 
05CC:  MOVWF  x44
....................     Cache.MACAddr.v[5] = 0xff; 
05CE:  MOVWF  x45
....................  
....................     Cache.IPAddr.Val = 0x0; 
05D0:  CLRF   x49
05D2:  CLRF   x48
05D4:  CLRF   x47
05D6:  CLRF   x46
.................... } 
05D8:  MOVLB  0
05DA:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void) 
.................... { 
....................     NODE_INFO remoteNode; 
....................     BYTE opCode; 
....................  
....................     switch(smARP) 
....................     { 
*
1CE0:  MOVLW  00
1CE2:  BTFSC  x83.1
1CE4:  MOVLW  01
1CE6:  XORLW  00
1CE8:  BZ    1CEC
1CEA:  BRA    1D4E
....................     case SM_ARP_IDLE: 
....................         if ( !ARPGet(&remoteNode, &opCode) ) 
1CEC:  MOVLW  01
1CEE:  MOVLB  2
1CF0:  MOVWF  x00
1CF2:  MOVLW  F4
1CF4:  MOVLB  1
1CF6:  MOVWF  xFF
1CF8:  MOVLW  01
1CFA:  MOVLB  2
1CFC:  MOVWF  x02
1CFE:  MOVLW  FE
1D00:  MOVWF  x01
1D02:  MOVLB  0
1D04:  GOTO   14B4
1D08:  MOVF   01,F
1D0A:  BNZ   1D0E
....................             break; 
1D0C:  BRA    1D6E
....................  
....................          //dsr add 071204 
....................          //dsr fix 071206 
....................          MACDiscardRx(); 
1D0E:  CALL   1138
....................  
....................         if ( opCode == ARP_REPLY ) 
1D12:  MOVLB  1
1D14:  MOVF   xFE,F
1D16:  BNZ   1D4A
....................         { 
.................... 			Cache.MACAddr = remoteNode.MACAddr; 
1D18:  MOVLW  01
1D1A:  MOVWF  FEA
1D1C:  MOVLW  40
1D1E:  MOVWF  FE9
1D20:  MOVLW  01
1D22:  MOVWF  FE2
1D24:  MOVLW  F4
1D26:  MOVWF  FE1
1D28:  MOVLW  06
1D2A:  MOVWF  01
1D2C:  MOVFF  FE6,FEE
1D30:  DECFSZ 01,F
1D32:  BRA    1D2C
....................             Cache.IPAddr.Val = remoteNode.IPAddr.Val; 
1D34:  MOVFF  1FD,149
1D38:  MOVFF  1FC,148
1D3C:  MOVFF  1FB,147
1D40:  MOVFF  1FA,146
....................             break; 
1D44:  MOVLB  0
1D46:  BRA    1D6E
....................         } 
....................         else 
1D48:  BRA    1D4E
....................             smARP = SM_ARP_REPLY; 
1D4A:  MOVLB  0
1D4C:  BSF    x83.1
....................  
....................     default: 
.................... 		if(ARPPut(&remoteNode, ARP_REPLY)) 
1D4E:  MOVLW  01
1D50:  MOVLB  2
1D52:  MOVWF  x18
1D54:  MOVLW  F4
1D56:  MOVWF  x17
1D58:  CLRF   x19
1D5A:  MOVLB  0
1D5C:  RCALL  1B52
1D5E:  MOVF   01,F
1D60:  BZ    1D66
.................... 		{ 
.................... 			smARP = SM_ARP_IDLE; 
1D62:  BCF    x83.1
.................... 		} 
....................         else 
1D64:  BRA    1D6C
....................             return FALSE; 
1D66:  MOVLW  00
1D68:  MOVWF  01
1D6A:  BRA    1D72
....................         break; 
1D6C:  BRA    1D6E
....................  
....................     } 
....................     return TRUE; 
1D6E:  MOVLW  01
1D70:  MOVWF  01
.................... } 
1D72:  GOTO   44E4 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    MACIsTxReady(TRUE) returns TRUE 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr) 
.................... { 
....................     NODE_INFO remoteNode; 
....................  
....................     remoteNode.IPAddr = *IPAddr; 
*
4C90:  MOVLB  2
4C92:  MOVFF  20B,FE9
4C96:  MOVFF  20C,FEA
4C9A:  MOVFF  FEF,00
4C9E:  MOVFF  FEC,01
4CA2:  MOVFF  FEC,02
4CA6:  MOVFF  FEC,03
4CAA:  MOVFF  03,216
4CAE:  MOVFF  02,215
4CB2:  MOVFF  01,214
4CB6:  MOVFF  00,213
....................  
....................     ARPPut(&remoteNode, ARP_REQUEST); 
4CBA:  MOVLW  02
4CBC:  MOVWF  x18
4CBE:  MOVLW  0D
4CC0:  MOVWF  x17
4CC2:  MOVLW  01
4CC4:  MOVWF  x19
4CC6:  MOVLB  0
4CC8:  CALL   1B52
.................... } 
4CCC:  GOTO   61D4 (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr) 
.................... { 
....................     if(Cache.IPAddr.Val == IPAddr->Val || Cache.IPAddr.Val == AppConfig.MyGateway.Val) 
4CD0:  MOVLB  2
4CD2:  MOVFF  20B,FE9
4CD6:  MOVFF  20C,FEA
4CDA:  MOVFF  FEF,00
4CDE:  MOVFF  FEC,01
4CE2:  MOVFF  FEC,02
4CE6:  MOVFF  FEC,03
4CEA:  MOVF   00,W
4CEC:  MOVLB  1
4CEE:  SUBWF  x46,W
4CF0:  BNZ   4D04
4CF2:  MOVF   01,W
4CF4:  SUBWF  x47,W
4CF6:  BNZ   4D04
4CF8:  MOVF   02,W
4CFA:  SUBWF  x48,W
4CFC:  BNZ   4D04
4CFE:  MOVF   03,W
4D00:  SUBWF  x49,W
4D02:  BZ    4D1C
4D04:  MOVF   51,W
4D06:  SUBWF  x46,W
4D08:  BNZ   4D46
4D0A:  MOVF   52,W
4D0C:  SUBWF  x47,W
4D0E:  BNZ   4D46
4D10:  MOVF   53,W
4D12:  SUBWF  x48,W
4D14:  BNZ   4D46
4D16:  MOVF   54,W
4D18:  SUBWF  x49,W
4D1A:  BNZ   4D46
....................     { 
....................         *MACAddr = Cache.MACAddr; 
4D1C:  MOVFF  20E,03
4D20:  MOVLB  2
4D22:  MOVFF  20D,FE9
4D26:  MOVFF  20E,FEA
4D2A:  MOVLW  01
4D2C:  MOVWF  FE2
4D2E:  MOVLW  40
4D30:  MOVWF  FE1
4D32:  MOVLW  06
4D34:  MOVWF  01
4D36:  MOVFF  FE6,FEE
4D3A:  DECFSZ 01,F
4D3C:  BRA    4D36
....................         return TRUE; 
4D3E:  MOVLW  01
4D40:  MOVWF  01
4D42:  BRA    4D4C
4D44:  MOVLB  1
....................     } 
....................     return FALSE; 
4D46:  MOVLW  00
4D48:  MOVWF  01
4D4A:  MOVLB  2
.................... } 
4D4C:  MOVLB  0
4D4E:  GOTO   6202 (RETURN)
....................  
....................  
....................  
.................... #include "tcpip/arp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.c 
....................  * Dependencies:    string.h 
....................  *                  stacktsk.h 
....................  *                  helpers.h 
....................  *                  arp.h 
....................  *                  mac.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... //#define debug_arp 
.................... //#define debug_arp debug_printf 
.................... #define debug_arp(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................  
.................... // ARP Operation codes. 
.................... #define ARP_OPERATION_REQ       0x01u 
.................... #define ARP_OPERATION_RESP      0x02u 
....................  
.................... // ETHERNET packet type as defined by IEEE 802.3 
.................... #define HW_ETHERNET             (0x0001u) 
.................... #define ARP_IP                  (0x0800u) 
....................  
....................  
....................  
.................... // ARP packet 
.................... typedef struct _ARP_PACKET 
.................... { 
....................     WORD        HardwareType; 
....................     WORD        Protocol; 
....................     BYTE        MACAddrLen; 
....................     BYTE        ProtocolLen; 
....................     WORD        Operation; 
....................     MAC_ADDR    SenderMACAddr; 
....................     IP_ADDR     SenderIPAddr; 
....................     MAC_ADDR    TargetMACAddr; 
....................     IP_ADDR     TargetIPAddr; 
.................... } ARP_PACKET; 
....................  
.................... // Helper function 
.................... static void SwapARPPacket(ARP_PACKET *p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int1 ARPGet(NODE_INFO *remote, int8 *opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................     //MACGetArray((int8*)&packet, sizeof(packet)); 
....................     MACGetArray(&packet, sizeof(ARP_PACKET)); 
*
14B4:  MOVLW  02
14B6:  MOVLB  2
14B8:  MOVWF  x89
14BA:  MOVLW  03
14BC:  MOVWF  x88
14BE:  CLRF   x8B
14C0:  MOVLW  1C
14C2:  MOVWF  x8A
14C4:  MOVLB  0
14C6:  RCALL  11D8
....................  
....................     MACDiscardRx(); 
14C8:  RCALL  1138
....................  
....................     SwapARPPacket(&packet); 
14CA:  MOVLW  02
14CC:  MOVLB  2
14CE:  MOVWF  x38
14D0:  MOVLW  03
14D2:  MOVWF  x37
14D4:  MOVLB  0
14D6:  RCALL  13E0
....................  
....................     /* 
....................     debug_arp(debug_putc, "\r\nARP: HW:%LX PR:%LX ML:%U PL:%U O:%LX TI:%U.%U.%U.%U FI:%U.%U.%U.%U", 
....................       packet.HardwareType, packet.Protocol, packet.MACAddrLen, packet.ProtocolLen, 
....................       packet.Operation, packet.TargetIPAddr.v[0],packet.TargetIPAddr.v[1], 
....................       packet.TargetIPAddr.v[2],packet.TargetIPAddr.v[3], 
....................       packet.SenderIPAddr.v[0],packet.SenderIPAddr.v[1],packet.SenderIPAddr.v[2],packet.SenderIPAddr.v[3]); 
.................... 	*/ 
....................     if ( packet.HardwareType != HW_ETHERNET     || 
....................          packet.MACAddrLen != sizeof(MAC_ADDR)  || 
....................          packet.ProtocolLen != sizeof(IP_ADDR) ) 
14D8:  MOVLB  2
14DA:  DECFSZ x03,W
14DC:  BRA    14EE
14DE:  MOVF   x04,F
14E0:  BNZ   14EE
14E2:  MOVF   x07,W
14E4:  SUBLW  06
14E6:  BNZ   14EE
14E8:  MOVF   x08,W
14EA:  SUBLW  04
14EC:  BZ    14F4
....................          return FALSE; 
14EE:  MOVLW  00
14F0:  MOVWF  01
14F2:  BRA    1596
....................  
....................     if ( packet.Operation == ARP_OPERATION_RESP ) 
14F4:  MOVF   x09,W
14F6:  SUBLW  02
14F8:  BNZ   150A
14FA:  MOVF   x0A,F
14FC:  BNZ   150A
....................         *opCode = ARP_REPLY; 
14FE:  MOVFF  201,FE9
1502:  MOVFF  202,FEA
1506:  CLRF   FEF
....................     else if ( packet.Operation == ARP_OPERATION_REQ ) 
1508:  BRA    1532
150A:  DECFSZ x09,W
150C:  BRA    1520
150E:  MOVF   x0A,F
1510:  BNZ   1520
....................         *opCode = ARP_REQUEST; 
1512:  MOVFF  201,FE9
1516:  MOVFF  202,FEA
151A:  MOVLW  01
151C:  MOVWF  FEF
....................     else 
151E:  BRA    1532
....................     { 
....................         *opCode = ARP_UNKNOWN; 
1520:  MOVFF  201,FE9
1524:  MOVFF  202,FEA
1528:  MOVLW  02
152A:  MOVWF  FEF
....................         return FALSE; 
152C:  MOVLW  00
152E:  MOVWF  01
1530:  BRA    1596
....................     } 
....................  
....................     if(packet.TargetIPAddr.Val == AppConfig.MyIPAddr.Val) 
1532:  MOVF   43,W
1534:  SUBWF  x1B,W
1536:  BNZ   1590
1538:  MOVF   44,W
153A:  SUBWF  x1C,W
153C:  BNZ   1590
153E:  MOVF   45,W
1540:  SUBWF  x1D,W
1542:  BNZ   1590
1544:  MOVF   46,W
1546:  SUBWF  x1E,W
1548:  BNZ   1590
....................     { 
....................         remote->MACAddr     = packet.SenderMACAddr; 
154A:  MOVFF  1FF,FE9
154E:  MOVLB  2
1550:  MOVFF  200,FEA
1554:  MOVLW  02
1556:  MOVWF  FE2
1558:  MOVLW  0B
155A:  MOVWF  FE1
155C:  MOVLW  06
155E:  MOVWF  01
1560:  MOVFF  FE6,FEE
1564:  DECFSZ 01,F
1566:  BRA    1560
....................         remote->IPAddr      = packet.SenderIPAddr; 
1568:  MOVLW  06
156A:  MOVLB  1
156C:  ADDWF  xFF,W
156E:  MOVWF  FE9
1570:  MOVLW  00
1572:  MOVLB  2
1574:  ADDWFC x00,W
1576:  MOVWF  FEA
1578:  MOVFF  211,FEF
157C:  MOVFF  212,FEC
1580:  MOVFF  213,FEC
1584:  MOVFF  214,FEC
....................         return TRUE; 
1588:  MOVLW  01
158A:  MOVWF  01
158C:  BRA    1596
....................     } 
....................     else 
158E:  BRA    1596
....................         return FALSE; 
1590:  MOVLW  00
1592:  MOVWF  01
1594:  BRA    1596
.................... } 
1596:  MOVLB  0
1598:  GOTO   1D08 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          TRUE - The ARP packet was generated properly 
....................  *               FALSE - Unable to allocate a TX buffer 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
*
1B52:  MOVLW  01
1B54:  MOVLB  2
1B56:  MOVWF  x7A
1B58:  MOVLB  0
1B5A:  RCALL  159C
1B5C:  MOVFF  01,236
....................     
....................    // Do not respond if there is no room to generate the ARP reply 
....................    if(MyTxBuffer == INVALID_BUFFER) 
1B60:  MOVLB  2
1B62:  INCFSZ x36,W
1B64:  BRA    1B6C
....................       return FALSE; 
1B66:  MOVLW  00
1B68:  MOVWF  01
1B6A:  BRA    1CDC
....................  
....................    MACSetTxBuffer(MyTxBuffer, 0); 
1B6C:  MOVFF  236,293
1B70:  CLRF   x95
1B72:  CLRF   x94
1B74:  MOVLB  0
1B76:  RCALL  15C4
....................     
....................     
....................     packet.HardwareType             = HW_ETHERNET; 
1B78:  MOVLB  2
1B7A:  CLRF   x1B
1B7C:  MOVLW  01
1B7E:  MOVWF  x1A
....................     packet.Protocol                 = ARP_IP; 
1B80:  MOVLW  08
1B82:  MOVWF  x1D
1B84:  CLRF   x1C
....................     packet.MACAddrLen               = sizeof(MAC_ADDR); 
1B86:  MOVLW  06
1B88:  MOVWF  x1E
....................     packet.ProtocolLen              = sizeof(IP_ADDR); 
1B8A:  MOVLW  04
1B8C:  MOVWF  x1F
....................  
....................     if ( opCode == ARP_REQUEST ) 
1B8E:  DECFSZ x19,W
1B90:  BRA    1BA8
....................     { 
....................         packet.Operation            = ARP_OPERATION_REQ; 
1B92:  CLRF   x21
1B94:  MOVLW  01
1B96:  MOVWF  x20
....................         packet.TargetMACAddr.v[0]   = 0xff; 
1B98:  MOVLW  FF
1B9A:  MOVWF  x2C
....................         packet.TargetMACAddr.v[1]   = 0xff; 
1B9C:  MOVWF  x2D
....................         packet.TargetMACAddr.v[2]   = 0xff; 
1B9E:  MOVWF  x2E
....................         packet.TargetMACAddr.v[3]   = 0xff; 
1BA0:  MOVWF  x2F
....................         packet.TargetMACAddr.v[4]   = 0xff; 
1BA2:  MOVWF  x30
....................         packet.TargetMACAddr.v[5]   = 0xff; 
1BA4:  MOVWF  x31
....................     } 
....................     else 
1BA6:  BRA    1BD6
....................     { 
....................         packet.Operation            = ARP_OPERATION_RESP; 
1BA8:  CLRF   x21
1BAA:  MOVLW  02
1BAC:  MOVWF  x20
....................         packet.TargetMACAddr        = remote->MACAddr; 
1BAE:  MOVFF  218,03
1BB2:  MOVFF  217,237
1BB6:  MOVFF  218,238
1BBA:  MOVLW  02
1BBC:  MOVWF  FEA
1BBE:  MOVLW  2C
1BC0:  MOVWF  FE9
1BC2:  MOVFF  218,FE2
1BC6:  MOVFF  217,FE1
1BCA:  MOVLW  06
1BCC:  MOVWF  01
1BCE:  MOVFF  FE6,FEE
1BD2:  DECFSZ 01,F
1BD4:  BRA    1BCE
....................     } 
....................  
....................     packet.SenderMACAddr = AppConfig.MyMACAddr; 
1BD6:  MOVLW  02
1BD8:  MOVWF  FEA
1BDA:  MOVLW  22
1BDC:  MOVWF  FE9
1BDE:  CLRF   FE2
1BE0:  MOVLW  47
1BE2:  MOVWF  FE1
1BE4:  MOVLW  06
1BE6:  MOVWF  01
1BE8:  MOVFF  FE6,FEE
1BEC:  DECFSZ 01,F
1BEE:  BRA    1BE8
....................     packet.SenderIPAddr  = AppConfig.MyIPAddr; 
1BF0:  MOVFF  46,22B
1BF4:  MOVFF  45,22A
1BF8:  MOVFF  44,229
1BFC:  MOVFF  43,228
....................  
....................  
....................     // Check to see if target is on same subnet, if not, find Gateway MAC. 
....................     // Once we get Gateway MAC, all access to remote host will go through Gateway. 
....................     if((packet.SenderIPAddr.Val ^ remote->IPAddr.Val) & AppConfig.MyMask.Val) 
1C00:  MOVLW  06
1C02:  ADDWF  x17,W
1C04:  MOVWF  FE9
1C06:  MOVLW  00
1C08:  ADDWFC x18,W
1C0A:  MOVWF  FEA
1C0C:  MOVFF  FEF,00
1C10:  MOVFF  FEC,01
1C14:  MOVFF  FEC,02
1C18:  MOVFF  FEC,03
1C1C:  MOVF   00,W
1C1E:  XORWF  x28,W
1C20:  MOVWF  x37
1C22:  MOVF   01,W
1C24:  XORWF  x29,W
1C26:  MOVWF  x38
1C28:  MOVF   02,W
1C2A:  XORWF  x2A,W
1C2C:  MOVWF  x39
1C2E:  MOVF   03,W
1C30:  XORWF  x2B,W
1C32:  MOVWF  x3A
1C34:  MOVF   x37,W
1C36:  ANDWF  4D,W
1C38:  MOVWF  00
1C3A:  MOVF   x38,W
1C3C:  ANDWF  4E,W
1C3E:  MOVWF  01
1C40:  MOVF   x39,W
1C42:  ANDWF  4F,W
1C44:  MOVWF  02
1C46:  MOVF   x3A,W
1C48:  ANDWF  50,W
1C4A:  MOVWF  03
1C4C:  MOVF   00,F
1C4E:  BNZ   1C5C
1C50:  MOVF   01,F
1C52:  BNZ   1C5C
1C54:  MOVF   02,F
1C56:  BNZ   1C5C
1C58:  MOVF   03,F
1C5A:  BZ    1C6E
....................     { 
....................       packet.TargetIPAddr = AppConfig.MyGateway; 
1C5C:  MOVFF  54,235
1C60:  MOVFF  53,234
1C64:  MOVFF  52,233
1C68:  MOVFF  51,232
....................     } 
....................     else 
1C6C:  BRA    1C9A
....................         packet.TargetIPAddr             = remote->IPAddr; 
1C6E:  MOVLW  06
1C70:  ADDWF  x17,W
1C72:  MOVWF  FE9
1C74:  MOVLW  00
1C76:  ADDWFC x18,W
1C78:  MOVWF  FEA
1C7A:  MOVFF  FEF,00
1C7E:  MOVFF  FEC,01
1C82:  MOVFF  FEC,02
1C86:  MOVFF  FEC,03
1C8A:  MOVFF  03,235
1C8E:  MOVFF  02,234
1C92:  MOVFF  01,233
1C96:  MOVFF  00,232
....................  
....................     SwapARPPacket(&packet); 
1C9A:  MOVLW  02
1C9C:  MOVWF  x38
1C9E:  MOVLW  1A
1CA0:  MOVWF  x37
1CA2:  MOVLB  0
1CA4:  CALL   13E0
....................  
....................     MACPutHeader(&packet.TargetMACAddr, MAC_ARP, sizeof(packet)); 
1CA8:  MOVLW  02
1CAA:  MOVLB  2
1CAC:  MOVWF  x98
1CAE:  MOVLW  2C
1CB0:  MOVWF  x97
1CB2:  MOVLW  06
1CB4:  MOVWF  x99
1CB6:  CLRF   x9B
1CB8:  MOVLW  1C
1CBA:  MOVWF  x9A
1CBC:  MOVLB  0
1CBE:  RCALL  1726
....................  
....................     //MACPutArray((int8*)&packet, sizeof(packet)); 
....................     MACPutArray(&packet, sizeof(ARP_PACKET)); 
1CC0:  MOVLW  02
1CC2:  MOVLB  2
1CC4:  MOVWF  x9F
1CC6:  MOVLW  1A
1CC8:  MOVWF  x9E
1CCA:  CLRF   xA1
1CCC:  MOVLW  1C
1CCE:  MOVWF  xA0
1CD0:  MOVLB  0
1CD2:  RCALL  16C0
....................  
....................     MACFlush(); 
1CD4:  RCALL  1820
....................     
....................    return TRUE; 
1CD6:  MOVLW  01
1CD8:  MOVWF  01
1CDA:  MOVLB  2
.................... } 
1CDC:  MOVLB  0
1CDE:  RETLW  00
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapARPPacket(ARP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p   - ARP packet to be swapped. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapARPPacket(ARP_PACKET *p) 
.................... { 
....................     p->HardwareType     = swaps(p->HardwareType); 
*
13E0:  MOVLB  2
13E2:  MOVFF  237,01
13E6:  MOVFF  238,03
13EA:  MOVFF  237,239
13EE:  MOVFF  238,23A
13F2:  MOVFF  237,FE9
13F6:  MOVFF  238,FEA
13FA:  MOVFF  FEC,23C
13FE:  MOVF   FED,F
1400:  MOVFF  FEF,23B
1404:  MOVFF  23C,29A
1408:  MOVFF  23B,299
140C:  MOVLB  0
140E:  RCALL  1254
1410:  MOVFF  23A,FEA
1414:  MOVFF  239,FE9
1418:  MOVFF  02,FEC
141C:  MOVF   FED,F
141E:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol); 
1422:  MOVLW  02
1424:  MOVLB  2
1426:  ADDWF  x37,W
1428:  MOVWF  01
142A:  MOVLW  00
142C:  ADDWFC x38,W
142E:  MOVWF  03
1430:  MOVFF  01,239
1434:  MOVWF  x3A
1436:  MOVLW  02
1438:  ADDWF  x37,W
143A:  MOVWF  FE9
143C:  MOVLW  00
143E:  ADDWFC x38,W
1440:  MOVWF  FEA
1442:  MOVFF  FEC,23C
1446:  MOVF   FED,F
1448:  MOVFF  FEF,23B
144C:  MOVFF  23C,29A
1450:  MOVFF  23B,299
1454:  MOVLB  0
1456:  RCALL  1254
1458:  MOVFF  23A,FEA
145C:  MOVFF  239,FE9
1460:  MOVFF  02,FEC
1464:  MOVF   FED,F
1466:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation); 
146A:  MOVLW  06
146C:  MOVLB  2
146E:  ADDWF  x37,W
1470:  MOVWF  01
1472:  MOVLW  00
1474:  ADDWFC x38,W
1476:  MOVWF  03
1478:  MOVFF  01,239
147C:  MOVWF  x3A
147E:  MOVLW  06
1480:  ADDWF  x37,W
1482:  MOVWF  FE9
1484:  MOVLW  00
1486:  ADDWFC x38,W
1488:  MOVWF  FEA
148A:  MOVFF  FEC,23C
148E:  MOVF   FED,F
1490:  MOVFF  FEF,23B
1494:  MOVFF  23C,29A
1498:  MOVFF  23B,299
149C:  MOVLB  0
149E:  RCALL  1254
14A0:  MOVFF  23A,FEA
14A4:  MOVFF  239,FE9
14A8:  MOVFF  02,FEC
14AC:  MOVF   FED,F
14AE:  MOVFF  01,FEF
.................... } 
14B2:  RETLW  00
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
.................... #include "mpfs/mpfs.c" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
.................... #include "tcpip/http.c" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
.................... #include "tcpip/http2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
.................... #include "tcpip/ftp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
.................... #include "tcpip/tftp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
.................... #include "tcpip/smtp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
.................... #include "tcpip/dns.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
.................... #include "tcpip/announce.h" 
.................... #include "tcpip/announce.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
.................... #include "tcpip/snmp.c" 
.................... #endif 
....................  
.................... //#define MAX_ICMP_DATA_LEN   64 //moved to icmp.h 
....................  
.................... /* 
....................  * Stack FSM states. 
....................  */ 
.................... typedef enum _SM_STACK 
.................... { 
....................    SM_STACK_IDLE=0, 
....................    SM_STACK_MAC, 
....................    SM_STACK_IP, 
....................    SM_STACK_ICMP, 
....................    SM_STACK_ICMP_REPLY, 
....................    SM_STACK_ARP, 
....................    SM_STACK_TCP, 
....................    SM_STACK_UDP 
.................... }SM_STACK; 
....................  
.................... SM_STACK smStack; 
....................  
.................... NODE_INFO remoteNode; 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componets are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines are used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void) 
.................... { 
....................    smStack = SM_STACK_IDLE; 
*
0854:  MOVLB  1
0856:  CLRF   x4A
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................    /* 
....................     * If DHCP or IP Gleaning is enabled, 
....................     * startup in Config Mode. 
....................     */ 
....................    AppConfig.Flags.bInConfigMode = TRUE; 
.................... #endif 
....................  
....................    TickInit(); 
0858:  MOVLB  0
085A:  RCALL  010E
....................  
.................... #if STACK_USE_MAC 
....................    MACInit(); 
085C:  RCALL  03F2
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................    ARPInit(); 
085E:  RCALL  05BE
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................    UDPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................    TCPInit(); 
0860:  RCALL  0712
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    DHCPReset(); 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    ppp_init(); 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP||STACK_USE_HTTP2 
....................    HTTP_Init(); 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
....................    FTPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
....................    TFTPInit(); 
.................... #endif 
.................... } 
0862:  RETLW  00
....................  
.................... /* 
....................  #if STACK_USE_MCPENC 
....................  #if MAC_TX_BUFFER_COUNT > 1 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U TXB0.ADD=0x%LX TXB0.FR=%U NPL=0x%LX CPL=0x%LX",NICCurrentTxBuffer, TxBuffers[0].StartAddress, TxBuffers[0].bFree, NextPacketLocation.Val, CurrentPacketLocation.Val) 
....................  #else 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U NPL=0x%LX CPL=0x%LX", NICCurrentTxBuffer, NextPacketLocation.Val, CurrentPacketLocation.Val) 
....................  #endif 
....................  #else 
....................  #define DebugDisplayVals() 
....................  #endif 
....................  */ 
....................  
.................... #define DebugDisplayVals() 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void) 
.................... { 
*
4486:  MOVLB  1
4488:  BCF    xF3.0
....................    static WORD dataCount; 
....................  
.................... #if STACK_USE_ICMP 
....................    static BYTE data[MAX_ICMP_DATA_LEN]; 
....................    static WORD ICMPId; 
....................    static WORD ICMPSeq; 
.................... #endif 
....................    IP_ADDR tempLocalIP; 
....................  
....................    union 
....................    { 
....................       BYTE MACFrameType; 
....................       BYTE IPFrameType; 
.................... #if STACK_USE_ICMP 
....................       ICMP_CODE ICMPCode; 
.................... #endif 
....................    }type; 
....................  
....................    BOOL lbContinue=FALSE; 
....................  
....................    do 
....................    { 
....................       lbContinue = FALSE; 
448A:  BCF    xF3.0
....................       switch(smStack) 
....................       { 
448C:  MOVF   x4A,W
448E:  ADDLW  F9
4490:  BTFSC  FD8.0
4492:  BRA    4622
4494:  ADDLW  07
4496:  MOVLB  0
4498:  GOTO   462E
....................          case SM_STACK_IDLE: 
....................          case SM_STACK_MAC: 
....................          if ( !MACGetHeader(&remoteNode.MACAddr, &type.MACFrameType) ) 
449C:  MOVLW  01
449E:  MOVLB  1
44A0:  MOVWF  xF5
44A2:  MOVLW  4B
44A4:  MOVWF  xF4
44A6:  MOVLW  01
44A8:  MOVWF  xF7
44AA:  MOVLW  F2
44AC:  MOVWF  xF6
44AE:  MOVLB  0
44B0:  GOTO   126A
44B4:  MOVF   01,F
44B6:  BNZ   44BC
....................          { 
.................... #if STACK_USE_DHCP 
....................             // Normally, an application would not include  DHCP module 
....................             // if it is not enabled. But in case some one wants to disable 
....................             // DHCP module at run-time, remember to not clear our IP 
....................             // address if link is removed. 
....................             if ( !DHCPIsDisabled() ) 
....................             { 
....................                if ( !MACIsLinked() ) 
....................                { 
....................                   AppConfig.MyIPAddr.Val = 0x00000000ul; 
....................                   AppConfig.Flags.bInConfigMode = TRUE; 
....................                   DHCPReset(); 
....................                } 
....................             } 
.................... #endif 
....................             break; 
44B8:  MOVLB  1
44BA:  BRA    4622
....................          } 
....................  
....................          //debug_stack(debug_putc, "\r\nMAC GET "); 
....................  
....................          lbContinue = TRUE; 
44BC:  MOVLB  1
44BE:  BSF    xF3.0
....................          if ( type.MACFrameType == MAC_IP ) { 
44C0:  MOVF   xF2,F
44C2:  BNZ   44CA
....................             smStack = SM_STACK_IP; 
44C4:  MOVLW  02
44C6:  MOVWF  x4A
....................             //debug_stack(debug_putc, "IP "); 
....................          } 
....................          else if ( type.MACFrameType == MAC_ARP ) { 
44C8:  BRA    44DE
44CA:  MOVF   xF2,W
44CC:  SUBLW  06
44CE:  BNZ   44D6
....................             smStack = SM_STACK_ARP; 
44D0:  MOVLW  05
44D2:  MOVWF  x4A
....................             //debug_stack(debug_putc, "ARP "); 
....................          } 
....................          else { 
44D4:  BRA    44DE
....................             MACDiscardRx(); 
44D6:  MOVLB  0
44D8:  CALL   1138
44DC:  MOVLB  1
....................             //debug_stack(debug_putc, "DISCARD"); 
....................          } 
....................          break; 
44DE:  BRA    4622
....................  
....................          case SM_STACK_ARP: 
.................... #if STACK_USE_ARP 
....................          if ( ARPProcess() ) { 
44E0:  GOTO   1CE0
44E4:  MOVF   01,F
44E6:  BZ    44EC
....................             smStack = SM_STACK_IDLE; 
44E8:  MOVLB  1
44EA:  CLRF   x4A
....................          } 
.................... #else 
....................          smStack = SM_STACK_IDLE; 
.................... #endif 
....................          break; 
44EC:  MOVLB  1
44EE:  BRA    4622
....................  
....................          case SM_STACK_IP: 
....................          if ( IPGetHeader(&tempLocalIP, 
....................                      &remoteNode, 
....................                      &type.IPFrameType, 
....................                      &dataCount) ) 
44F0:  MOVLW  01
44F2:  MOVLB  1
44F4:  MOVWF  xF5
44F6:  MOVLW  EE
44F8:  MOVWF  xF4
44FA:  MOVLW  01
44FC:  MOVWF  xF7
44FE:  MOVLW  4B
4500:  MOVWF  xF6
4502:  MOVLW  01
4504:  MOVWF  xF9
4506:  MOVLW  F2
4508:  MOVWF  xF8
450A:  MOVLW  01
450C:  MOVWF  xFB
450E:  MOVLW  55
4510:  MOVWF  xFA
4512:  MOVLB  0
4514:  GOTO   207A
4518:  MOVF   01,F
451A:  BZ    4546
....................          { 
....................             lbContinue = TRUE; 
451C:  MOVLB  1
451E:  BSF    xF3.0
....................             if ( type.IPFrameType == IP_PROT_ICMP ) 
4520:  DECFSZ xF2,W
4522:  BRA    452A
....................             { 
....................                smStack = SM_STACK_ICMP; 
4524:  MOVLW  03
4526:  MOVWF  x4A
....................                //debug_stack(debug_putc, "ICMP "); 
.................... #if STACK_USE_IP_GLEANING 
....................                if(AppConfig.Flags.bInConfigMode && !DHCPIsDisabled()) 
....................                { 
....................                   /* 
....................                    * Accoriding to "IP Gleaning" procedure, 
....................                    * when we receive an ICMP packet with a valid 
....................                    * IP address while we are still in configuration 
....................                    * mode, accept that address as ours and conclude 
....................                    * configuration mode. 
....................                    */ 
....................                   if( tempLocalIP.Val != 0xffffffff ) 
....................                   { 
....................                      AppConfig.Flags.bInConfigMode = FALSE; 
....................                      AppConfig.MyIPAddr = tempLocalIP; 
....................                      myDHCPBindCount--; 
....................                   } 
....................                } 
.................... #endif 
....................             } 
....................  
.................... #if STACK_USE_TCP 
....................             else if ( type.IPFrameType == IP_PROT_TCP ) { 
4528:  BRA    4542
452A:  MOVF   xF2,W
452C:  SUBLW  06
452E:  BNZ   4536
....................                smStack = SM_STACK_TCP; 
4530:  MOVLW  06
4532:  MOVWF  x4A
....................                //debug_stack(debug_putc, "TCP "); 
....................             } 
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................             else if ( type.IPFrameType == IP_PROT_UDP ) { 
....................                smStack = SM_STACK_UDP; 
....................                //debug_stack(debug_putc, "UDP "); 
....................             } 
.................... #endif 
....................  
....................             else 
4534:  BRA    4542
....................             { 
....................                lbContinue = FALSE; 
4536:  BCF    xF3.0
....................                MACDiscardRx(); 
4538:  MOVLB  0
453A:  CALL   1138
....................  
....................                smStack = SM_STACK_IDLE; 
453E:  MOVLB  1
4540:  CLRF   x4A
....................                //debug_stack(debug_putc, "UNKOWN-IP1 "); 
....................             } 
....................          } 
....................          else 
4542:  BRA    454E
4544:  MOVLB  0
....................          { 
....................             MACDiscardRx(); 
4546:  CALL   1138
....................             smStack = SM_STACK_IDLE; 
454A:  MOVLB  1
454C:  CLRF   x4A
....................             //debug_stack(debug_putc, "UNKOWN-IP2 "); 
....................          } 
....................          break; 
454E:  BRA    4622
....................  
.................... #if STACK_USE_UDP 
....................          case SM_STACK_UDP: 
....................          if ( UDPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
....................          { 
....................         	 //debug_stack(debug_putc, "\r\nUDP PROCESSED"); 
....................         	 //DebugDisplayVals(); 
....................             smStack = SM_STACK_IDLE; 
....................          } 
....................          break; 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................          case SM_STACK_TCP: 
....................          if ( TCPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
4550:  MOVLW  01
4552:  MOVLB  1
4554:  MOVWF  xF5
4556:  MOVLW  4B
4558:  MOVWF  xF4
455A:  MOVLW  01
455C:  MOVWF  xF7
455E:  MOVLW  EE
4560:  MOVWF  xF6
4562:  MOVFF  156,1F9
4566:  MOVFF  155,1F8
456A:  MOVLB  0
456C:  GOTO   3B04
4570:  MOVF   01,F
4572:  BZ    4578
....................          { 
....................         	 //debug_stack(debug_putc, "\r\nTCP PROCESSED"); 
....................         	 //DebugDisplayVals(); 
....................             smStack = SM_STACK_IDLE; 
4574:  MOVLB  1
4576:  CLRF   x4A
....................          } 
....................          break; 
4578:  MOVLB  1
457A:  BRA    4622
.................... #endif 
....................  
....................          case SM_STACK_ICMP: 
....................          smStack = SM_STACK_IDLE; 
457C:  MOVLB  1
457E:  CLRF   x4A
....................  
.................... #if STACK_USE_ICMP 
....................          //if ( dataCount <= (MAX_ICMP_DATA_LEN+9) ) 
....................          if ( dataCount <= (MAX_ICMP_DATA_LEN+8) ) 
4580:  MOVF   x56,F
4582:  BNZ   45D2
4584:  MOVF   x55,W
4586:  SUBLW  48
4588:  BNC   45D2
....................          { 
....................             if ( ICMPGet(&type.ICMPCode, 
....................                         data, 
....................                         (BYTE*)&dataCount, 
....................                         &ICMPId, 
....................                         &ICMPSeq) ) 
458A:  MOVLW  01
458C:  MOVWF  xF5
458E:  MOVLW  55
4590:  MOVWF  xF4
4592:  MOVLW  01
4594:  MOVWF  xF7
4596:  MOVLW  F2
4598:  MOVWF  xF6
459A:  MOVLW  01
459C:  MOVWF  xF9
459E:  MOVLW  57
45A0:  MOVWF  xF8
45A2:  MOVFF  1F5,1FB
45A6:  MOVFF  1F4,1FA
45AA:  MOVLW  01
45AC:  MOVWF  xFD
45AE:  MOVLW  97
45B0:  MOVWF  xFC
45B2:  MOVLW  01
45B4:  MOVWF  xFF
45B6:  MOVLW  99
45B8:  MOVWF  xFE
45BA:  MOVLB  0
45BC:  GOTO   3DA2
45C0:  MOVF   01,F
45C2:  BZ    45D4
....................             { 
....................                if ( type.ICMPCode == ICMP_ECHO_REQUEST ) 
45C4:  MOVLB  1
45C6:  MOVF   xF2,W
45C8:  SUBLW  08
45CA:  BNZ   45D2
....................                { 
....................             	   // debug_stack(debug_putc, "\r\nICMP PROCESSED"); 
....................                   lbContinue = TRUE; 
45CC:  BSF    xF3.0
....................                   smStack = SM_STACK_ICMP_REPLY; 
45CE:  MOVLW  04
45D0:  MOVWF  x4A
45D2:  MOVLB  0
....................                } 
....................             } 
....................          } 
....................          //DebugDisplayVals(); 
.................... #endif 
....................          MACDiscardRx(); 
45D4:  CALL   1138
....................          break; 
45D8:  MOVLB  1
45DA:  BRA    4622
....................  
.................... #if STACK_USE_ICMP 
....................          case SM_STACK_ICMP_REPLY: 
....................          if ( ICMPIsTxReady() ) 
45DC:  MOVLW  01
45DE:  MOVLB  2
45E0:  MOVWF  x7A
45E2:  MOVLB  0
45E4:  CALL   29CE
45E8:  MOVF   01,F
45EA:  BZ    461C
....................          { 
....................             ICMPPut(&remoteNode, 
....................                   ICMP_ECHO_REPLY, 
....................                   data, 
....................                   (BYTE)dataCount, 
....................                   ICMPId, 
....................                   ICMPSeq); 
45EC:  MOVLW  01
45EE:  MOVLB  1
45F0:  MOVWF  xF5
45F2:  MOVLW  4B
45F4:  MOVWF  xF4
45F6:  CLRF   xF6
45F8:  MOVLW  01
45FA:  MOVWF  xF8
45FC:  MOVLW  57
45FE:  MOVWF  xF7
4600:  MOVFF  155,1F9
4604:  MOVFF  198,1FB
4608:  MOVFF  197,1FA
460C:  MOVFF  19A,1FD
4610:  MOVFF  199,1FC
4614:  MOVLB  0
4616:  BRA    3E7E
....................  
....................             //debug_stack(debug_putc, "\r\nICMP REPLIED"); 
....................             //DebugDisplayVals(); 
....................             smStack = SM_STACK_IDLE; 
4618:  MOVLB  1
461A:  CLRF   x4A
....................          } 
....................          break; 
461C:  MOVLB  1
461E:  BRA    4622
4620:  MOVLB  1
.................... #endif 
....................  
....................       } 
....................  
....................    }while( lbContinue ); 
4622:  BTFSC  xF3.0
4624:  BRA    448A
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
....................    AnnounceTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................    // Perform timed TCP FSM. 
....................    TCPTick(); 
4626:  MOVLB  0
4628:  BRA    3F9A
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    HTTP_Task(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    HTTP_Task(); 
.................... #endif 
....................  
.................... #IF STACK_USE_FTP 
....................    FTPTask(); 
.................... #ENDIF    
....................  
.................... #if STACK_USE_TFTP 
....................    TFTPTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    /* 
....................     * DHCP must be called all the time even after IP configuration is 
....................     * discovered. 
....................     * DHCP has to account lease expiration time and renew the configuration 
....................     * time. 
....................     */ 
....................    DHCPTask(); 
....................  
....................    if ( DHCPIsBound() ) 
....................    AppConfig.Flags.bInConfigMode = FALSE; 
....................  
.................... #endif 
.................... } 
462A:  GOTO   6CD4 (RETURN)
....................  
.................... #include "config.c" 
.................... /********************************************************************* 
....................  * FileName:        config.c 
....................  * Dependencies:    config.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30, dsPIC33F 
....................  * Complier:        Microchip C18 v3.03 or higher 
....................  *                  Microchip C30 v2.01 or higher 
....................  * Company:         IOnOff Technology, Inc. 
....................  * 
....................  * Author               Date       Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Sann Tran            30/06/16   Original 
....................  ********************************************************************/ 
.................... #define __CONFIG_C 
....................  
.................... void MacReset(void) { 
....................    // Microchip VendorID, MAC: 00-04-A3-XX-XX-XX 
....................    MyEEPRom.Macs[0] = MY_DEFAULT_MAC_BYTE3; 
*
0A46:  MOVLW  A3
0A48:  MOVWF  37
....................    MyEEPRom.Macs[1] = MY_DEFAULT_MAC_BYTE4; 
0A4A:  CLRF   38
....................    MyEEPRom.Macs[2] = MY_DEFAULT_MAC_BYTE5; 
0A4C:  CLRF   39
....................    MyEEPRom.Macs[3] = MY_DEFAULT_MAC_BYTE6; 
0A4E:  CLRF   3A
.................... } 
0A50:  GOTO   0DCC (RETURN)
....................  
.................... void ConfigReset(void) { 
....................    MyEEPRom.Flag = TRUE;   
0A54:  MOVLW  01
0A56:  MOVWF  26
....................     
....................    MyEEPRom.SrvIps[0] = 192; 
0A58:  MOVLW  C0
0A5A:  MOVWF  27
....................    MyEEPRom.SrvIps[1] = 168; 
0A5C:  MOVLW  A8
0A5E:  MOVWF  28
....................    MyEEPRom.SrvIps[2] = 1; 
0A60:  MOVLW  01
0A62:  MOVWF  29
....................    MyEEPRom.SrvIps[3] = 252; 
0A64:  MOVLW  FC
0A66:  MOVWF  2A
....................  
....................    MyEEPRom.Ips[0] = MY_DEFAULT_IP_ADDR_BYTE1; 
0A68:  MOVLW  C0
0A6A:  MOVWF  2B
....................    MyEEPRom.Ips[1] = MY_DEFAULT_IP_ADDR_BYTE2; 
0A6C:  MOVLW  A8
0A6E:  MOVWF  2C
....................    MyEEPRom.Ips[2] = MY_DEFAULT_IP_ADDR_BYTE3; 
0A70:  MOVLW  01
0A72:  MOVWF  2D
....................    MyEEPRom.Ips[3] = MY_DEFAULT_IP_ADDR_BYTE4; 
0A74:  MOVLW  81
0A76:  MOVWF  2E
....................  
....................    //Mascara de Subred 
....................    MyEEPRom.Masks[0] = MY_DEFAULT_MASK_BYTE1; 
0A78:  MOVLW  FF
0A7A:  MOVWF  2F
....................    MyEEPRom.Masks[1] = MY_DEFAULT_MASK_BYTE2; 
0A7C:  MOVWF  30
....................    MyEEPRom.Masks[2] = MY_DEFAULT_MASK_BYTE3; 
0A7E:  MOVWF  31
....................    MyEEPRom.Masks[3] = MY_DEFAULT_MASK_BYTE4; 
0A80:  CLRF   32
....................  
....................    //Puerta de Enlace 
....................    MyEEPRom.Gates[0] = MY_DEFAULT_GATE_BYTE1; 
0A82:  MOVLW  C0
0A84:  MOVWF  33
....................    MyEEPRom.Gates[1] = MY_DEFAULT_GATE_BYTE2; 
0A86:  MOVLW  A8
0A88:  MOVWF  34
....................    MyEEPRom.Gates[2] = MY_DEFAULT_GATE_BYTE3; 
0A8A:  MOVLW  01
0A8C:  MOVWF  35
....................    MyEEPRom.Gates[3] = MY_DEFAULT_GATE_BYTE4; 
0A8E:  MOVWF  36
....................    // Set default input types 
....................    int8 i; 
....................    for (i = 0; i < 8; i++) { 
0A90:  MOVLB  1
0A92:  CLRF   xEF
0A94:  MOVF   xEF,W
0A96:  SUBLW  07
0A98:  BNC   0AB0
....................       MyEEPRom.InputTypes[i] = INPUT_SWITCH; 
0A9A:  CLRF   03
0A9C:  MOVF   xEF,W
0A9E:  ADDLW  3B
0AA0:  MOVWF  FE9
0AA2:  MOVLW  00
0AA4:  ADDWFC 03,W
0AA6:  MOVWF  FEA
0AA8:  MOVLW  01
0AAA:  MOVWF  FEF
....................    } 
0AAC:  INCF   xEF,F
0AAE:  BRA    0A94
.................... } 
0AB0:  MOVLB  0
0AB2:  RETLW  00
....................  
.................... void EEPWriteFlag() { 
....................    write_eeprom(0, MyEEPRom.Flag); 
*
0B0A:  CLRF   FA9
0B0C:  MOVFF  26,FA8
0B10:  BCF    FA6.6
0B12:  BCF    FA6.7
0B14:  BSF    FA6.2
0B16:  MOVF   FF2,W
0B18:  MOVWF  00
0B1A:  BCF    FF2.7
0B1C:  MOVLB  F
0B1E:  MOVLW  55
0B20:  MOVWF  FA7
0B22:  MOVLW  AA
0B24:  MOVWF  FA7
0B26:  BSF    FA6.1
0B28:  BTFSC  FA6.1
0B2A:  BRA    0B28
0B2C:  BCF    FA6.2
0B2E:  MOVF   00,W
0B30:  IORWF  FF2,F
.................... } 
0B32:  MOVLB  0
0B34:  GOTO   0CE8 (RETURN)
....................  
.................... void EEPWriteSrvIp() { 
....................    int i; 
....................    for (i = 0; i < 4; i++) { 
0B38:  MOVLB  2
0B3A:  CLRF   x27
0B3C:  MOVF   x27,W
0B3E:  SUBLW  03
0B40:  BNC   0B8A
....................       write_eeprom(1 + i, MyEEPRom.SrvIps[i]); 
0B42:  MOVLW  01
0B44:  ADDWF  x27,W
0B46:  MOVWF  x28
0B48:  CLRF   03
0B4A:  MOVF   x27,W
0B4C:  ADDLW  27
0B4E:  MOVWF  FE9
0B50:  MOVLW  00
0B52:  ADDWFC 03,W
0B54:  MOVWF  FEA
0B56:  MOVFF  FEF,229
0B5A:  MOVFF  228,FA9
0B5E:  MOVFF  229,FA8
0B62:  BCF    FA6.6
0B64:  BCF    FA6.7
0B66:  BSF    FA6.2
0B68:  MOVF   FF2,W
0B6A:  MOVWF  00
0B6C:  BCF    FF2.7
0B6E:  MOVLB  F
0B70:  MOVLW  55
0B72:  MOVWF  FA7
0B74:  MOVLW  AA
0B76:  MOVWF  FA7
0B78:  BSF    FA6.1
0B7A:  BTFSC  FA6.1
0B7C:  BRA    0B7A
0B7E:  BCF    FA6.2
0B80:  MOVF   00,W
0B82:  IORWF  FF2,F
....................    }    
0B84:  MOVLB  2
0B86:  INCF   x27,F
0B88:  BRA    0B3C
.................... } 
0B8A:  MOVLB  0
0B8C:  RETLW  00
....................  
.................... void EEPWriteIp() { 
....................    int i; 
....................    for (i = 0; i < 4; i++) { 
0B8E:  MOVLB  2
0B90:  CLRF   x27
0B92:  MOVF   x27,W
0B94:  SUBLW  03
0B96:  BNC   0BE0
....................       write_eeprom(5 + i, MyEEPRom.Ips[i]); 
0B98:  MOVLW  05
0B9A:  ADDWF  x27,W
0B9C:  MOVWF  x28
0B9E:  CLRF   03
0BA0:  MOVF   x27,W
0BA2:  ADDLW  2B
0BA4:  MOVWF  FE9
0BA6:  MOVLW  00
0BA8:  ADDWFC 03,W
0BAA:  MOVWF  FEA
0BAC:  MOVFF  FEF,229
0BB0:  MOVFF  228,FA9
0BB4:  MOVFF  229,FA8
0BB8:  BCF    FA6.6
0BBA:  BCF    FA6.7
0BBC:  BSF    FA6.2
0BBE:  MOVF   FF2,W
0BC0:  MOVWF  00
0BC2:  BCF    FF2.7
0BC4:  MOVLB  F
0BC6:  MOVLW  55
0BC8:  MOVWF  FA7
0BCA:  MOVLW  AA
0BCC:  MOVWF  FA7
0BCE:  BSF    FA6.1
0BD0:  BTFSC  FA6.1
0BD2:  BRA    0BD0
0BD4:  BCF    FA6.2
0BD6:  MOVF   00,W
0BD8:  IORWF  FF2,F
....................    } 
0BDA:  MOVLB  2
0BDC:  INCF   x27,F
0BDE:  BRA    0B92
.................... } 
0BE0:  MOVLB  0
0BE2:  RETLW  00
....................  
.................... void EEPWriteGate() { 
....................    int i; 
....................    for (i = 0; i < 4; i++) { 
0BE4:  MOVLB  2
0BE6:  CLRF   x27
0BE8:  MOVF   x27,W
0BEA:  SUBLW  03
0BEC:  BNC   0C36
....................       write_eeprom(9 + i, MyEEPRom.Gates[i]); 
0BEE:  MOVLW  09
0BF0:  ADDWF  x27,W
0BF2:  MOVWF  x28
0BF4:  CLRF   03
0BF6:  MOVF   x27,W
0BF8:  ADDLW  33
0BFA:  MOVWF  FE9
0BFC:  MOVLW  00
0BFE:  ADDWFC 03,W
0C00:  MOVWF  FEA
0C02:  MOVFF  FEF,229
0C06:  MOVFF  228,FA9
0C0A:  MOVFF  229,FA8
0C0E:  BCF    FA6.6
0C10:  BCF    FA6.7
0C12:  BSF    FA6.2
0C14:  MOVF   FF2,W
0C16:  MOVWF  00
0C18:  BCF    FF2.7
0C1A:  MOVLB  F
0C1C:  MOVLW  55
0C1E:  MOVWF  FA7
0C20:  MOVLW  AA
0C22:  MOVWF  FA7
0C24:  BSF    FA6.1
0C26:  BTFSC  FA6.1
0C28:  BRA    0C26
0C2A:  BCF    FA6.2
0C2C:  MOVF   00,W
0C2E:  IORWF  FF2,F
....................    } 
0C30:  MOVLB  2
0C32:  INCF   x27,F
0C34:  BRA    0BE8
.................... } 
0C36:  MOVLB  0
0C38:  RETLW  00
....................  
.................... void EEPWriteMask() { 
....................    int i; 
....................    for (i = 0; i < 4; i++) { 
0C3A:  MOVLB  2
0C3C:  CLRF   x27
0C3E:  MOVF   x27,W
0C40:  SUBLW  03
0C42:  BNC   0C8C
....................       write_eeprom(13 + i, MyEEPRom.Masks[i]); 
0C44:  MOVLW  0D
0C46:  ADDWF  x27,W
0C48:  MOVWF  x28
0C4A:  CLRF   03
0C4C:  MOVF   x27,W
0C4E:  ADDLW  2F
0C50:  MOVWF  FE9
0C52:  MOVLW  00
0C54:  ADDWFC 03,W
0C56:  MOVWF  FEA
0C58:  MOVFF  FEF,229
0C5C:  MOVFF  228,FA9
0C60:  MOVFF  229,FA8
0C64:  BCF    FA6.6
0C66:  BCF    FA6.7
0C68:  BSF    FA6.2
0C6A:  MOVF   FF2,W
0C6C:  MOVWF  00
0C6E:  BCF    FF2.7
0C70:  MOVLB  F
0C72:  MOVLW  55
0C74:  MOVWF  FA7
0C76:  MOVLW  AA
0C78:  MOVWF  FA7
0C7A:  BSF    FA6.1
0C7C:  BTFSC  FA6.1
0C7E:  BRA    0C7C
0C80:  BCF    FA6.2
0C82:  MOVF   00,W
0C84:  IORWF  FF2,F
....................    } 
0C86:  MOVLB  2
0C88:  INCF   x27,F
0C8A:  BRA    0C3E
.................... } 
0C8C:  MOVLB  0
0C8E:  RETLW  00
....................  
.................... void EEPWriteMac() {   
....................    // Just store MAC bytes from 3-6 
....................    int i; 
....................    for (i = 0; i < 4; i++) { 
*
0AB4:  MOVLB  2
0AB6:  CLRF   x27
0AB8:  MOVF   x27,W
0ABA:  SUBLW  03
0ABC:  BNC   0B06
....................       write_eeprom(17 + i, MyEEPRom.Macs[i]); 
0ABE:  MOVLW  11
0AC0:  ADDWF  x27,W
0AC2:  MOVWF  x28
0AC4:  CLRF   03
0AC6:  MOVF   x27,W
0AC8:  ADDLW  37
0ACA:  MOVWF  FE9
0ACC:  MOVLW  00
0ACE:  ADDWFC 03,W
0AD0:  MOVWF  FEA
0AD2:  MOVFF  FEF,229
0AD6:  MOVFF  228,FA9
0ADA:  MOVFF  229,FA8
0ADE:  BCF    FA6.6
0AE0:  BCF    FA6.7
0AE2:  BSF    FA6.2
0AE4:  MOVF   FF2,W
0AE6:  MOVWF  00
0AE8:  BCF    FF2.7
0AEA:  MOVLB  F
0AEC:  MOVLW  55
0AEE:  MOVWF  FA7
0AF0:  MOVLW  AA
0AF2:  MOVWF  FA7
0AF4:  BSF    FA6.1
0AF6:  BTFSC  FA6.1
0AF8:  BRA    0AF6
0AFA:  BCF    FA6.2
0AFC:  MOVF   00,W
0AFE:  IORWF  FF2,F
....................    } 
0B00:  MOVLB  2
0B02:  INCF   x27,F
0B04:  BRA    0AB8
.................... } 
0B06:  MOVLB  0
0B08:  RETLW  00
....................  
.................... void EEPWriteInputTypes() { // 21 - 28 
....................    int8 i; 
....................    for (i = 0; i < 8; i++) { 
*
0C90:  MOVLB  2
0C92:  CLRF   x0C
0C94:  MOVF   x0C,W
0C96:  SUBLW  07
0C98:  BNC   0CE2
....................       write_eeprom(i + 21, MyEEPRom.InputTypes[i]); 
0C9A:  MOVLW  15
0C9C:  ADDWF  x0C,W
0C9E:  MOVWF  x0D
0CA0:  CLRF   03
0CA2:  MOVF   x0C,W
0CA4:  ADDLW  3B
0CA6:  MOVWF  FE9
0CA8:  MOVLW  00
0CAA:  ADDWFC 03,W
0CAC:  MOVWF  FEA
0CAE:  MOVFF  FEF,20E
0CB2:  MOVFF  20D,FA9
0CB6:  MOVFF  20E,FA8
0CBA:  BCF    FA6.6
0CBC:  BCF    FA6.7
0CBE:  BSF    FA6.2
0CC0:  MOVF   FF2,W
0CC2:  MOVWF  00
0CC4:  BCF    FF2.7
0CC6:  MOVLB  F
0CC8:  MOVLW  55
0CCA:  MOVWF  FA7
0CCC:  MOVLW  AA
0CCE:  MOVWF  FA7
0CD0:  BSF    FA6.1
0CD2:  BTFSC  FA6.1
0CD4:  BRA    0CD2
0CD6:  BCF    FA6.2
0CD8:  MOVF   00,W
0CDA:  IORWF  FF2,F
....................    } 
0CDC:  MOVLB  2
0CDE:  INCF   x0C,F
0CE0:  BRA    0C94
.................... } 
0CE2:  MOVLB  0
0CE4:  RETLW  00
....................  
.................... void EEPWriteOutputState(int8 idx) { // 29 - 36 
....................    if (idx >= 1 && idx <= 8) { 
*
46D8:  MOVLB  2
46DA:  MOVF   x0F,W
46DC:  SUBLW  00
46DE:  BTFSC  FD8.0
46E0:  BRA    48C6
46E2:  MOVF   x0F,W
46E4:  SUBLW  08
46E6:  BTFSS  FD8.0
46E8:  BRA    48C6
....................       if (idx == 1) { 
46EA:  DECFSZ x0F,W
46EC:  BRA    4724
....................          write_eeprom(29, input_state(OUT_1)); 
46EE:  MOVLW  00
46F0:  BTFSC  F82.2
46F2:  MOVLW  01
46F4:  MOVWF  x10
46F6:  MOVLW  1D
46F8:  MOVWF  FA9
46FA:  MOVFF  210,FA8
46FE:  BCF    FA6.6
4700:  BCF    FA6.7
4702:  BSF    FA6.2
4704:  MOVF   FF2,W
4706:  MOVWF  00
4708:  BCF    FF2.7
470A:  MOVLB  F
470C:  MOVLW  55
470E:  MOVWF  FA7
4710:  MOVLW  AA
4712:  MOVWF  FA7
4714:  BSF    FA6.1
4716:  BTFSC  FA6.1
4718:  BRA    4716
471A:  BCF    FA6.2
471C:  MOVF   00,W
471E:  IORWF  FF2,F
....................       } 
....................       else if (idx == 2) { 
4720:  BRA    48C4
4722:  MOVLB  2
4724:  MOVF   x0F,W
4726:  SUBLW  02
4728:  BNZ   4760
....................          write_eeprom(30, input_state(OUT_2)); 
472A:  MOVLW  00
472C:  BTFSC  F82.1
472E:  MOVLW  01
4730:  MOVWF  x10
4732:  MOVLW  1E
4734:  MOVWF  FA9
4736:  MOVFF  210,FA8
473A:  BCF    FA6.6
473C:  BCF    FA6.7
473E:  BSF    FA6.2
4740:  MOVF   FF2,W
4742:  MOVWF  00
4744:  BCF    FF2.7
4746:  MOVLB  F
4748:  MOVLW  55
474A:  MOVWF  FA7
474C:  MOVLW  AA
474E:  MOVWF  FA7
4750:  BSF    FA6.1
4752:  BTFSC  FA6.1
4754:  BRA    4752
4756:  BCF    FA6.2
4758:  MOVF   00,W
475A:  IORWF  FF2,F
....................       } 
....................       else if (idx == 3) { 
475C:  BRA    48C4
475E:  MOVLB  2
4760:  MOVF   x0F,W
4762:  SUBLW  03
4764:  BNZ   479C
....................          write_eeprom(31, input_state(OUT_3)); 
4766:  MOVLW  00
4768:  BTFSC  F82.0
476A:  MOVLW  01
476C:  MOVWF  x10
476E:  MOVLW  1F
4770:  MOVWF  FA9
4772:  MOVFF  210,FA8
4776:  BCF    FA6.6
4778:  BCF    FA6.7
477A:  BSF    FA6.2
477C:  MOVF   FF2,W
477E:  MOVWF  00
4780:  BCF    FF2.7
4782:  MOVLB  F
4784:  MOVLW  55
4786:  MOVWF  FA7
4788:  MOVLW  AA
478A:  MOVWF  FA7
478C:  BSF    FA6.1
478E:  BTFSC  FA6.1
4790:  BRA    478E
4792:  BCF    FA6.2
4794:  MOVF   00,W
4796:  IORWF  FF2,F
....................       } 
....................       else if (idx == 4) { 
4798:  BRA    48C4
479A:  MOVLB  2
479C:  MOVF   x0F,W
479E:  SUBLW  04
47A0:  BNZ   47D8
....................          write_eeprom(32, input_state(OUT_4)); 
47A2:  MOVLW  00
47A4:  BTFSC  F84.2
47A6:  MOVLW  01
47A8:  MOVWF  x10
47AA:  MOVLW  20
47AC:  MOVWF  FA9
47AE:  MOVFF  210,FA8
47B2:  BCF    FA6.6
47B4:  BCF    FA6.7
47B6:  BSF    FA6.2
47B8:  MOVF   FF2,W
47BA:  MOVWF  00
47BC:  BCF    FF2.7
47BE:  MOVLB  F
47C0:  MOVLW  55
47C2:  MOVWF  FA7
47C4:  MOVLW  AA
47C6:  MOVWF  FA7
47C8:  BSF    FA6.1
47CA:  BTFSC  FA6.1
47CC:  BRA    47CA
47CE:  BCF    FA6.2
47D0:  MOVF   00,W
47D2:  IORWF  FF2,F
....................       } 
....................       else if (idx == 5) { 
47D4:  BRA    48C4
47D6:  MOVLB  2
47D8:  MOVF   x0F,W
47DA:  SUBLW  05
47DC:  BNZ   4814
....................          write_eeprom(33, input_state(OUT_5)); 
47DE:  MOVLW  00
47E0:  BTFSC  F84.1
47E2:  MOVLW  01
47E4:  MOVWF  x10
47E6:  MOVLW  21
47E8:  MOVWF  FA9
47EA:  MOVFF  210,FA8
47EE:  BCF    FA6.6
47F0:  BCF    FA6.7
47F2:  BSF    FA6.2
47F4:  MOVF   FF2,W
47F6:  MOVWF  00
47F8:  BCF    FF2.7
47FA:  MOVLB  F
47FC:  MOVLW  55
47FE:  MOVWF  FA7
4800:  MOVLW  AA
4802:  MOVWF  FA7
4804:  BSF    FA6.1
4806:  BTFSC  FA6.1
4808:  BRA    4806
480A:  BCF    FA6.2
480C:  MOVF   00,W
480E:  IORWF  FF2,F
....................       } 
....................       else if (idx == 6) { 
4810:  BRA    48C4
4812:  MOVLB  2
4814:  MOVF   x0F,W
4816:  SUBLW  06
4818:  BNZ   4850
....................          write_eeprom(34, input_state(OUT_6)); 
481A:  MOVLW  00
481C:  BTFSC  F84.0
481E:  MOVLW  01
4820:  MOVWF  x10
4822:  MOVLW  22
4824:  MOVWF  FA9
4826:  MOVFF  210,FA8
482A:  BCF    FA6.6
482C:  BCF    FA6.7
482E:  BSF    FA6.2
4830:  MOVF   FF2,W
4832:  MOVWF  00
4834:  BCF    FF2.7
4836:  MOVLB  F
4838:  MOVLW  55
483A:  MOVWF  FA7
483C:  MOVLW  AA
483E:  MOVWF  FA7
4840:  BSF    FA6.1
4842:  BTFSC  FA6.1
4844:  BRA    4842
4846:  BCF    FA6.2
4848:  MOVF   00,W
484A:  IORWF  FF2,F
....................       }  
....................       else if (idx == 7) { 
484C:  BRA    48C4
484E:  MOVLB  2
4850:  MOVF   x0F,W
4852:  SUBLW  07
4854:  BNZ   488C
....................          write_eeprom(35, input_state(OUT_7)); 
4856:  MOVLW  00
4858:  BTFSC  F80.5
485A:  MOVLW  01
485C:  MOVWF  x10
485E:  MOVLW  23
4860:  MOVWF  FA9
4862:  MOVFF  210,FA8
4866:  BCF    FA6.6
4868:  BCF    FA6.7
486A:  BSF    FA6.2
486C:  MOVF   FF2,W
486E:  MOVWF  00
4870:  BCF    FF2.7
4872:  MOVLB  F
4874:  MOVLW  55
4876:  MOVWF  FA7
4878:  MOVLW  AA
487A:  MOVWF  FA7
487C:  BSF    FA6.1
487E:  BTFSC  FA6.1
4880:  BRA    487E
4882:  BCF    FA6.2
4884:  MOVF   00,W
4886:  IORWF  FF2,F
....................       } 
....................       else if (idx == 8) { 
4888:  BRA    48C4
488A:  MOVLB  2
488C:  MOVF   x0F,W
488E:  SUBLW  08
4890:  BNZ   48C6
....................          write_eeprom(36, input_state(OUT_8)); 
4892:  MOVLW  00
4894:  BTFSC  F80.4
4896:  MOVLW  01
4898:  MOVWF  x10
489A:  MOVLW  24
489C:  MOVWF  FA9
489E:  MOVFF  210,FA8
48A2:  BCF    FA6.6
48A4:  BCF    FA6.7
48A6:  BSF    FA6.2
48A8:  MOVF   FF2,W
48AA:  MOVWF  00
48AC:  BCF    FF2.7
48AE:  MOVLB  F
48B0:  MOVLW  55
48B2:  MOVWF  FA7
48B4:  MOVLW  AA
48B6:  MOVWF  FA7
48B8:  BSF    FA6.1
48BA:  BTFSC  FA6.1
48BC:  BRA    48BA
48BE:  BCF    FA6.2
48C0:  MOVF   00,W
48C2:  IORWF  FF2,F
48C4:  MOVLB  2
....................       }       
....................    }    
.................... } 
48C6:  MOVLB  0
48C8:  RETLW  00
....................  
.................... void EEPWriteConfig() { 
....................    EEPWriteFlag(); 
*
0CE6:  BRA    0B0A
....................    EEPWriteSrvIp(); 
0CE8:  RCALL  0B38
....................    EEPWriteIp(); 
0CEA:  RCALL  0B8E
....................    EEPWriteGate(); 
0CEC:  RCALL  0BE4
....................    EEPWriteMask(); 
0CEE:  RCALL  0C3A
....................    EEPWriteInputTypes(); 
0CF0:  RCALL  0C90
.................... } 
0CF2:  RETLW  00
....................  
.................... void EEPReadAll() { 
....................    MyEEPRom.Flag = read_eeprom(0); 
*
08D8:  MOVFF  FF2,1EF
08DC:  BCF    FF2.7
08DE:  CLRF   FA9
08E0:  BCF    FA6.6
08E2:  BCF    FA6.7
08E4:  BSF    FA6.0
08E6:  MOVF   FA8,W
08E8:  MOVLB  1
08EA:  BTFSC  xEF.7
08EC:  BSF    FF2.7
08EE:  MOVWF  26
....................    int8 i; 
....................    for (i = 0; i < 4; i++) { 
08F0:  CLRF   xEE
08F2:  MOVF   xEE,W
08F4:  SUBLW  03
08F6:  BNC   0928
....................       MyEEPRom.SrvIps[i] = read_eeprom(1 + i); 
08F8:  CLRF   03
08FA:  MOVF   xEE,W
08FC:  ADDLW  27
08FE:  MOVWF  FE9
0900:  MOVLW  00
0902:  ADDWFC 03,W
0904:  MOVWF  FEA
0906:  MOVLW  01
0908:  ADDWF  xEE,W
090A:  MOVWF  xF1
090C:  MOVFF  FF2,1F2
0910:  BCF    FF2.7
0912:  MOVFF  1F1,FA9
0916:  BCF    FA6.6
0918:  BCF    FA6.7
091A:  BSF    FA6.0
091C:  MOVF   FA8,W
091E:  BTFSC  xF2.7
0920:  BSF    FF2.7
0922:  MOVWF  FEF
....................    } 
0924:  INCF   xEE,F
0926:  BRA    08F2
....................    for (i = 0; i < 4; i++) { 
0928:  CLRF   xEE
092A:  MOVF   xEE,W
092C:  SUBLW  03
092E:  BNC   0960
....................       MyEEPRom.Ips[i] = read_eeprom(5 + i); 
0930:  CLRF   03
0932:  MOVF   xEE,W
0934:  ADDLW  2B
0936:  MOVWF  FE9
0938:  MOVLW  00
093A:  ADDWFC 03,W
093C:  MOVWF  FEA
093E:  MOVLW  05
0940:  ADDWF  xEE,W
0942:  MOVWF  xF1
0944:  MOVFF  FF2,1F2
0948:  BCF    FF2.7
094A:  MOVFF  1F1,FA9
094E:  BCF    FA6.6
0950:  BCF    FA6.7
0952:  BSF    FA6.0
0954:  MOVF   FA8,W
0956:  BTFSC  xF2.7
0958:  BSF    FF2.7
095A:  MOVWF  FEF
....................    } 
095C:  INCF   xEE,F
095E:  BRA    092A
....................    for (i = 0; i < 4; i++) { 
0960:  CLRF   xEE
0962:  MOVF   xEE,W
0964:  SUBLW  03
0966:  BNC   0998
....................       MyEEPRom.Gates[i] = read_eeprom(9 + i); 
0968:  CLRF   03
096A:  MOVF   xEE,W
096C:  ADDLW  33
096E:  MOVWF  FE9
0970:  MOVLW  00
0972:  ADDWFC 03,W
0974:  MOVWF  FEA
0976:  MOVLW  09
0978:  ADDWF  xEE,W
097A:  MOVWF  xF1
097C:  MOVFF  FF2,1F2
0980:  BCF    FF2.7
0982:  MOVFF  1F1,FA9
0986:  BCF    FA6.6
0988:  BCF    FA6.7
098A:  BSF    FA6.0
098C:  MOVF   FA8,W
098E:  BTFSC  xF2.7
0990:  BSF    FF2.7
0992:  MOVWF  FEF
....................    } 
0994:  INCF   xEE,F
0996:  BRA    0962
....................    for (i = 0; i < 4; i++) { 
0998:  CLRF   xEE
099A:  MOVF   xEE,W
099C:  SUBLW  03
099E:  BNC   09D0
....................       MyEEPRom.Masks[i] = read_eeprom(13 + i); 
09A0:  CLRF   03
09A2:  MOVF   xEE,W
09A4:  ADDLW  2F
09A6:  MOVWF  FE9
09A8:  MOVLW  00
09AA:  ADDWFC 03,W
09AC:  MOVWF  FEA
09AE:  MOVLW  0D
09B0:  ADDWF  xEE,W
09B2:  MOVWF  xF1
09B4:  MOVFF  FF2,1F2
09B8:  BCF    FF2.7
09BA:  MOVFF  1F1,FA9
09BE:  BCF    FA6.6
09C0:  BCF    FA6.7
09C2:  BSF    FA6.0
09C4:  MOVF   FA8,W
09C6:  BTFSC  xF2.7
09C8:  BSF    FF2.7
09CA:  MOVWF  FEF
....................    } 
09CC:  INCF   xEE,F
09CE:  BRA    099A
....................    for (i = 0; i < 4; i++) { 
09D0:  CLRF   xEE
09D2:  MOVF   xEE,W
09D4:  SUBLW  03
09D6:  BNC   0A08
....................       MyEEPRom.Macs[i] = read_eeprom(17 + i); 
09D8:  CLRF   03
09DA:  MOVF   xEE,W
09DC:  ADDLW  37
09DE:  MOVWF  FE9
09E0:  MOVLW  00
09E2:  ADDWFC 03,W
09E4:  MOVWF  FEA
09E6:  MOVLW  11
09E8:  ADDWF  xEE,W
09EA:  MOVWF  xF1
09EC:  MOVFF  FF2,1F2
09F0:  BCF    FF2.7
09F2:  MOVFF  1F1,FA9
09F6:  BCF    FA6.6
09F8:  BCF    FA6.7
09FA:  BSF    FA6.0
09FC:  MOVF   FA8,W
09FE:  BTFSC  xF2.7
0A00:  BSF    FF2.7
0A02:  MOVWF  FEF
....................    }    
0A04:  INCF   xEE,F
0A06:  BRA    09D2
....................    for (i = 0; i < 8; i++) { 
0A08:  CLRF   xEE
0A0A:  MOVF   xEE,W
0A0C:  SUBLW  07
0A0E:  BNC   0A40
....................       MyEEPRom.InputTypes[i] = read_eeprom(21 + i); 
0A10:  CLRF   03
0A12:  MOVF   xEE,W
0A14:  ADDLW  3B
0A16:  MOVWF  FE9
0A18:  MOVLW  00
0A1A:  ADDWFC 03,W
0A1C:  MOVWF  FEA
0A1E:  MOVLW  15
0A20:  ADDWF  xEE,W
0A22:  MOVWF  xF1
0A24:  MOVFF  FF2,1F2
0A28:  BCF    FF2.7
0A2A:  MOVFF  1F1,FA9
0A2E:  BCF    FA6.6
0A30:  BCF    FA6.7
0A32:  BSF    FA6.0
0A34:  MOVF   FA8,W
0A36:  BTFSC  xF2.7
0A38:  BSF    FF2.7
0A3A:  MOVWF  FEF
....................    } 
0A3C:  INCF   xEE,F
0A3E:  BRA    0A0A
.................... } 
0A40:  MOVLB  0
0A42:  GOTO   0DC4 (RETURN)
....................  
....................  
.................... #include "tcpclient.c" 
.................... /********************************************************************* 
....................  * 
....................  *  TCP Client Application to send IO status notification to IOnOff server 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        tcpclient.c 
....................  * Dependencies:    tcp.h, config.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30, dsPIC33F 
....................  * Complier:        CCS 4.15 
....................  * Company:         IOnOff Technology. 
....................  * PreCondition:    Stack is initialized() 
....................  * 
....................  * Author           Date          Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * SannTran          30/06/2016      Customize from Generic TCP Client 
....................  *                            Thanks to Microchip Inc 
....................  ********************************************************************/ 
....................  
.................... #define __TCPCLIENT_C 
....................  
....................  
.................... /*********************************************************************/ 
.................... // Global variables 
....................  
.................... WORD CenterPort; 
.................... NODE_INFO Server; 
.................... BOOLEAN IsInputChanged; 
.................... BOOLEAN IsEnc28J60Reset; 
.................... int8 EncTransactioCount; 
.................... BOOLEAN IsTCPClientBusy; 
....................  
.................... // Internal variables 
.................... #define DATA_RECEIVED_LEN 32 
.................... #define CONF_SET_SRV_IP 1 
.................... #define CONF_SET_IP 2 
.................... #define CONF_SET_MASK 3 
.................... #define CONF_SET_GATE 4 
.................... #define CONF_SET_MAC 5 
....................  
.................... #define CMD_NA 0 
.................... #define CMD_IO 1 
.................... #define CMD_CF 2 
.................... #define CMD_ER 3 
....................  
.................... int8 CmdReceived; 
.................... char DataReceived[DATA_RECEIVED_LEN]; 
....................  
.................... /*********************************************************************/ 
....................  
.................... TCP_SOCKET ClientSocket = INVALID_SOCKET; 
....................  
.................... void ClientSockPut(char c) { 
....................    TCPPut(ClientSocket, c); 
*
5480:  MOVFF  1C9,20E
5484:  MOVFF  20D,20F
5488:  BRA    5336
.................... } 
548A:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPClientTask(void) 
....................  * 
....................  * PreCondition:    Stack is initialized() 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TCPClientInit() { 
....................    CenterPort = 8118; 
*
0864:  MOVLW  1F
0866:  MOVLB  1
0868:  MOVWF  x9C
086A:  MOVLW  B6
086C:  MOVWF  x9B
....................    IsTCPClientBusy = FALSE; 
086E:  MOVLB  0
0870:  BCF    x83.4
....................    IsEnc28J60Reset = TRUE; 
0872:  BSF    x83.3
....................    EncTransactioCount = 0; 
0874:  MOVLB  1
0876:  CLRF   xA7
....................    Server.IPAddr.v[0] = MY_SRV_IP_BYTES[0]; 
0878:  MOVFF  22,1A3
....................    Server.IPAddr.v[1] = MY_SRV_IP_BYTES[1]; 
087C:  MOVFF  23,1A4
....................    Server.IPAddr.v[2] = MY_SRV_IP_BYTES[2]; 
0880:  MOVFF  24,1A5
....................    Server.IPAddr.v[3] = MY_SRV_IP_BYTES[3]; 
0884:  MOVFF  25,1A6
.................... } 
0888:  MOVLB  0
088A:  RETLW  00
....................  
.................... void LCDPrintCmdUK() { 
.................... #ifdef USE_PORTD_LCD 
....................    printf(lcd_putc, "\f%s", "ER:BADCMD"); 
.................... #endif 
.................... } 
*
0006:  RETLW  00
....................  
.................... void OutSet(int8 pin, char val, int8 idx) { 
....................  
....................    if (val == '0') { 
*
5686:  MOVLB  2
5688:  MOVF   x0D,W
568A:  SUBLW  30
568C:  BNZ   56C4
....................       output_low(pin);       
568E:  MOVFF  20C,20F
5692:  CLRF   x10
5694:  MOVLW  0F
5696:  MOVWF  x12
5698:  MOVLW  89
569A:  MOVWF  x11
569C:  MOVLB  0
569E:  CALL   0E24
56A2:  MOVFF  20C,20F
56A6:  MOVLB  2
56A8:  CLRF   x10
56AA:  MOVLW  0F
56AC:  MOVWF  x12
56AE:  MOVLW  92
56B0:  MOVWF  x11
56B2:  MOVLB  0
56B4:  CALL   0E24
....................       EEPWriteOutputState(idx); 
56B8:  MOVFF  20E,20F
56BC:  CALL   46D8
....................    } 
....................    else if (val == '1') { 
56C0:  BRA    5788
56C2:  MOVLB  2
56C4:  MOVF   x0D,W
56C6:  SUBLW  31
56C8:  BNZ   5702
....................       output_high(pin); 
56CA:  MOVFF  20C,20F
56CE:  MOVLW  01
56D0:  MOVWF  x10
56D2:  MOVLW  0F
56D4:  MOVWF  x12
56D6:  MOVLW  89
56D8:  MOVWF  x11
56DA:  MOVLB  0
56DC:  CALL   0E24
56E0:  MOVFF  20C,20F
56E4:  MOVLB  2
56E6:  CLRF   x10
56E8:  MOVLW  0F
56EA:  MOVWF  x12
56EC:  MOVLW  92
56EE:  MOVWF  x11
56F0:  MOVLB  0
56F2:  CALL   0E24
....................       EEPWriteOutputState(idx); 
56F6:  MOVFF  20E,20F
56FA:  CALL   46D8
....................    } 
....................    else if (val == '2') { 
56FE:  BRA    5788
5700:  MOVLB  2
5702:  MOVF   x0D,W
5704:  SUBLW  32
5706:  BNZ   578A
....................       output_high(pin); 
5708:  MOVFF  20C,20F
570C:  MOVLW  01
570E:  MOVWF  x10
5710:  MOVLW  0F
5712:  MOVWF  x12
5714:  MOVLW  89
5716:  MOVWF  x11
5718:  MOVLB  0
571A:  CALL   0E24
571E:  MOVFF  20C,20F
5722:  MOVLB  2
5724:  CLRF   x10
5726:  MOVLW  0F
5728:  MOVWF  x12
572A:  MOVLW  92
572C:  MOVWF  x11
572E:  MOVLB  0
5730:  CALL   0E24
....................       delay_ms(920); 
5734:  MOVLW  04
5736:  MOVLB  2
5738:  MOVWF  x0F
573A:  CLRF   19
573C:  BTFSC  FF2.7
573E:  BSF    19.7
5740:  BCF    FF2.7
5742:  MOVLW  E6
5744:  MOVWF  xA9
5746:  MOVLB  0
5748:  CALL   00E6
574C:  BTFSC  19.7
574E:  BSF    FF2.7
5750:  MOVLB  2
5752:  DECFSZ x0F,F
5754:  BRA    573A
....................       output_low(pin); 
5756:  MOVFF  20C,20F
575A:  CLRF   x10
575C:  MOVLW  0F
575E:  MOVWF  x12
5760:  MOVLW  89
5762:  MOVWF  x11
5764:  MOVLB  0
5766:  CALL   0E24
576A:  MOVFF  20C,20F
576E:  MOVLB  2
5770:  CLRF   x10
5772:  MOVLW  0F
5774:  MOVWF  x12
5776:  MOVLW  92
5778:  MOVWF  x11
577A:  MOVLB  0
577C:  CALL   0E24
....................       EEPWriteOutputState(idx); 
5780:  MOVFF  20E,20F
5784:  CALL   46D8
5788:  MOVLB  2
....................    } 
.................... #ifdef USE_PORTD_LCD 
....................    if (val == '0') { 
....................       printf(lcd_putc, "\fSet OUT_%d 0", idx); 
....................    } 
....................    else if (val == '1') { 
....................       printf(lcd_putc, "\fSet OUT_%d 1", idx); 
....................    } 
....................    else if (val == '2') { 
....................       printf(lcd_putc, "\fSet OUT_%d 2", idx); 
....................    } 
.................... #endif 
.................... } 
578A:  MOVLB  0
578C:  RETLW  00
....................  
.................... // Method to set server ip, ip, subnet mask, gateway 
.................... void ConfigSet(int8 att) { 
....................    int8 idx[5], i, sep; 
....................    sep = 0; 
*
5B6E:  MOVLB  2
5B70:  CLRF   x12
....................    idx[0] = 8; // 8 is index of start ip value 
5B72:  MOVLW  08
5B74:  MOVWF  x0C
....................  
....................    for (i = idx[0]; i < DATA_RECEIVED_LEN; i++) { 
5B76:  MOVFF  20C,211
5B7A:  MOVF   x11,W
5B7C:  SUBLW  1F
5B7E:  BNC   5BE0
....................       if (DataReceived[i] == '-') { // use '-' instead of '.' 
5B80:  CLRF   03
5B82:  MOVF   x11,W
5B84:  ADDLW  A9
5B86:  MOVWF  FE9
5B88:  MOVLW  01
5B8A:  ADDWFC 03,W
5B8C:  MOVWF  FEA
5B8E:  MOVF   FEF,W
5B90:  SUBLW  2D
5B92:  BNZ   5BAE
....................          sep++; 
5B94:  INCF   x12,F
....................          if (sep <= 3) { 
5B96:  MOVF   x12,W
5B98:  SUBLW  03
5B9A:  BNC   5BAE
....................             idx[sep] = i; 
5B9C:  CLRF   03
5B9E:  MOVF   x12,W
5BA0:  ADDLW  0C
5BA2:  MOVWF  FE9
5BA4:  MOVLW  02
5BA6:  ADDWFC 03,W
5BA8:  MOVWF  FEA
5BAA:  MOVFF  211,FEF
....................          } 
....................       } 
....................       if (DataReceived[i] == '}') { 
5BAE:  CLRF   03
5BB0:  MOVF   x11,W
5BB2:  ADDLW  A9
5BB4:  MOVWF  FE9
5BB6:  MOVLW  01
5BB8:  ADDWFC 03,W
5BBA:  MOVWF  FEA
5BBC:  MOVF   FEF,W
5BBE:  SUBLW  7D
5BC0:  BNZ   5BDC
....................          sep++; 
5BC2:  INCF   x12,F
....................          if (sep <= 4) { 
5BC4:  MOVF   x12,W
5BC6:  SUBLW  04
5BC8:  BNC   5BDC
....................             idx[sep] = i; 
5BCA:  CLRF   03
5BCC:  MOVF   x12,W
5BCE:  ADDLW  0C
5BD0:  MOVWF  FE9
5BD2:  MOVLW  02
5BD4:  ADDWFC 03,W
5BD6:  MOVWF  FEA
5BD8:  MOVFF  211,FEF
....................          } 
....................       } 
....................    } 
5BDC:  INCF   x11,F
5BDE:  BRA    5B7A
....................  
....................    if  (sep != 4) { 
5BE0:  MOVF   x12,W
5BE2:  SUBLW  04
5BE4:  BZ    5BF6
....................       CmdReceived = CMD_ER; 
5BE6:  MOVLW  03
5BE8:  MOVLB  1
5BEA:  MOVWF  xA8
....................       LCDPrintCmdUK(); 
5BEC:  MOVLB  0
5BEE:  CALL   0006
....................       return; 
5BF2:  BRA    5EE0
5BF4:  MOVLB  2
....................    } 
....................  
....................    int8 b1s, b2s, b3s, b4s; 
....................    b1s = idx[1] - idx[0]; 
5BF6:  MOVF   x0C,W
5BF8:  SUBWF  x0D,W
5BFA:  MOVWF  x13
....................    b2s = idx[2] - idx[1] - 1; 
5BFC:  MOVF   x0D,W
5BFE:  SUBWF  x0E,W
5C00:  ADDLW  FF
5C02:  MOVWF  x14
....................    b3s = idx[3] - idx[2] - 1; 
5C04:  MOVF   x0E,W
5C06:  SUBWF  x0F,W
5C08:  ADDLW  FF
5C0A:  MOVWF  x15
....................    b4s = idx[4] - idx[3] - 1; 
5C0C:  MOVF   x0F,W
5C0E:  SUBWF  x10,W
5C10:  ADDLW  FF
5C12:  MOVWF  x16
....................    if (b1s > 3 || b1s == 0 || b2s > 3 || b2s == 0 || b3s > 3 || b3s == 0 
....................          || b4s > 3 || b4s == 0) { 
5C14:  MOVF   x13,W
5C16:  SUBLW  03
5C18:  BNC   5C3C
5C1A:  MOVF   x13,F
5C1C:  BZ    5C3C
5C1E:  MOVF   x14,W
5C20:  SUBLW  03
5C22:  BNC   5C3C
5C24:  MOVF   x14,F
5C26:  BZ    5C3C
5C28:  MOVF   x15,W
5C2A:  SUBLW  03
5C2C:  BNC   5C3C
5C2E:  MOVF   x15,F
5C30:  BZ    5C3C
5C32:  MOVF   x16,W
5C34:  SUBLW  03
5C36:  BNC   5C3C
5C38:  MOVF   x16,F
5C3A:  BNZ   5C4C
....................      CmdReceived = CMD_ER; 
5C3C:  MOVLW  03
5C3E:  MOVLB  1
5C40:  MOVWF  xA8
....................      LCDPrintCmdUK(); 
5C42:  MOVLB  0
5C44:  CALL   0006
....................       return; 
5C48:  BRA    5EE0
5C4A:  MOVLB  2
....................    } 
....................  
....................    char b1[4]; 
....................    char b2[4]; 
....................    char b3[4]; 
....................    char b4[4]; 
....................  
....................    for (i = 0; i < b1s; i++) { 
5C4C:  CLRF   x11
5C4E:  MOVF   x13,W
5C50:  SUBWF  x11,W
5C52:  BC    5C88
....................       b1[i] = DataReceived[i + idx[0]]; 
5C54:  CLRF   03
5C56:  MOVF   x11,W
5C58:  ADDLW  17
5C5A:  MOVWF  01
5C5C:  MOVLW  02
5C5E:  ADDWFC 03,F
5C60:  MOVFF  03,228
5C64:  MOVF   x0C,W
5C66:  ADDWF  x11,W
5C68:  CLRF   03
5C6A:  ADDLW  A9
5C6C:  MOVWF  FE9
5C6E:  MOVLW  01
5C70:  ADDWFC 03,W
5C72:  MOVWF  FEA
5C74:  MOVFF  FEF,229
5C78:  MOVFF  228,FEA
5C7C:  MOVFF  01,FE9
5C80:  MOVFF  229,FEF
....................    } 
5C84:  INCF   x11,F
5C86:  BRA    5C4E
....................    for (i = 0; i < b2s; i++) { 
5C88:  CLRF   x11
5C8A:  MOVF   x14,W
5C8C:  SUBWF  x11,W
5C8E:  BC    5CC6
....................       b2[i] = DataReceived[i + idx[1] + 1]; 
5C90:  CLRF   03
5C92:  MOVF   x11,W
5C94:  ADDLW  1B
5C96:  MOVWF  01
5C98:  MOVLW  02
5C9A:  ADDWFC 03,F
5C9C:  MOVFF  03,228
5CA0:  MOVF   x0D,W
5CA2:  ADDWF  x11,W
5CA4:  ADDLW  01
5CA6:  CLRF   03
5CA8:  ADDLW  A9
5CAA:  MOVWF  FE9
5CAC:  MOVLW  01
5CAE:  ADDWFC 03,W
5CB0:  MOVWF  FEA
5CB2:  MOVFF  FEF,229
5CB6:  MOVFF  228,FEA
5CBA:  MOVFF  01,FE9
5CBE:  MOVFF  229,FEF
....................    } 
5CC2:  INCF   x11,F
5CC4:  BRA    5C8A
....................    for (i = 0; i < b3s; i++) { 
5CC6:  CLRF   x11
5CC8:  MOVF   x15,W
5CCA:  SUBWF  x11,W
5CCC:  BC    5D04
....................       b3[i] = DataReceived[i + idx[2] + 1]; 
5CCE:  CLRF   03
5CD0:  MOVF   x11,W
5CD2:  ADDLW  1F
5CD4:  MOVWF  01
5CD6:  MOVLW  02
5CD8:  ADDWFC 03,F
5CDA:  MOVFF  03,228
5CDE:  MOVF   x0E,W
5CE0:  ADDWF  x11,W
5CE2:  ADDLW  01
5CE4:  CLRF   03
5CE6:  ADDLW  A9
5CE8:  MOVWF  FE9
5CEA:  MOVLW  01
5CEC:  ADDWFC 03,W
5CEE:  MOVWF  FEA
5CF0:  MOVFF  FEF,229
5CF4:  MOVFF  228,FEA
5CF8:  MOVFF  01,FE9
5CFC:  MOVFF  229,FEF
....................    } 
5D00:  INCF   x11,F
5D02:  BRA    5CC8
....................    for (i = 0; i < b4s; i++) { 
5D04:  CLRF   x11
5D06:  MOVF   x16,W
5D08:  SUBWF  x11,W
5D0A:  BC    5D42
....................       b4[i] = DataReceived[i + idx[3] + 1]; 
5D0C:  CLRF   03
5D0E:  MOVF   x11,W
5D10:  ADDLW  23
5D12:  MOVWF  01
5D14:  MOVLW  02
5D16:  ADDWFC 03,F
5D18:  MOVFF  03,228
5D1C:  MOVF   x0F,W
5D1E:  ADDWF  x11,W
5D20:  ADDLW  01
5D22:  CLRF   03
5D24:  ADDLW  A9
5D26:  MOVWF  FE9
5D28:  MOVLW  01
5D2A:  ADDWFC 03,W
5D2C:  MOVWF  FEA
5D2E:  MOVFF  FEF,229
5D32:  MOVFF  228,FEA
5D36:  MOVFF  01,FE9
5D3A:  MOVFF  229,FEF
....................    } 
5D3E:  INCF   x11,F
5D40:  BRA    5D06
....................  
....................    if (att == CONF_SET_SRV_IP) { 
5D42:  DECFSZ x0B,W
5D44:  BRA    5D94
....................       MyEEPRom.SrvIps[0] = atoi(b1); 
5D46:  MOVLW  02
5D48:  MOVWF  x28
5D4A:  MOVLW  17
5D4C:  MOVWF  x27
5D4E:  MOVLB  0
5D50:  RCALL  59CC
5D52:  MOVFF  01,27
....................       MyEEPRom.SrvIps[1] = atoi(b2); 
5D56:  MOVLW  02
5D58:  MOVLB  2
5D5A:  MOVWF  x28
5D5C:  MOVLW  1B
5D5E:  MOVWF  x27
5D60:  MOVLB  0
5D62:  RCALL  59CC
5D64:  MOVFF  01,28
....................       MyEEPRom.SrvIps[2] = atoi(b3); 
5D68:  MOVLW  02
5D6A:  MOVLB  2
5D6C:  MOVWF  x28
5D6E:  MOVLW  1F
5D70:  MOVWF  x27
5D72:  MOVLB  0
5D74:  RCALL  59CC
5D76:  MOVFF  01,29
....................       MyEEPRom.SrvIps[3] = atoi(b4); 
5D7A:  MOVLW  02
5D7C:  MOVLB  2
5D7E:  MOVWF  x28
5D80:  MOVLW  23
5D82:  MOVWF  x27
5D84:  MOVLB  0
5D86:  RCALL  59CC
5D88:  MOVFF  01,2A
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\n%u.%u.%u.%u", MyEEPRom.SrvIps[0], MyEEPRom.SrvIps[1], MyEEPRom.SrvIps[2], MyEEPRom.SrvIps[3]); 
.................... #endif 
....................       EEPWriteSrvIp(); 
5D8C:  CALL   0B38
....................    } 
....................    else if (att == CONF_SET_IP) { 
5D90:  BRA    5EE0
5D92:  MOVLB  2
5D94:  MOVF   x0B,W
5D96:  SUBLW  02
5D98:  BNZ   5DE8
....................       MyEEPRom.Ips[0] = atoi(b1); 
5D9A:  MOVLW  02
5D9C:  MOVWF  x28
5D9E:  MOVLW  17
5DA0:  MOVWF  x27
5DA2:  MOVLB  0
5DA4:  RCALL  59CC
5DA6:  MOVFF  01,2B
....................       MyEEPRom.Ips[1] = atoi(b2); 
5DAA:  MOVLW  02
5DAC:  MOVLB  2
5DAE:  MOVWF  x28
5DB0:  MOVLW  1B
5DB2:  MOVWF  x27
5DB4:  MOVLB  0
5DB6:  RCALL  59CC
5DB8:  MOVFF  01,2C
....................       MyEEPRom.Ips[2] = atoi(b3); 
5DBC:  MOVLW  02
5DBE:  MOVLB  2
5DC0:  MOVWF  x28
5DC2:  MOVLW  1F
5DC4:  MOVWF  x27
5DC6:  MOVLB  0
5DC8:  RCALL  59CC
5DCA:  MOVFF  01,2D
....................       MyEEPRom.Ips[3] = atoi(b4); 
5DCE:  MOVLW  02
5DD0:  MOVLB  2
5DD2:  MOVWF  x28
5DD4:  MOVLW  23
5DD6:  MOVWF  x27
5DD8:  MOVLB  0
5DDA:  RCALL  59CC
5DDC:  MOVFF  01,2E
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\n%u.%u.%u.%u", MyEEPRom.Ips[0], MyEEPRom.Ips[1], MyEEPRom.Ips[2], MyEEPRom.Ips[3]); 
.................... #endif 
....................       EEPWriteIp(); 
5DE0:  CALL   0B8E
....................    } 
....................    else if (att == CONF_SET_MASK) { 
5DE4:  BRA    5EE0
5DE6:  MOVLB  2
5DE8:  MOVF   x0B,W
5DEA:  SUBLW  03
5DEC:  BNZ   5E3C
....................       MyEEPRom.Masks[0] = atoi(b1); 
5DEE:  MOVLW  02
5DF0:  MOVWF  x28
5DF2:  MOVLW  17
5DF4:  MOVWF  x27
5DF6:  MOVLB  0
5DF8:  RCALL  59CC
5DFA:  MOVFF  01,2F
....................       MyEEPRom.Masks[1] = atoi(b2); 
5DFE:  MOVLW  02
5E00:  MOVLB  2
5E02:  MOVWF  x28
5E04:  MOVLW  1B
5E06:  MOVWF  x27
5E08:  MOVLB  0
5E0A:  RCALL  59CC
5E0C:  MOVFF  01,30
....................       MyEEPRom.Masks[2] = atoi(b3); 
5E10:  MOVLW  02
5E12:  MOVLB  2
5E14:  MOVWF  x28
5E16:  MOVLW  1F
5E18:  MOVWF  x27
5E1A:  MOVLB  0
5E1C:  RCALL  59CC
5E1E:  MOVFF  01,31
....................       MyEEPRom.Masks[3] = atoi(b4); 
5E22:  MOVLW  02
5E24:  MOVLB  2
5E26:  MOVWF  x28
5E28:  MOVLW  23
5E2A:  MOVWF  x27
5E2C:  MOVLB  0
5E2E:  RCALL  59CC
5E30:  MOVFF  01,32
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\n%u.%u.%u.%u", MyEEPRom.Masks[0], MyEEPRom.Masks[1], MyEEPRom.Masks[2], MyEEPRom.Masks[3]); 
.................... #endif 
....................       EEPWriteMask(); 
5E34:  CALL   0C3A
....................    } 
....................    else if (att == CONF_SET_GATE) { 
5E38:  BRA    5EE0
5E3A:  MOVLB  2
5E3C:  MOVF   x0B,W
5E3E:  SUBLW  04
5E40:  BNZ   5E90
....................       MyEEPRom.Gates[0] = atoi(b1); 
5E42:  MOVLW  02
5E44:  MOVWF  x28
5E46:  MOVLW  17
5E48:  MOVWF  x27
5E4A:  MOVLB  0
5E4C:  RCALL  59CC
5E4E:  MOVFF  01,33
....................       MyEEPRom.Gates[1] = atoi(b2); 
5E52:  MOVLW  02
5E54:  MOVLB  2
5E56:  MOVWF  x28
5E58:  MOVLW  1B
5E5A:  MOVWF  x27
5E5C:  MOVLB  0
5E5E:  RCALL  59CC
5E60:  MOVFF  01,34
....................       MyEEPRom.Gates[2] = atoi(b3); 
5E64:  MOVLW  02
5E66:  MOVLB  2
5E68:  MOVWF  x28
5E6A:  MOVLW  1F
5E6C:  MOVWF  x27
5E6E:  MOVLB  0
5E70:  RCALL  59CC
5E72:  MOVFF  01,35
....................       MyEEPRom.Gates[3] = atoi(b4); 
5E76:  MOVLW  02
5E78:  MOVLB  2
5E7A:  MOVWF  x28
5E7C:  MOVLW  23
5E7E:  MOVWF  x27
5E80:  MOVLB  0
5E82:  RCALL  59CC
5E84:  MOVFF  01,36
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\n%u.%u.%u.%u", MyEEPRom.Gates[0], MyEEPRom.Gates[1], MyEEPRom.Gates[2], MyEEPRom.Gates[3]); 
.................... #endif 
....................       EEPWriteGate(); 
5E88:  CALL   0BE4
....................    } 
....................  
....................    else if (att == CONF_SET_MAC) { 
5E8C:  BRA    5EE0
5E8E:  MOVLB  2
5E90:  MOVF   x0B,W
5E92:  SUBLW  05
5E94:  BNZ   5EE2
....................       // continue parsing 2 last mac bytes 
....................       // 4 bytes are the last 4 bytes of 6 bytes mac 
....................       MyEEPRom.Macs[0] = atoi(b1); 
5E96:  MOVLW  02
5E98:  MOVWF  x28
5E9A:  MOVLW  17
5E9C:  MOVWF  x27
5E9E:  MOVLB  0
5EA0:  RCALL  59CC
5EA2:  MOVFF  01,37
....................       MyEEPRom.Macs[1] = atoi(b2); 
5EA6:  MOVLW  02
5EA8:  MOVLB  2
5EAA:  MOVWF  x28
5EAC:  MOVLW  1B
5EAE:  MOVWF  x27
5EB0:  MOVLB  0
5EB2:  RCALL  59CC
5EB4:  MOVFF  01,38
....................       MyEEPRom.Macs[2] = atoi(b3); 
5EB8:  MOVLW  02
5EBA:  MOVLB  2
5EBC:  MOVWF  x28
5EBE:  MOVLW  1F
5EC0:  MOVWF  x27
5EC2:  MOVLB  0
5EC4:  RCALL  59CC
5EC6:  MOVFF  01,39
....................       MyEEPRom.Macs[3] = atoi(b4); 
5ECA:  MOVLW  02
5ECC:  MOVLB  2
5ECE:  MOVWF  x28
5ED0:  MOVLW  23
5ED2:  MOVWF  x27
5ED4:  MOVLB  0
5ED6:  RCALL  59CC
5ED8:  MOVFF  01,3A
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\n%X%X%X%X", MyEEPRom.Macs[0], MyEEPRom.Macs[1], MyEEPRom.Macs[2], MyEEPRom.Macs[3]); 
.................... #endif 
....................       EEPWriteMac(); 
5EDC:  CALL   0AB4
5EE0:  MOVLB  2
....................    } 
.................... } 
5EE2:  MOVLB  0
5EE4:  RETLW  00
....................  
.................... void InTypeSet() { 
.................... #ifdef USE_PORTD_LCD 
....................    printf(lcd_putc, "\f%s", "Set InType"); 
....................    printf(lcd_putc, "\n%s", DataReceived); 
.................... #endif 
....................    int i; 
....................    for (i = 8; i < 16; i++) { 
*
5910:  MOVLW  08
5912:  MOVLB  2
5914:  MOVWF  x0B
5916:  MOVF   x0B,W
5918:  SUBLW  0F
591A:  BNC   5972
....................       if (DataReceived[i] == '1') { 
591C:  CLRF   03
591E:  MOVF   x0B,W
5920:  ADDLW  A9
5922:  MOVWF  FE9
5924:  MOVLW  01
5926:  ADDWFC 03,W
5928:  MOVWF  FEA
592A:  MOVF   FEF,W
592C:  SUBLW  31
592E:  BNZ   5946
....................          MyEEPRom.InputTypes[i - 8] = INPUT_SWITCH; 
5930:  MOVLW  08
5932:  SUBWF  x0B,W
5934:  CLRF   03
5936:  ADDLW  3B
5938:  MOVWF  FE9
593A:  MOVLW  00
593C:  ADDWFC 03,W
593E:  MOVWF  FEA
5940:  MOVLW  01
5942:  MOVWF  FEF
....................       } 
....................       else if (DataReceived[i] == '2') { 
5944:  BRA    596E
5946:  CLRF   03
5948:  MOVF   x0B,W
594A:  ADDLW  A9
594C:  MOVWF  FE9
594E:  MOVLW  01
5950:  ADDWFC 03,W
5952:  MOVWF  FEA
5954:  MOVF   FEF,W
5956:  SUBLW  32
5958:  BNZ   596E
....................          MyEEPRom.InputTypes[i - 8] = INPUT_BUTTON; 
595A:  MOVLW  08
595C:  SUBWF  x0B,W
595E:  CLRF   03
5960:  ADDLW  3B
5962:  MOVWF  FE9
5964:  MOVLW  00
5966:  ADDWFC 03,W
5968:  MOVWF  FEA
596A:  MOVLW  02
596C:  MOVWF  FEF
....................       } 
....................    } 
596E:  INCF   x0B,F
5970:  BRA    5916
....................    EEPWriteInputTypes(); 
5972:  MOVLB  0
5974:  CALL   0C90
.................... } 
5978:  GOTO   5F74 (RETURN)
....................  
.................... void SrvSet() { 
.................... #ifdef USE_PORTD_LCD 
....................    printf(lcd_putc, "\f%s", "Set SrvIP"); 
.................... #endif 
....................    ConfigSet(CONF_SET_SRV_IP); 
*
5EE6:  MOVLW  01
5EE8:  MOVLB  2
5EEA:  MOVWF  x0B
5EEC:  MOVLB  0
5EEE:  RCALL  5B6E
.................... } 
5EF0:  GOTO   5F8C (RETURN)
....................  
.................... void IpSet() { 
.................... #ifdef USE_PORTD_LCD 
....................    printf(lcd_putc, "\f%s", "Set MyIP"); 
.................... #endif 
....................    ConfigSet(CONF_SET_IP); 
5EF4:  MOVLW  02
5EF6:  MOVLB  2
5EF8:  MOVWF  x0B
5EFA:  MOVLB  0
5EFC:  RCALL  5B6E
.................... } 
5EFE:  GOTO   5FA4 (RETURN)
....................  
.................... void MaskSet() { 
.................... #ifdef USE_PORTD_LCD 
....................    printf(lcd_putc, "\f%s", "Set SubnetMask"); 
.................... #endif 
....................    ConfigSet(CONF_SET_MASK); 
5F02:  MOVLW  03
5F04:  MOVLB  2
5F06:  MOVWF  x0B
5F08:  MOVLB  0
5F0A:  RCALL  5B6E
.................... } 
5F0C:  GOTO   5FBC (RETURN)
....................  
.................... void GateSet() { 
.................... #ifdef USE_PORTD_LCD 
....................    printf(lcd_putc, "\f%s", "Set GateWay"); 
.................... #endif 
....................    ConfigSet(CONF_SET_GATE); 
5F10:  MOVLW  04
5F12:  MOVLB  2
5F14:  MOVWF  x0B
5F16:  MOVLB  0
5F18:  RCALL  5B6E
.................... } 
5F1A:  GOTO   5FD4 (RETURN)
....................  
.................... void MacSet() { 
.................... #ifdef USE_PORTD_LCD 
....................    printf(lcd_putc, "\f%s", "Set Mac"); 
.................... #endif 
....................    ConfigSet(CONF_SET_MAC); 
5F1E:  MOVLW  05
5F20:  MOVLB  2
5F22:  MOVWF  x0B
5F24:  MOVLB  0
5F26:  RCALL  5B6E
.................... } 
5F28:  GOTO   5FEC (RETURN)
....................  
.................... BOOLEAN ObjFound(char c1, char c2) { 
....................    return DataReceived[1] == c1 && DataReceived[2] == c2; 
*
561C:  MOVLB  2
561E:  MOVF   x0B,W
5620:  MOVLB  1
5622:  SUBWF  xAA,W
5624:  BNZ   5630
5626:  MOVLB  2
5628:  MOVF   x0C,W
562A:  MOVLB  1
562C:  SUBWF  xAB,W
562E:  BZ    5634
5630:  MOVLW  00
5632:  BRA    5636
5634:  MOVLW  01
5636:  MOVWF  01
.................... } 
5638:  MOVLB  0
563A:  RETLW  00
....................  
.................... BOOLEAN CmdFound(char c1, char c2, char c3) { 
....................    return DataReceived[3] == c1 && DataReceived[4] == c2 && DataReceived[5] == c3; 
563C:  MOVLB  2
563E:  MOVF   x0C,W
5640:  MOVLB  1
5642:  SUBWF  xAC,W
5644:  BNZ   565A
5646:  MOVLB  2
5648:  MOVF   x0D,W
564A:  MOVLB  1
564C:  SUBWF  xAD,W
564E:  BNZ   565A
5650:  MOVLB  2
5652:  MOVF   x0E,W
5654:  MOVLB  1
5656:  SUBWF  xAE,W
5658:  BZ    565E
565A:  MOVLW  00
565C:  BRA    5660
565E:  MOVLW  01
5660:  MOVWF  01
.................... } 
5662:  MOVLB  0
5664:  RETLW  00
....................  
.................... BOOLEAN AttFound(char c1, char c2) { 
....................    return DataReceived[6] == c1 && DataReceived[7] == c2; 
5666:  MOVLB  2
5668:  MOVF   x0C,W
566A:  MOVLB  1
566C:  SUBWF  xAF,W
566E:  BNZ   567A
5670:  MOVLB  2
5672:  MOVF   x0D,W
5674:  MOVLB  1
5676:  SUBWF  xB0,W
5678:  BZ    567E
567A:  MOVLW  00
567C:  BRA    5680
567E:  MOVLW  01
5680:  MOVWF  01
.................... } 
5682:  MOVLB  0
5684:  RETLW  00
....................  
.................... void IOReqHandle(void) { 
....................    if (CmdFound('g', 'e', 't')) { // Check get io status 
*
578E:  MOVLW  67
5790:  MOVLB  2
5792:  MOVWF  x0C
5794:  MOVLW  65
5796:  MOVWF  x0D
5798:  MOVLW  74
579A:  MOVWF  x0E
579C:  MOVLB  0
579E:  RCALL  563C
57A0:  MOVF   01,F
57A2:  BZ    57A6
....................       // does nothing, forward to next step to return IO status 
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\f%s", "Get IO State"); 
.................... #endif 
....................    } 
....................    else if (CmdFound('s', 'e', 't')) { // Check set io status 
57A4:  BRA    590C
57A6:  MOVLW  73
57A8:  MOVLB  2
57AA:  MOVWF  x0C
57AC:  MOVLW  65
57AE:  MOVWF  x0D
57B0:  MOVLW  74
57B2:  MOVWF  x0E
57B4:  MOVLB  0
57B6:  RCALL  563C
57B8:  MOVF   01,F
57BA:  BTFSC  FD8.2
57BC:  BRA    5900
....................       char val = DataReceived[8]; 
57BE:  MOVFF  1B1,20B
....................  
....................       if (AttFound('o', '1')) { 
57C2:  MOVLW  6F
57C4:  MOVLB  2
57C6:  MOVWF  x0C
57C8:  MOVLW  31
57CA:  MOVWF  x0D
57CC:  MOVLB  0
57CE:  RCALL  5666
57D0:  MOVF   01,F
57D2:  BZ    57E8
....................          OutSet(OUT_1, val, 1); 
57D4:  MOVLW  12
57D6:  MOVLB  2
57D8:  MOVWF  x0C
57DA:  MOVFF  20B,20D
57DE:  MOVLW  01
57E0:  MOVWF  x0E
57E2:  MOVLB  0
57E4:  RCALL  5686
....................       } 
....................       else if (AttFound('o', '2')) { 
57E6:  BRA    58FE
57E8:  MOVLW  6F
57EA:  MOVLB  2
57EC:  MOVWF  x0C
57EE:  MOVLW  32
57F0:  MOVWF  x0D
57F2:  MOVLB  0
57F4:  RCALL  5666
57F6:  MOVF   01,F
57F8:  BZ    580E
....................          OutSet(OUT_2, val, 2); 
57FA:  MOVLW  11
57FC:  MOVLB  2
57FE:  MOVWF  x0C
5800:  MOVFF  20B,20D
5804:  MOVLW  02
5806:  MOVWF  x0E
5808:  MOVLB  0
580A:  RCALL  5686
....................       } 
....................       else if (AttFound('o', '3')) { 
580C:  BRA    58FE
580E:  MOVLW  6F
5810:  MOVLB  2
5812:  MOVWF  x0C
5814:  MOVLW  33
5816:  MOVWF  x0D
5818:  MOVLB  0
581A:  RCALL  5666
581C:  MOVF   01,F
581E:  BZ    5834
....................          OutSet(OUT_3, val, 3); 
5820:  MOVLW  10
5822:  MOVLB  2
5824:  MOVWF  x0C
5826:  MOVFF  20B,20D
582A:  MOVLW  03
582C:  MOVWF  x0E
582E:  MOVLB  0
5830:  RCALL  5686
....................       } 
....................       else if (AttFound('o', '4')) { 
5832:  BRA    58FE
5834:  MOVLW  6F
5836:  MOVLB  2
5838:  MOVWF  x0C
583A:  MOVLW  34
583C:  MOVWF  x0D
583E:  MOVLB  0
5840:  RCALL  5666
5842:  MOVF   01,F
5844:  BZ    585A
....................          OutSet(OUT_4, val, 4); 
5846:  MOVLW  22
5848:  MOVLB  2
584A:  MOVWF  x0C
584C:  MOVFF  20B,20D
5850:  MOVLW  04
5852:  MOVWF  x0E
5854:  MOVLB  0
5856:  RCALL  5686
....................       } 
....................       else if (AttFound('o', '5')) { 
5858:  BRA    58FE
585A:  MOVLW  6F
585C:  MOVLB  2
585E:  MOVWF  x0C
5860:  MOVLW  35
5862:  MOVWF  x0D
5864:  MOVLB  0
5866:  RCALL  5666
5868:  MOVF   01,F
586A:  BZ    5880
....................          OutSet(OUT_5, val, 5); 
586C:  MOVLW  21
586E:  MOVLB  2
5870:  MOVWF  x0C
5872:  MOVFF  20B,20D
5876:  MOVLW  05
5878:  MOVWF  x0E
587A:  MOVLB  0
587C:  RCALL  5686
....................       } 
....................       else if (AttFound('o', '6')) { 
587E:  BRA    58FE
5880:  MOVLW  6F
5882:  MOVLB  2
5884:  MOVWF  x0C
5886:  MOVLW  36
5888:  MOVWF  x0D
588A:  MOVLB  0
588C:  RCALL  5666
588E:  MOVF   01,F
5890:  BZ    58A6
....................          OutSet(OUT_6, val, 6); 
5892:  MOVLW  20
5894:  MOVLB  2
5896:  MOVWF  x0C
5898:  MOVFF  20B,20D
589C:  MOVLW  06
589E:  MOVWF  x0E
58A0:  MOVLB  0
58A2:  RCALL  5686
....................       } 
....................       else if (AttFound('o', '7')) { 
58A4:  BRA    58FE
58A6:  MOVLW  6F
58A8:  MOVLB  2
58AA:  MOVWF  x0C
58AC:  MOVLW  37
58AE:  MOVWF  x0D
58B0:  MOVLB  0
58B2:  RCALL  5666
58B4:  MOVF   01,F
58B6:  BZ    58CC
....................          OutSet(OUT_7, val, 7); 
58B8:  MOVLW  05
58BA:  MOVLB  2
58BC:  MOVWF  x0C
58BE:  MOVFF  20B,20D
58C2:  MOVLW  07
58C4:  MOVWF  x0E
58C6:  MOVLB  0
58C8:  RCALL  5686
....................       } 
....................       else if (AttFound('o', '8')) { 
58CA:  BRA    58FE
58CC:  MOVLW  6F
58CE:  MOVLB  2
58D0:  MOVWF  x0C
58D2:  MOVLW  38
58D4:  MOVWF  x0D
58D6:  MOVLB  0
58D8:  RCALL  5666
58DA:  MOVF   01,F
58DC:  BZ    58F2
....................          OutSet(OUT_8, val, 8); 
58DE:  MOVLW  04
58E0:  MOVLB  2
58E2:  MOVWF  x0C
58E4:  MOVFF  20B,20D
58E8:  MOVLW  08
58EA:  MOVWF  x0E
58EC:  MOVLB  0
58EE:  RCALL  5686
....................       } 
....................       else { 
58F0:  BRA    58FE
....................          CmdReceived = CMD_ER; 
58F2:  MOVLW  03
58F4:  MOVLB  1
58F6:  MOVWF  xA8
....................          LCDPrintCmdUK(); 
58F8:  MOVLB  0
58FA:  CALL   0006
....................       } 
....................    } 
....................    else { 
58FE:  BRA    590C
....................       CmdReceived = CMD_ER; 
5900:  MOVLW  03
5902:  MOVLB  1
5904:  MOVWF  xA8
....................       LCDPrintCmdUK(); 
5906:  MOVLB  0
5908:  CALL   0006
....................    } 
.................... } 
590C:  GOTO   6AC2 (RETURN)
....................  
.................... void TCPLedOn() { 
....................    output_low(OUT_TCP_STATE); 
*
4F9A:  BCF    F93.4
4F9C:  BCF    F8A.4
.................... } 
4F9E:  RETLW  00
....................  
.................... void TCPLedOff() { 
....................    output_high(OUT_TCP_STATE); 
*
0E1E:  BCF    F93.4
0E20:  BSF    F8A.4
.................... } 
0E22:  RETLW  00
....................  
.................... void CfReqHandle(void) { 
....................    if (CmdFound('g', 'e', 't')) { // Check to get configs 
*
5F2C:  MOVLW  67
5F2E:  MOVLB  2
5F30:  MOVWF  x0C
5F32:  MOVLW  65
5F34:  MOVWF  x0D
5F36:  MOVLW  74
5F38:  MOVWF  x0E
5F3A:  MOVLB  0
5F3C:  CALL   563C
5F40:  MOVF   01,F
5F42:  BZ    5F46
....................       // Go to next step to return configs 
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\f%s", "Get Config"); 
.................... #endif 
....................    } 
....................    else if (CmdFound('s', 'e', 't')) { // Check to set configs 
5F44:  BRA    6008
5F46:  MOVLW  73
5F48:  MOVLB  2
5F4A:  MOVWF  x0C
5F4C:  MOVLW  65
5F4E:  MOVWF  x0D
5F50:  MOVLW  74
5F52:  MOVWF  x0E
5F54:  MOVLB  0
5F56:  CALL   563C
5F5A:  MOVF   01,F
5F5C:  BZ    5FFC
....................       if (AttFound('i', 'n')) { // Set input type switch / button 
5F5E:  MOVLW  69
5F60:  MOVLB  2
5F62:  MOVWF  x0C
5F64:  MOVLW  6E
5F66:  MOVWF  x0D
5F68:  MOVLB  0
5F6A:  CALL   5666
5F6E:  MOVF   01,F
5F70:  BZ    5F76
....................          InTypeSet(); 
5F72:  BRA    5910
....................       } 
....................       else if (AttFound('s', 'v')) { // Set ionoff server ip 
5F74:  BRA    5FFA
5F76:  MOVLW  73
5F78:  MOVLB  2
5F7A:  MOVWF  x0C
5F7C:  MOVLW  76
5F7E:  MOVWF  x0D
5F80:  MOVLB  0
5F82:  CALL   5666
5F86:  MOVF   01,F
5F88:  BZ    5F8E
....................          SrvSet();          
5F8A:  BRA    5EE6
....................       } 
....................       else if (AttFound('i', 'p')) { // Set my board ip 
5F8C:  BRA    5FFA
5F8E:  MOVLW  69
5F90:  MOVLB  2
5F92:  MOVWF  x0C
5F94:  MOVLW  70
5F96:  MOVWF  x0D
5F98:  MOVLB  0
5F9A:  CALL   5666
5F9E:  MOVF   01,F
5FA0:  BZ    5FA6
....................          IpSet(); 
5FA2:  BRA    5EF4
....................       } 
....................       else if (AttFound('s', 'm')) { // Set subnet mask 
5FA4:  BRA    5FFA
5FA6:  MOVLW  73
5FA8:  MOVLB  2
5FAA:  MOVWF  x0C
5FAC:  MOVLW  6D
5FAE:  MOVWF  x0D
5FB0:  MOVLB  0
5FB2:  CALL   5666
5FB6:  MOVF   01,F
5FB8:  BZ    5FBE
....................          MaskSet(); 
5FBA:  BRA    5F02
....................       } 
....................       else if (AttFound('g', 'w')) { // Set gate way 
5FBC:  BRA    5FFA
5FBE:  MOVLW  67
5FC0:  MOVLB  2
5FC2:  MOVWF  x0C
5FC4:  MOVLW  77
5FC6:  MOVWF  x0D
5FC8:  MOVLB  0
5FCA:  CALL   5666
5FCE:  MOVF   01,F
5FD0:  BZ    5FD6
....................          GateSet(); 
5FD2:  BRA    5F10
....................       } 
....................       else if (AttFound('m', 'a')) { // Set gate way 
5FD4:  BRA    5FFA
5FD6:  MOVLW  6D
5FD8:  MOVLB  2
5FDA:  MOVWF  x0C
5FDC:  MOVLW  61
5FDE:  MOVWF  x0D
5FE0:  MOVLB  0
5FE2:  CALL   5666
5FE6:  MOVF   01,F
5FE8:  BZ    5FEE
....................          MacSet(); 
5FEA:  BRA    5F1E
....................       } 
....................       else { 
5FEC:  BRA    5FFA
....................          CmdReceived = CMD_ER; 
5FEE:  MOVLW  03
5FF0:  MOVLB  1
5FF2:  MOVWF  xA8
....................          LCDPrintCmdUK(); 
5FF4:  MOVLB  0
5FF6:  CALL   0006
....................       } 
....................    } 
....................    else { 
5FFA:  BRA    6008
....................       CmdReceived = CMD_ER; 
5FFC:  MOVLW  03
5FFE:  MOVLB  1
6000:  MOVWF  xA8
....................       LCDPrintCmdUK(); 
6002:  MOVLB  0
6004:  CALL   0006
....................    } 
.................... } 
6008:  GOTO   6AE2 (RETURN)
....................  
.................... void TCPClientTask(void) { 
....................     
....................    char BuffC; 
....................    int8 BuffI; 
....................    static int8 ARPCheckResolved; 
....................    static int8 TCPCheckConnected; 
....................    static TICKTYPE Timer;    
....................  
....................    static enum { 
....................       SM_HOME = 0, 
....................       SM_ARP_START_RESOLVE = 1, 
....................       SM_ARP_RESOLVE = 2, 
....................       SM_SOCKET_OBTAIN = 3, 
....................       SM_SOCKET_OBTAINED = 4, 
....................       SM_PROCESS_RESPONSE = 5, 
....................       SM_DISCONNECT = 6, 
....................       SM_DONE = 7 
....................    } TCPClientState = SM_HOME; 
....................   
....................    switch (TCPClientState) { 
*
6198:  MOVLB  1
619A:  MOVF   xCE,W
619C:  ADDLW  F8
619E:  BTFSC  FD8.0
61A0:  GOTO   6B30
61A4:  ADDLW  08
61A6:  MOVLB  0
61A8:  GOTO   6B36
....................    case SM_HOME:       
....................       ARPCheckResolved = 0; 
61AC:  MOVLB  1
61AE:  CLRF   xCA
....................       TCPCheckConnected = 0; 
61B0:  CLRF   xCB
....................       IsTCPClientBusy = FALSE; 
61B2:  MOVLB  0
61B4:  BCF    x83.4
....................       CmdReceived = CMD_NA; 
61B6:  MOVLB  1
61B8:  CLRF   xA8
....................       TCPClientState = SM_ARP_START_RESOLVE; 
61BA:  MOVLW  01
61BC:  MOVWF  xCE
....................       EncTransactioCount = EncTransactioCount + 1; 
61BE:  ADDWF  xA7,F
....................       break; 
61C0:  GOTO   6B30
....................  
....................    case SM_ARP_START_RESOLVE: 
....................       // Obtain the MAC address associated with the server's IP address 
....................       // (either direct MAC address on same subnet, or the MAC address of the Gateway machine) 
....................       ARPResolve(&Server.IPAddr); 
61C4:  MOVLW  01
61C6:  MOVLB  2
61C8:  MOVWF  x0C
61CA:  MOVLW  A3
61CC:  MOVWF  x0B
61CE:  MOVLB  0
61D0:  GOTO   4C90
....................       Timer = TickGet(); 
61D4:  CALL   10B0
61D8:  MOVFF  02,1CD
61DC:  MOVFF  01,1CC
....................       TCPClientState = SM_ARP_RESOLVE; 
61E0:  MOVLW  02
61E2:  MOVLB  1
61E4:  MOVWF  xCE
....................       break; 
61E6:  GOTO   6B30
....................  
....................    case SM_ARP_RESOLVE: 
....................        
....................       // Wait for the MAC address to finish being obtained 
....................       if (!ARPIsResolved(&Server.IPAddr, &Server.MACAddr)) { 
61EA:  MOVLW  01
61EC:  MOVLB  2
61EE:  MOVWF  x0C
61F0:  MOVLW  A3
61F2:  MOVWF  x0B
61F4:  MOVLW  01
61F6:  MOVWF  x0E
61F8:  MOVLW  9D
61FA:  MOVWF  x0D
61FC:  MOVLB  0
61FE:  GOTO   4CD0
6202:  MOVF   01,F
6204:  BNZ   6246
....................          // Time out if too much time is spent in this state 
....................          if (TickGet() - Timer > 3 * TICK_SECOND) {             
6206:  CALL   10B0
620A:  MOVFF  02,20C
620E:  MOVFF  01,20B
6212:  MOVLB  1
6214:  MOVF   xCC,W
6216:  MOVLB  2
6218:  SUBWF  x0B,F
621A:  MOVLB  1
621C:  MOVF   xCD,W
621E:  MOVLB  2
6220:  SUBWFB x0C,F
6222:  BNZ   622A
6224:  MOVF   x0B,W
6226:  SUBLW  24
6228:  BC    623E
....................             if (ARPCheckResolved >= 3) { 
622A:  MOVLB  1
622C:  MOVF   xCA,W
622E:  SUBLW  02
6230:  BC    6238
.................... #ifdef USE_PORTD_LCD 
....................                printf(lcd_putc, "\f%s", "ARPNotResolved/"); 
.................... #endif 
....................                TCPClientState = SM_DONE; // ignore sending this notification 
6232:  MOVLW  07
6234:  MOVWF  xCE
....................             } 
....................             else { 
6236:  BRA    623C
.................... #ifdef USE_PORTD_LCD 
....................                printf(lcd_putc, "\f%s", "ARPNotResolved+"); 
.................... #endif 
....................                TCPClientState = SM_ARP_START_RESOLVE; // try to reconnect 
6238:  MOVLW  01
623A:  MOVWF  xCE
....................             } 
....................             ARPCheckResolved ++; 
623C:  INCF   xCA,F
....................          } 
....................          break; 
623E:  MOVLB  1
6240:  GOTO   6B30
6244:  MOVLB  0
....................       } 
....................       Timer = TickGet(); 
6246:  CALL   10B0
624A:  MOVFF  02,1CD
624E:  MOVFF  01,1CC
....................       TCPClientState = SM_SOCKET_OBTAIN; 
6252:  MOVLW  03
6254:  MOVLB  1
6256:  MOVWF  xCE
....................       break; 
6258:  GOTO   6B30
....................  
....................    case SM_SOCKET_OBTAIN: 
....................        
....................       // Connect a socket to the remote TCP server 
....................       ClientSocket = TCPConnect(&Server, CenterPort); 
625C:  MOVLW  01
625E:  MOVLB  2
6260:  MOVWF  x0C
6262:  MOVLW  9D
6264:  MOVWF  x0B
6266:  MOVFF  19C,20E
626A:  MOVFF  19B,20D
626E:  MOVLB  0
6270:  GOTO   4D52
6274:  MOVFF  01,1C9
....................       // Abort operation if no TCP sockets are available 
....................       // If this ever happens, incrementing MAX_TCP_SOCKETS in 
....................       // stacktsk.h may help (at the expense of more global memory 
....................       // resources). 
....................       if (ClientSocket == INVALID_SOCKET) { 
6278:  MOVLB  1
627A:  MOVF   xC9,W
627C:  SUBLW  FE
627E:  BNZ   62B2
....................          if (TickGet() - Timer > 3 * TICK_SECOND) { 
6280:  MOVLB  0
6282:  CALL   10B0
6286:  MOVFF  02,20C
628A:  MOVFF  01,20B
628E:  MOVLB  1
6290:  MOVF   xCC,W
6292:  MOVLB  2
6294:  SUBWF  x0B,F
6296:  MOVLB  1
6298:  MOVF   xCD,W
629A:  MOVLB  2
629C:  SUBWFB x0C,F
629E:  BNZ   62A6
62A0:  MOVF   x0B,W
62A2:  SUBLW  24
62A4:  BC    62AC
.................... #ifdef USE_PORTD_LCD 
....................             printf(lcd_putc, "\f%s", "TCPConnectFailed"); 
.................... #endif   
....................             TCPClientState = SM_DONE;          
62A6:  MOVLW  07
62A8:  MOVLB  1
62AA:  MOVWF  xCE
....................          } 
....................          break; 
62AC:  MOVLB  1
62AE:  GOTO   6B30
....................       } 
....................       TCPClientState = SM_SOCKET_OBTAINED; 
62B2:  MOVLW  04
62B4:  MOVWF  xCE
....................       Timer = TickGet(); 
62B6:  MOVLB  0
62B8:  CALL   10B0
62BC:  MOVFF  02,1CD
62C0:  MOVFF  01,1CC
....................       break; 
62C4:  MOVLB  1
62C6:  GOTO   6B30
....................  
....................    case SM_SOCKET_OBTAINED: 
....................       // Wait for the remote server to accept connection request 
....................       if (!TCPIsConnected(ClientSocket)) { 
62CA:  MOVFF  1C9,20B
62CE:  CALL   4F70
62D2:  MOVF   01,F
62D4:  BNZ   630C
....................          // Time out if too much time is spent in this state 
....................          if (TickGet() - Timer > 3 * TICK_SECOND) { 
62D6:  CALL   10B0
62DA:  MOVFF  02,20C
62DE:  MOVFF  01,20B
62E2:  MOVLB  1
62E4:  MOVF   xCC,W
62E6:  MOVLB  2
62E8:  SUBWF  x0B,F
62EA:  MOVLB  1
62EC:  MOVF   xCD,W
62EE:  MOVLB  2
62F0:  SUBWFB x0C,F
62F2:  BNZ   62FA
62F4:  MOVF   x0B,W
62F6:  SUBLW  24
62F8:  BC    6304
....................             TCPClientState = SM_DISCONNECT; 
62FA:  MOVLW  06
62FC:  MOVLB  1
62FE:  MOVWF  xCE
....................             break;            
6300:  GOTO   6B30
....................          } 
....................          break; 
6304:  MOVLB  1
6306:  GOTO   6B30
630A:  MOVLB  0
....................       } 
....................      TCPLedOn(); 
630C:  CALL   4F9A
....................       IsTCPClientBusy = TRUE; 
6310:  BSF    x83.4
....................        
....................        
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\f%s", "TCPNowConnected."); 
.................... #endif 
....................       // Make certain the socket can be written to 
....................       if (!TCPIsPutReady(ClientSocket)) { 
6312:  MOVFF  1C9,20B
6316:  GOTO   4FA0
631A:  MOVF   01,F
631C:  BNZ   6326
....................          break; 
631E:  MOVLB  1
6320:  GOTO   6B30
6324:  MOVLB  0
....................       } 
....................       char ioStates[18]; 
....................        
....................       if (CmdReceived == CMD_NA || CmdReceived == CMD_IO) { 
6326:  MOVLB  1
6328:  MOVF   xA8,F
632A:  BZ    6330
632C:  DECFSZ xA8,W
632E:  BRA    66C6
....................          // Place the data into the transmit buffer. 
....................          sprintf(ioStates, "%d%d%d%d%d%d%d%d,%d%d%d%d%d%d%d%d", 
....................                input_state(IN_1), input_state(IN_2), input_state(IN_3), 
....................                input_state(IN_4), input_state(IN_5), input_state(IN_6), 
....................                input_state(IN_7), input_state(IN_8), 
....................                input_state(OUT_1), 
....................                input_state(OUT_2), input_state(OUT_3), input_state(OUT_4), 
....................                input_state(OUT_5), input_state(OUT_6), input_state(OUT_7), 
....................                input_state(OUT_8)); 
6330:  MOVLW  00
6332:  BTFSC  F82.4
6334:  MOVLW  01
6336:  MOVLB  2
6338:  MOVWF  x0B
633A:  MOVLW  00
633C:  BTFSC  F82.5
633E:  MOVLW  01
6340:  MOVWF  x0C
6342:  MOVLW  00
6344:  BTFSC  F83.5
6346:  MOVLW  01
6348:  MOVWF  x0D
634A:  MOVLW  00
634C:  BTFSC  F83.6
634E:  MOVLW  01
6350:  MOVWF  x0E
6352:  MOVLW  00
6354:  BTFSC  F83.7
6356:  MOVLW  01
6358:  MOVWF  x0F
635A:  MOVLW  00
635C:  BTFSC  F81.0
635E:  MOVLW  01
6360:  MOVWF  x10
6362:  MOVLW  00
6364:  BTFSC  F81.1
6366:  MOVLW  01
6368:  MOVWF  x11
636A:  MOVLW  00
636C:  BTFSC  F81.2
636E:  MOVLW  01
6370:  MOVWF  x12
6372:  MOVLW  00
6374:  BTFSC  F82.2
6376:  MOVLW  01
6378:  MOVWF  x13
637A:  MOVLW  00
637C:  BTFSC  F82.1
637E:  MOVLW  01
6380:  MOVWF  x14
6382:  MOVLW  00
6384:  BTFSC  F82.0
6386:  MOVLW  01
6388:  MOVWF  x15
638A:  MOVLW  00
638C:  BTFSC  F84.2
638E:  MOVLW  01
6390:  MOVWF  x16
6392:  MOVLW  00
6394:  BTFSC  F84.1
6396:  MOVLW  01
6398:  MOVWF  x17
639A:  MOVLW  00
639C:  BTFSC  F84.0
639E:  MOVLW  01
63A0:  MOVWF  x18
63A2:  MOVLW  00
63A4:  BTFSC  F80.5
63A6:  MOVLW  01
63A8:  MOVWF  x19
63AA:  MOVLW  00
63AC:  BTFSC  F80.4
63AE:  MOVLW  01
63B0:  MOVWF  x1A
63B2:  MOVLW  01
63B4:  MOVLB  1
63B6:  MOVWF  xD0
63B8:  MOVLW  F0
63BA:  MOVWF  xCF
63BC:  MOVFF  20B,21B
63C0:  MOVLW  1F
63C2:  MOVLB  2
63C4:  MOVWF  x1C
63C6:  MOVLB  0
63C8:  CALL   508E
63CC:  MOVFF  20C,21B
63D0:  MOVLW  1F
63D2:  MOVLB  2
63D4:  MOVWF  x1C
63D6:  MOVLB  0
63D8:  CALL   508E
63DC:  MOVFF  20D,21B
63E0:  MOVLW  1F
63E2:  MOVLB  2
63E4:  MOVWF  x1C
63E6:  MOVLB  0
63E8:  CALL   508E
63EC:  MOVFF  20E,21B
63F0:  MOVLW  1F
63F2:  MOVLB  2
63F4:  MOVWF  x1C
63F6:  MOVLB  0
63F8:  CALL   508E
63FC:  MOVFF  20F,21B
6400:  MOVLW  1F
6402:  MOVLB  2
6404:  MOVWF  x1C
6406:  MOVLB  0
6408:  CALL   508E
640C:  MOVFF  210,21B
6410:  MOVLW  1F
6412:  MOVLB  2
6414:  MOVWF  x1C
6416:  MOVLB  0
6418:  CALL   508E
641C:  MOVFF  211,21B
6420:  MOVLW  1F
6422:  MOVLB  2
6424:  MOVWF  x1C
6426:  MOVLB  0
6428:  CALL   508E
642C:  MOVFF  212,21B
6430:  MOVLW  1F
6432:  MOVLB  2
6434:  MOVWF  x1C
6436:  MOVLB  0
6438:  CALL   508E
643C:  MOVLW  2C
643E:  MOVLB  2
6440:  MOVWF  x21
6442:  MOVLB  0
6444:  CALL   506C
6448:  MOVFF  213,21B
644C:  MOVLW  1F
644E:  MOVLB  2
6450:  MOVWF  x1C
6452:  MOVLB  0
6454:  CALL   508E
6458:  MOVFF  214,21B
645C:  MOVLW  1F
645E:  MOVLB  2
6460:  MOVWF  x1C
6462:  MOVLB  0
6464:  CALL   508E
6468:  MOVFF  215,21B
646C:  MOVLW  1F
646E:  MOVLB  2
6470:  MOVWF  x1C
6472:  MOVLB  0
6474:  CALL   508E
6478:  MOVFF  216,21B
647C:  MOVLW  1F
647E:  MOVLB  2
6480:  MOVWF  x1C
6482:  MOVLB  0
6484:  CALL   508E
6488:  MOVFF  217,21B
648C:  MOVLW  1F
648E:  MOVLB  2
6490:  MOVWF  x1C
6492:  MOVLB  0
6494:  CALL   508E
6498:  MOVFF  218,21B
649C:  MOVLW  1F
649E:  MOVLB  2
64A0:  MOVWF  x1C
64A2:  MOVLB  0
64A4:  CALL   508E
64A8:  MOVFF  219,21B
64AC:  MOVLW  1F
64AE:  MOVLB  2
64B0:  MOVWF  x1C
64B2:  MOVLB  0
64B4:  CALL   508E
64B8:  MOVFF  21A,21B
64BC:  MOVLW  1F
64BE:  MOVLB  2
64C0:  MOVWF  x1C
64C2:  MOVLB  0
64C4:  CALL   508E
....................          if (CmdReceived == CMD_NA) { 
64C8:  MOVLB  1
64CA:  MOVF   xA8,F
64CC:  BTFSS  FD8.2
64CE:  BRA    6686
....................             if (IsEnc28J60Reset == TRUE){ 
64D0:  MOVLB  0
64D2:  BTFSS  x83.3
64D4:  BRA    6560
....................                printf(ClientSockPut, "RS:%s,%X%X%X%X\n", ioStates, MY_MAC_BYTE3, MY_MAC_BYTE4, MY_MAC_BYTE5, MY_MAC_BYTE6); 
64D6:  MOVLW  52
64D8:  MOVLB  2
64DA:  MOVWF  x0D
64DC:  MOVLB  0
64DE:  CALL   5480
64E2:  MOVLW  53
64E4:  MOVLB  2
64E6:  MOVWF  x0D
64E8:  MOVLB  0
64EA:  CALL   5480
64EE:  MOVLW  3A
64F0:  MOVLB  2
64F2:  MOVWF  x0D
64F4:  MOVLB  0
64F6:  CALL   5480
64FA:  MOVLW  01
64FC:  MOVWF  FEA
64FE:  MOVLW  F0
6500:  MOVWF  FE9
6502:  CALL   548C
6506:  MOVLW  2C
6508:  MOVLB  2
650A:  MOVWF  x0D
650C:  MOVLB  0
650E:  CALL   5480
6512:  MOVFF  49,20B
6516:  MOVLW  37
6518:  MOVLB  2
651A:  MOVWF  x0C
651C:  MOVLB  0
651E:  CALL   54B0
6522:  MOVFF  4A,20B
6526:  MOVLW  37
6528:  MOVLB  2
652A:  MOVWF  x0C
652C:  MOVLB  0
652E:  CALL   54B0
6532:  MOVFF  4B,20B
6536:  MOVLW  37
6538:  MOVLB  2
653A:  MOVWF  x0C
653C:  MOVLB  0
653E:  CALL   54B0
6542:  MOVFF  4C,20B
6546:  MOVLW  37
6548:  MOVLB  2
654A:  MOVWF  x0C
654C:  MOVLB  0
654E:  CALL   54B0
6552:  MOVLW  0A
6554:  MOVLB  2
6556:  MOVWF  x0D
6558:  MOVLB  0
655A:  CALL   5480
....................             }       
....................             else if (IsInputChanged == TRUE){ 
655E:  BRA    6676
6560:  BTFSS  x83.2
6562:  BRA    65EE
....................                printf(ClientSockPut, "CH:%s,%X%X%X%X\n", ioStates, MY_MAC_BYTE3, MY_MAC_BYTE4, MY_MAC_BYTE5, MY_MAC_BYTE6); 
6564:  MOVLW  43
6566:  MOVLB  2
6568:  MOVWF  x0D
656A:  MOVLB  0
656C:  CALL   5480
6570:  MOVLW  48
6572:  MOVLB  2
6574:  MOVWF  x0D
6576:  MOVLB  0
6578:  CALL   5480
657C:  MOVLW  3A
657E:  MOVLB  2
6580:  MOVWF  x0D
6582:  MOVLB  0
6584:  CALL   5480
6588:  MOVLW  01
658A:  MOVWF  FEA
658C:  MOVLW  F0
658E:  MOVWF  FE9
6590:  CALL   548C
6594:  MOVLW  2C
6596:  MOVLB  2
6598:  MOVWF  x0D
659A:  MOVLB  0
659C:  CALL   5480
65A0:  MOVFF  49,20B
65A4:  MOVLW  37
65A6:  MOVLB  2
65A8:  MOVWF  x0C
65AA:  MOVLB  0
65AC:  CALL   54B0
65B0:  MOVFF  4A,20B
65B4:  MOVLW  37
65B6:  MOVLB  2
65B8:  MOVWF  x0C
65BA:  MOVLB  0
65BC:  CALL   54B0
65C0:  MOVFF  4B,20B
65C4:  MOVLW  37
65C6:  MOVLB  2
65C8:  MOVWF  x0C
65CA:  MOVLB  0
65CC:  CALL   54B0
65D0:  MOVFF  4C,20B
65D4:  MOVLW  37
65D6:  MOVLB  2
65D8:  MOVWF  x0C
65DA:  MOVLB  0
65DC:  CALL   54B0
65E0:  MOVLW  0A
65E2:  MOVLB  2
65E4:  MOVWF  x0D
65E6:  MOVLB  0
65E8:  CALL   5480
....................             } 
....................             else { 
65EC:  BRA    6676
....................                printf(ClientSockPut, "ST:%s,%X%X%X%X\n", ioStates, MY_MAC_BYTE3, MY_MAC_BYTE4, MY_MAC_BYTE5, MY_MAC_BYTE6); 
65EE:  MOVLW  53
65F0:  MOVLB  2
65F2:  MOVWF  x0D
65F4:  MOVLB  0
65F6:  CALL   5480
65FA:  MOVLW  54
65FC:  MOVLB  2
65FE:  MOVWF  x0D
6600:  MOVLB  0
6602:  CALL   5480
6606:  MOVLW  3A
6608:  MOVLB  2
660A:  MOVWF  x0D
660C:  MOVLB  0
660E:  CALL   5480
6612:  MOVLW  01
6614:  MOVWF  FEA
6616:  MOVLW  F0
6618:  MOVWF  FE9
661A:  CALL   548C
661E:  MOVLW  2C
6620:  MOVLB  2
6622:  MOVWF  x0D
6624:  MOVLB  0
6626:  CALL   5480
662A:  MOVFF  49,20B
662E:  MOVLW  37
6630:  MOVLB  2
6632:  MOVWF  x0C
6634:  MOVLB  0
6636:  CALL   54B0
663A:  MOVFF  4A,20B
663E:  MOVLW  37
6640:  MOVLB  2
6642:  MOVWF  x0C
6644:  MOVLB  0
6646:  CALL   54B0
664A:  MOVFF  4B,20B
664E:  MOVLW  37
6650:  MOVLB  2
6652:  MOVWF  x0C
6654:  MOVLB  0
6656:  CALL   54B0
665A:  MOVFF  4C,20B
665E:  MOVLW  37
6660:  MOVLB  2
6662:  MOVWF  x0C
6664:  MOVLB  0
6666:  CALL   54B0
666A:  MOVLW  0A
666C:  MOVLB  2
666E:  MOVWF  x0D
6670:  MOVLB  0
6672:  CALL   5480
....................             } 
....................             if (IsInputChanged == TRUE){ 
6676:  BTFSS  x83.2
6678:  BRA    667C
....................                IsInputChanged = FALSE; 
667A:  BCF    x83.2
....................             } 
....................             if (IsEnc28J60Reset == TRUE){ 
667C:  BTFSS  x83.3
667E:  BRA    6682
....................                IsEnc28J60Reset = FALSE; 
6680:  BCF    x83.3
....................             } 
....................          } 
....................           
....................          else { // CmdReceived == CMD_IO  
6682:  BRA    66C2
6684:  MOVLB  1
....................             printf(ClientSockPut, "IO:%s\n", ioStates); 
6686:  MOVLW  49
6688:  MOVLB  2
668A:  MOVWF  x0D
668C:  MOVLB  0
668E:  CALL   5480
6692:  MOVLW  4F
6694:  MOVLB  2
6696:  MOVWF  x0D
6698:  MOVLB  0
669A:  CALL   5480
669E:  MOVLW  3A
66A0:  MOVLB  2
66A2:  MOVWF  x0D
66A4:  MOVLB  0
66A6:  CALL   5480
66AA:  MOVLW  01
66AC:  MOVWF  FEA
66AE:  MOVLW  F0
66B0:  MOVWF  FE9
66B2:  CALL   548C
66B6:  MOVLW  0A
66B8:  MOVLB  2
66BA:  MOVWF  x0D
66BC:  MOVLB  0
66BE:  CALL   5480
....................          }          
....................       } 
....................       else if (CmdReceived == CMD_CF) { 
66C2:  BRA    69D0
66C4:  MOVLB  1
66C6:  MOVF   xA8,W
66C8:  SUBLW  02
66CA:  BTFSS  FD8.2
66CC:  BRA    69C2
....................          char inputTypes[9]; 
....................          sprintf(inputTypes, "%d%d%d%d%d%d%d%d", 
....................                MyEEPRom.InputTypes[0], MyEEPRom.InputTypes[1], MyEEPRom.InputTypes[2], MyEEPRom.InputTypes[3], 
....................                MyEEPRom.InputTypes[4], MyEEPRom.InputTypes[5], MyEEPRom.InputTypes[6], MyEEPRom.InputTypes[7]); 
66CE:  MOVLW  02
66D0:  MOVWF  xD0
66D2:  MOVWF  xCF
66D4:  MOVFF  3B,21B
66D8:  MOVLW  1F
66DA:  MOVLB  2
66DC:  MOVWF  x1C
66DE:  MOVLB  0
66E0:  CALL   508E
66E4:  MOVFF  3C,21B
66E8:  MOVLW  1F
66EA:  MOVLB  2
66EC:  MOVWF  x1C
66EE:  MOVLB  0
66F0:  CALL   508E
66F4:  MOVFF  3D,21B
66F8:  MOVLW  1F
66FA:  MOVLB  2
66FC:  MOVWF  x1C
66FE:  MOVLB  0
6700:  CALL   508E
6704:  MOVFF  3E,21B
6708:  MOVLW  1F
670A:  MOVLB  2
670C:  MOVWF  x1C
670E:  MOVLB  0
6710:  CALL   508E
6714:  MOVFF  3F,21B
6718:  MOVLW  1F
671A:  MOVLB  2
671C:  MOVWF  x1C
671E:  MOVLB  0
6720:  CALL   508E
6724:  MOVFF  40,21B
6728:  MOVLW  1F
672A:  MOVLB  2
672C:  MOVWF  x1C
672E:  MOVLB  0
6730:  CALL   508E
6734:  MOVFF  41,21B
6738:  MOVLW  1F
673A:  MOVLB  2
673C:  MOVWF  x1C
673E:  MOVLB  0
6740:  CALL   508E
6744:  MOVFF  42,21B
6748:  MOVLW  1F
674A:  MOVLB  2
674C:  MOVWF  x1C
674E:  MOVLB  0
6750:  CALL   508E
....................          printf(ClientSockPut, 
....................             "CF:%X.%X.%X.%X,%X.%X.%X.%X,%X.%X.%X.%X,%X.%X.%X.%X,%X-%X-%X-%X,%s\n", 
....................             MyEEPRom.SrvIps[0], MyEEPRom.SrvIps[1], MyEEPRom.SrvIps[2], MyEEPRom.SrvIps[3], 
....................             MyEEPRom.Ips[0], MyEEPRom.Ips[1], MyEEPRom.Ips[2], MyEEPRom.Ips[3], 
....................             MyEEPRom.Masks[0], MyEEPRom.Masks[1], MyEEPRom.Masks[2], MyEEPRom.Masks[3],  
....................             MyEEPRom.Gates[0], MyEEPRom.Gates[1], MyEEPRom.Gates[2], MyEEPRom.Gates[3], 
....................             // Just send mac from byte 3 to 6 
....................             MyEEPRom.Macs[0], MyEEPRom.Macs[1], MyEEPRom.Macs[2], MyEEPRom.Macs[3], 
....................             inputTypes); 
6754:  MOVLW  43
6756:  MOVLB  2
6758:  MOVWF  x0D
675A:  MOVLB  0
675C:  CALL   5480
6760:  MOVLW  46
6762:  MOVLB  2
6764:  MOVWF  x0D
6766:  MOVLB  0
6768:  CALL   5480
676C:  MOVLW  3A
676E:  MOVLB  2
6770:  MOVWF  x0D
6772:  MOVLB  0
6774:  CALL   5480
6778:  MOVFF  27,20B
677C:  MOVLW  37
677E:  MOVLB  2
6780:  MOVWF  x0C
6782:  MOVLB  0
6784:  CALL   54B0
6788:  MOVLW  2E
678A:  MOVLB  2
678C:  MOVWF  x0D
678E:  MOVLB  0
6790:  CALL   5480
6794:  MOVFF  28,20B
6798:  MOVLW  37
679A:  MOVLB  2
679C:  MOVWF  x0C
679E:  MOVLB  0
67A0:  CALL   54B0
67A4:  MOVLW  2E
67A6:  MOVLB  2
67A8:  MOVWF  x0D
67AA:  MOVLB  0
67AC:  CALL   5480
67B0:  MOVFF  29,20B
67B4:  MOVLW  37
67B6:  MOVLB  2
67B8:  MOVWF  x0C
67BA:  MOVLB  0
67BC:  CALL   54B0
67C0:  MOVLW  2E
67C2:  MOVLB  2
67C4:  MOVWF  x0D
67C6:  MOVLB  0
67C8:  CALL   5480
67CC:  MOVFF  2A,20B
67D0:  MOVLW  37
67D2:  MOVLB  2
67D4:  MOVWF  x0C
67D6:  MOVLB  0
67D8:  CALL   54B0
67DC:  MOVLW  2C
67DE:  MOVLB  2
67E0:  MOVWF  x0D
67E2:  MOVLB  0
67E4:  CALL   5480
67E8:  MOVFF  2B,20B
67EC:  MOVLW  37
67EE:  MOVLB  2
67F0:  MOVWF  x0C
67F2:  MOVLB  0
67F4:  CALL   54B0
67F8:  MOVLW  2E
67FA:  MOVLB  2
67FC:  MOVWF  x0D
67FE:  MOVLB  0
6800:  CALL   5480
6804:  MOVFF  2C,20B
6808:  MOVLW  37
680A:  MOVLB  2
680C:  MOVWF  x0C
680E:  MOVLB  0
6810:  CALL   54B0
6814:  MOVLW  2E
6816:  MOVLB  2
6818:  MOVWF  x0D
681A:  MOVLB  0
681C:  CALL   5480
6820:  MOVFF  2D,20B
6824:  MOVLW  37
6826:  MOVLB  2
6828:  MOVWF  x0C
682A:  MOVLB  0
682C:  CALL   54B0
6830:  MOVLW  2E
6832:  MOVLB  2
6834:  MOVWF  x0D
6836:  MOVLB  0
6838:  CALL   5480
683C:  MOVFF  2E,20B
6840:  MOVLW  37
6842:  MOVLB  2
6844:  MOVWF  x0C
6846:  MOVLB  0
6848:  CALL   54B0
684C:  MOVLW  2C
684E:  MOVLB  2
6850:  MOVWF  x0D
6852:  MOVLB  0
6854:  CALL   5480
6858:  MOVFF  2F,20B
685C:  MOVLW  37
685E:  MOVLB  2
6860:  MOVWF  x0C
6862:  MOVLB  0
6864:  CALL   54B0
6868:  MOVLW  2E
686A:  MOVLB  2
686C:  MOVWF  x0D
686E:  MOVLB  0
6870:  CALL   5480
6874:  MOVFF  30,20B
6878:  MOVLW  37
687A:  MOVLB  2
687C:  MOVWF  x0C
687E:  MOVLB  0
6880:  CALL   54B0
6884:  MOVLW  2E
6886:  MOVLB  2
6888:  MOVWF  x0D
688A:  MOVLB  0
688C:  CALL   5480
6890:  MOVFF  31,20B
6894:  MOVLW  37
6896:  MOVLB  2
6898:  MOVWF  x0C
689A:  MOVLB  0
689C:  CALL   54B0
68A0:  MOVLW  2E
68A2:  MOVLB  2
68A4:  MOVWF  x0D
68A6:  MOVLB  0
68A8:  CALL   5480
68AC:  MOVFF  32,20B
68B0:  MOVLW  37
68B2:  MOVLB  2
68B4:  MOVWF  x0C
68B6:  MOVLB  0
68B8:  CALL   54B0
68BC:  MOVLW  2C
68BE:  MOVLB  2
68C0:  MOVWF  x0D
68C2:  MOVLB  0
68C4:  CALL   5480
68C8:  MOVFF  33,20B
68CC:  MOVLW  37
68CE:  MOVLB  2
68D0:  MOVWF  x0C
68D2:  MOVLB  0
68D4:  CALL   54B0
68D8:  MOVLW  2E
68DA:  MOVLB  2
68DC:  MOVWF  x0D
68DE:  MOVLB  0
68E0:  CALL   5480
68E4:  MOVFF  34,20B
68E8:  MOVLW  37
68EA:  MOVLB  2
68EC:  MOVWF  x0C
68EE:  MOVLB  0
68F0:  CALL   54B0
68F4:  MOVLW  2E
68F6:  MOVLB  2
68F8:  MOVWF  x0D
68FA:  MOVLB  0
68FC:  CALL   5480
6900:  MOVFF  35,20B
6904:  MOVLW  37
6906:  MOVLB  2
6908:  MOVWF  x0C
690A:  MOVLB  0
690C:  CALL   54B0
6910:  MOVLW  2E
6912:  MOVLB  2
6914:  MOVWF  x0D
6916:  MOVLB  0
6918:  CALL   5480
691C:  MOVFF  36,20B
6920:  MOVLW  37
6922:  MOVLB  2
6924:  MOVWF  x0C
6926:  MOVLB  0
6928:  CALL   54B0
692C:  MOVLW  2C
692E:  MOVLB  2
6930:  MOVWF  x0D
6932:  MOVLB  0
6934:  CALL   5480
6938:  MOVFF  37,20B
693C:  MOVLW  37
693E:  MOVLB  2
6940:  MOVWF  x0C
6942:  MOVLB  0
6944:  CALL   54B0
6948:  MOVLW  2D
694A:  MOVLB  2
694C:  MOVWF  x0D
694E:  MOVLB  0
6950:  CALL   5480
6954:  MOVFF  38,20B
6958:  MOVLW  37
695A:  MOVLB  2
695C:  MOVWF  x0C
695E:  MOVLB  0
6960:  CALL   54B0
6964:  MOVLW  2D
6966:  MOVLB  2
6968:  MOVWF  x0D
696A:  MOVLB  0
696C:  CALL   5480
6970:  MOVFF  39,20B
6974:  MOVLW  37
6976:  MOVLB  2
6978:  MOVWF  x0C
697A:  MOVLB  0
697C:  CALL   54B0
6980:  MOVLW  2D
6982:  MOVLB  2
6984:  MOVWF  x0D
6986:  MOVLB  0
6988:  CALL   5480
698C:  MOVFF  3A,20B
6990:  MOVLW  37
6992:  MOVLB  2
6994:  MOVWF  x0C
6996:  MOVLB  0
6998:  CALL   54B0
699C:  MOVLW  2C
699E:  MOVLB  2
69A0:  MOVWF  x0D
69A2:  MOVLB  0
69A4:  CALL   5480
69A8:  MOVLW  02
69AA:  MOVWF  FEA
69AC:  MOVWF  FE9
69AE:  CALL   548C
69B2:  MOVLW  0A
69B4:  MOVLB  2
69B6:  MOVWF  x0D
69B8:  MOVLB  0
69BA:  CALL   5480
....................       } 
....................       else { //CmdReceived == CMD_ER 
69BE:  BRA    69D0
69C0:  MOVLB  1
....................          printf(ClientSockPut, "ER:BADCMD\n"); 
69C2:  MOVLW  DA
69C4:  MOVWF  FF6
69C6:  MOVLW  00
69C8:  MOVWF  FF7
69CA:  MOVLB  0
69CC:  GOTO   54F6
....................       } 
....................        
....................       // Send the packet 
....................       TCPFlush(ClientSocket); 
69D0:  MOVFF  1C9,214
69D4:  CALL   516C
....................       if (CmdReceived == CMD_NA) { 
69D8:  MOVLB  1
69DA:  MOVF   xA8,F
69DC:  BNZ   69E4
....................          TCPClientState = SM_PROCESS_RESPONSE; 
69DE:  MOVLW  05
69E0:  MOVWF  xCE
....................       } 
....................       else { 
69E2:  BRA    69E8
....................          TCPClientState = SM_DISCONNECT; 
69E4:  MOVLW  06
69E6:  MOVWF  xCE
....................       } 
....................       Timer = TickGet(); 
69E8:  MOVLB  0
69EA:  CALL   10B0
69EE:  MOVFF  02,1CD
69F2:  MOVFF  01,1CC
....................       break; 
69F6:  MOVLB  1
69F8:  BRA    6B30
....................  
....................    case SM_PROCESS_RESPONSE: 
....................       IsTCPClientBusy = TRUE; 
69FA:  BSF    x83.4
....................       // Check to see if the remote node has disconnected from us or sent us any application data 
....................       if (!TCPIsConnected(ClientSocket)) { 
69FC:  MOVFF  1C9,20B
6A00:  CALL   4F70
6A04:  MOVF   01,F
6A06:  BNZ   6A14
....................          IsTCPClientBusy = FALSE; 
6A08:  BCF    x83.4
....................          TCPClientState = SM_DISCONNECT; 
6A0A:  MOVLW  06
6A0C:  MOVLB  1
6A0E:  MOVWF  xCE
....................          break; 
6A10:  BRA    6B30
6A12:  MOVLB  0
....................       } 
....................       if (!TCPIsGetReady(ClientSocket)) { 
6A14:  MOVFF  1C9,20B
6A18:  GOTO   5518
6A1C:  MOVF   01,F
6A1E:  BNZ   6A66
....................          IsTCPClientBusy = FALSE; 
6A20:  BCF    x83.4
....................          if (TickGet() - Timer > 30 * TICK_SECOND) { 
6A22:  CALL   10B0
6A26:  MOVFF  02,20C
6A2A:  MOVFF  01,20B
6A2E:  MOVLB  1
6A30:  MOVF   xCC,W
6A32:  MOVLB  2
6A34:  SUBWF  x0B,F
6A36:  MOVLB  1
6A38:  MOVF   xCD,W
6A3A:  MOVLB  2
6A3C:  SUBWFB x0C,F
6A3E:  MOVF   x0C,W
6A40:  SUBLW  00
6A42:  BC    6A54
6A44:  XORLW  FF
6A46:  BNZ   6A4E
6A48:  MOVF   x0B,W
6A4A:  SUBLW  68
6A4C:  BC    6A54
....................             TCPClientState = SM_DISCONNECT; 
6A4E:  MOVLW  06
6A50:  MOVLB  1
6A52:  MOVWF  xCE
....................          } 
....................          if (IsInputChanged == TRUE) { 
6A54:  MOVLB  0
6A56:  BTFSS  x83.2
6A58:  BRA    6A60
....................             TCPClientState = SM_DISCONNECT; 
6A5A:  MOVLW  06
6A5C:  MOVLB  1
6A5E:  MOVWF  xCE
....................          } 
....................          break; 
6A60:  MOVLB  1
6A62:  BRA    6B30
6A64:  MOVLB  0
....................       } 
....................       TCPLedOn(); 
6A66:  CALL   4F9A
....................       BuffI = 0; 
6A6A:  MOVLB  1
6A6C:  CLRF   xEF
....................       // Obtain the server reply 
....................       while (TCPGet(ClientSocket, &BuffC)) { 
6A6E:  MOVFF  1C9,20B
6A72:  MOVLW  01
6A74:  MOVLB  2
6A76:  MOVWF  x0D
6A78:  MOVLW  EE
6A7A:  MOVWF  x0C
6A7C:  MOVLB  0
6A7E:  GOTO   5546
6A82:  MOVF   01,F
6A84:  BZ    6AAA
....................          DataReceived[BuffI] = BuffC; 
6A86:  CLRF   03
6A88:  MOVLB  1
6A8A:  MOVF   xEF,W
6A8C:  ADDLW  A9
6A8E:  MOVWF  FE9
6A90:  MOVLW  01
6A92:  ADDWFC 03,W
6A94:  MOVWF  FEA
6A96:  MOVFF  1EE,FEF
....................          BuffI++; 
6A9A:  INCF   xEF,F
....................          if (BuffC == '\n') { 
6A9C:  MOVF   xEE,W
6A9E:  SUBLW  0A
6AA0:  BNZ   6AA8
....................             break; 
6AA2:  MOVLB  0
6AA4:  BRA    6AAA
6AA6:  MOVLB  1
....................          } 
....................       } 
6AA8:  BRA    6A6E
....................  
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\fREQ:%s", DataReceived); 
.................... #endif 
....................       // Handle Data Received 
....................       if (ObjFound('i', 'o')) { 
6AAA:  MOVLW  69
6AAC:  MOVLB  2
6AAE:  MOVWF  x0B
6AB0:  MOVLW  6F
6AB2:  MOVWF  x0C
6AB4:  MOVLB  0
6AB6:  CALL   561C
6ABA:  MOVF   01,F
6ABC:  BZ    6ACA
....................          IOReqHandle(); 
6ABE:  GOTO   578E
....................          CmdReceived = CMD_IO; 
6AC2:  MOVLW  01
6AC4:  MOVLB  1
6AC6:  MOVWF  xA8
....................       } 
....................       else if (ObjFound('c', 'f')) { 
6AC8:  BRA    6AF6
6ACA:  MOVLW  63
6ACC:  MOVLB  2
6ACE:  MOVWF  x0B
6AD0:  MOVLW  66
6AD2:  MOVWF  x0C
6AD4:  MOVLB  0
6AD6:  CALL   561C
6ADA:  MOVF   01,F
6ADC:  BZ    6AEC
....................          CfReqHandle(); 
6ADE:  GOTO   5F2C
....................          CmdReceived = CMD_CF; 
6AE2:  MOVLW  02
6AE4:  MOVLB  1
6AE6:  MOVWF  xA8
....................       } 
....................       else { 
6AE8:  BRA    6AF6
6AEA:  MOVLB  0
....................          LCDPrintCmdUK(); 
6AEC:  CALL   0006
....................          CmdReceived = CMD_ER; 
6AF0:  MOVLW  03
6AF2:  MOVLB  1
6AF4:  MOVWF  xA8
....................       } 
....................  
....................       // Continue reading data... 
....................       Timer = TickGet(); 
6AF6:  MOVLB  0
6AF8:  CALL   10B0
6AFC:  MOVFF  02,1CD
6B00:  MOVFF  01,1CC
....................       TCPClientState = SM_SOCKET_OBTAINED; 
6B04:  MOVLW  04
6B06:  MOVLB  1
6B08:  MOVWF  xCE
....................       break; 
6B0A:  BRA    6B30
....................  
....................    case SM_DISCONNECT: 
....................       // Close the socket so it can be used by other modules 
....................       // For this application, we wish to stay connected, but this state will still get entered if the remote server decides to disconnect 
....................       TCPDisconnect(ClientSocket); 
6B0C:  MOVFF  1C9,20B
6B10:  GOTO   605C
....................       ClientSocket = INVALID_SOCKET; 
6B14:  MOVLW  FE
6B16:  MOVLB  1
6B18:  MOVWF  xC9
....................       TCPClientState = SM_DONE;       
6B1A:  MOVLW  07
6B1C:  MOVWF  xCE
....................       break; 
6B1E:  BRA    6B30
....................  
....................    case SM_DONE: 
....................       TCPClientState = SM_HOME;    
6B20:  MOVLB  1
6B22:  CLRF   xCE
....................       TCPLedOff(); 
6B24:  MOVLB  0
6B26:  CALL   0E1E
....................       break; 
6B2A:  MOVLB  1
6B2C:  BRA    6B30
6B2E:  MOVLB  1
....................    } 
.................... } 
6B30:  MOVLB  0
6B32:  GOTO   6CDC (RETURN)
....................  
.................... #include "inputscan.c" 
.................... /********************************************************************* 
....................  * 
....................  * Inputs Changed Handler to handle input change. When input changed, 
....................  * output pin will be switched state and trigger InChangedFlag to make 
....................  * TCPClient send notification to IOnOff server 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        inlisten.c 
....................  * Dependencies:    tcp.h, dns.h, tcpclient.c, config.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30, dsPIC33F 
....................  * Complier:        CCS 4.15 
....................  * Company:         IOnOff Technology. 
....................  * 
....................  * Author           Date          Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * SannTran          30/06/2016      Original 
....................  ********************************************************************/ 
.................... // 9 includes RESET button 
.................... BOOLEAN InStates[9]; 
.................... BOOLEAN NewInStates[9]; 
.................... BOOLEAN InStatesChanged[9]; 
.................... TICKTYPE InStatesChangedTime[9]; 
.................... BOOLEAN ControlDecisions[9]; 
....................  
.................... // 
.................... TICKTYPE ResetPressedTime; 
....................  
.................... // Init pin as output and input 
.................... void InsStore(void) { 
....................    InStates[0] = input_state(IN_RESET); 
*
1072:  MOVLB  1
1074:  BCF    xD1.0
1076:  BTFSC  F81.3
1078:  BSF    xD1.0
....................    InStates[1] = input_state(IN_1); 
107A:  BCF    xD1.1
107C:  BTFSC  F82.4
107E:  BSF    xD1.1
....................    InStates[2] = input_state(IN_2); 
1080:  BCF    xD1.2
1082:  BTFSC  F82.5
1084:  BSF    xD1.2
....................    InStates[3] = input_state(IN_3); 
1086:  BCF    xD1.3
1088:  BTFSC  F83.5
108A:  BSF    xD1.3
....................    InStates[4] = input_state(IN_4); 
108C:  BCF    xD1.4
108E:  BTFSC  F83.6
1090:  BSF    xD1.4
....................    InStates[5] = input_state(IN_5); 
1092:  BCF    xD1.5
1094:  BTFSC  F83.7
1096:  BSF    xD1.5
....................    InStates[6] = input_state(IN_6); 
1098:  BCF    xD1.6
109A:  BTFSC  F81.0
109C:  BSF    xD1.6
....................    InStates[7] = input_state(IN_7); 
109E:  BCF    xD1.7
10A0:  BTFSC  F81.1
10A2:  BSF    xD1.7
....................    InStates[8] = input_state(IN_8); 
10A4:  BCF    xD2.0
10A6:  BTFSC  F81.2
10A8:  BSF    xD2.0
.................... } 
10AA:  MOVLB  0
10AC:  GOTO   10CC (RETURN)
....................  
.................... void InputsScanInit(void) { 
....................    InsStore(); 
*
10CA:  BRA    1072
....................    TICKTYPE tick = TickGet(); 
....................    int8 i; 
10CC:  RCALL  10B0
10CE:  MOVFF  02,1EF
10D2:  MOVFF  01,1EE
....................    for (i = 0; i < 9; i++) {       
10D6:  MOVLB  1
10D8:  CLRF   xF0
10DA:  MOVF   xF0,W
10DC:  SUBLW  08
10DE:  BNC   1114
....................       InStatesChanged[i] = FALSE; 
10E0:  MOVFF  1F0,20F
10E4:  MOVLB  2
10E6:  CLRF   x10
10E8:  MOVLW  01
10EA:  MOVWF  x12
10EC:  MOVLW  D5
10EE:  MOVWF  x11
10F0:  MOVLB  0
10F2:  RCALL  0E24
....................       InStatesChangedTime[i] = tick; 
10F4:  BCF    FD8.0
10F6:  MOVLB  1
10F8:  RLCF   xF0,W
10FA:  CLRF   03
10FC:  ADDLW  D7
10FE:  MOVWF  FE9
1100:  MOVLW  01
1102:  ADDWFC 03,W
1104:  MOVWF  FEA
1106:  MOVFF  1EF,FEC
110A:  MOVF   FED,F
110C:  MOVFF  1EE,FEF
....................    } 
1110:  INCF   xF0,F
1112:  BRA    10DA
....................    IsInputChanged = FALSE; 
1114:  MOVLB  0
1116:  BCF    x83.2
....................    ResetPressedTime = 0; 
1118:  MOVLB  1
111A:  CLRF   xEC
111C:  CLRF   xEB
.................... } 
111E:  MOVLB  0
1120:  GOTO   6C90 (RETURN)
....................  
.................... void OnResetBtnReleased(void) { 
....................    if ((TickGet() - ResetPressedTime) > 5 * TICK_SECOND) { 
*
4688:  CALL   10B0
468C:  MOVFF  02,1F0
4690:  MOVFF  01,1EF
4694:  MOVLB  1
4696:  MOVF   xEB,W
4698:  SUBWF  xEF,F
469A:  MOVF   xEC,W
469C:  SUBWFB xF0,F
469E:  BNZ   46A6
46A0:  MOVF   xEF,W
46A2:  SUBLW  3C
46A4:  BC    46B4
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\f%s", "ResetAll..."); 
.................... #endif 
....................       ConfigReset();  
46A6:  MOVLB  0
46A8:  CALL   0A54
....................       EEPWriteConfig();  
46AC:  CALL   0CE6
....................    } 
....................    else { 
46B0:  BRA    46B2
46B2:  MOVLB  1
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\f%s", "ResetPIC..."); 
.................... #endif 
....................    } 
....................    // Just delay to let WDT reset 
....................    output_low(OUT_IAM_RUNNING); 
46B4:  BCF    F95.0
46B6:  BCF    F8C.0
46B8:  CLRF   19
46BA:  BTFSC  FF2.7
46BC:  BSF    19.7
46BE:  BCF    FF2.7
....................    delay_ms(10); 
46C0:  MOVLW  0A
46C2:  MOVLB  2
46C4:  MOVWF  xA9
46C6:  MOVLB  0
46C8:  CALL   00E6
46CC:  BTFSC  19.7
46CE:  BSF    FF2.7
....................    setup_wdt(WDT_ON); 
46D0:  BSF    FD1.0
....................    restart_wdt(); 
46D2:  CLRWDT
.................... } 
46D4:  GOTO   4AA2 (RETURN)
....................  
.................... void InChangedHandle(int8 pin, int8 idx) { 
.................... #ifdef USE_PORTD_LCD 
....................     printf(lcd_putc, "\fIN_%d Changed OK", idx); 
.................... #endif 
....................  
....................     IsInputChanged = TRUE; 
*
48CA:  BSF    x83.2
....................     output_toggle(pin); 
48CC:  MOVFF  1EF,1F2
48D0:  MOVLW  0F
48D2:  MOVLB  1
48D4:  MOVWF  xF4
48D6:  MOVLW  80
48D8:  MOVWF  xF3
48DA:  MOVLB  0
48DC:  RCALL  4656
48DE:  MOVLW  00
48E0:  BTFSS  01.0
48E2:  MOVLW  01
48E4:  MOVFF  1EF,20F
48E8:  MOVLB  2
48EA:  MOVWF  x10
48EC:  MOVLW  0F
48EE:  MOVWF  x12
48F0:  MOVLW  89
48F2:  MOVWF  x11
48F4:  MOVLB  0
48F6:  CALL   0E24
48FA:  MOVFF  1EF,20F
48FE:  MOVLB  2
4900:  CLRF   x10
4902:  MOVLW  0F
4904:  MOVWF  x12
4906:  MOVLW  92
4908:  MOVWF  x11
490A:  MOVLB  0
490C:  CALL   0E24
....................     EEPWriteOutputState(idx); 
4910:  MOVFF  1F0,20F
4914:  RCALL  46D8
.................... } 
4916:  RETLW  00
....................  
.................... void InsListen(void) {    
....................    int8 i; 
....................    for (i = 0; i < 9; i++) { 
4918:  MOVLB  1
491A:  CLRF   xEE
491C:  MOVF   xEE,W
491E:  SUBLW  08
4920:  BNC   493E
....................       ControlDecisions[i] = FALSE; 
4922:  MOVFF  1EE,20F
4926:  MOVLB  2
4928:  CLRF   x10
492A:  MOVLW  01
492C:  MOVWF  x12
492E:  MOVLW  E9
4930:  MOVWF  x11
4932:  MOVLB  0
4934:  CALL   0E24
....................    } 
4938:  MOVLB  1
493A:  INCF   xEE,F
493C:  BRA    491C
....................    NewInStates[0] = input_state(IN_RESET); 
493E:  BCF    xD3.0
4940:  BTFSC  F81.3
4942:  BSF    xD3.0
....................    NewInStates[1] = input_state(IN_1); 
4944:  BCF    xD3.1
4946:  BTFSC  F82.4
4948:  BSF    xD3.1
....................    NewInStates[2] = input_state(IN_2); 
494A:  BCF    xD3.2
494C:  BTFSC  F82.5
494E:  BSF    xD3.2
....................    NewInStates[3] = input_state(IN_3); 
4950:  BCF    xD3.3
4952:  BTFSC  F83.5
4954:  BSF    xD3.3
....................    NewInStates[4] = input_state(IN_4); 
4956:  BCF    xD3.4
4958:  BTFSC  F83.6
495A:  BSF    xD3.4
....................    NewInStates[5] = input_state(IN_5); 
495C:  BCF    xD3.5
495E:  BTFSC  F83.7
4960:  BSF    xD3.5
....................    NewInStates[6] = input_state(IN_6); 
4962:  BCF    xD3.6
4964:  BTFSC  F81.0
4966:  BSF    xD3.6
....................    NewInStates[7] = input_state(IN_7); 
4968:  BCF    xD3.7
496A:  BTFSC  F81.1
496C:  BSF    xD3.7
....................    NewInStates[8] = input_state(IN_8); 
496E:  BCF    xD4.0
4970:  BTFSC  F81.2
4972:  BSF    xD4.0
....................  
....................    for (i = 0; i < 9; i++) { 
4974:  CLRF   xEE
4976:  MOVF   xEE,W
4978:  SUBLW  08
497A:  BTFSS  FD8.0
497C:  BRA    4BFA
....................       // If the input has changed before 
....................       if (InStatesChanged[i] == TRUE) { 
497E:  MOVFF  1EE,1F2
4982:  MOVLW  01
4984:  MOVWF  xF4
4986:  MOVLW  D5
4988:  MOVWF  xF3
498A:  MOVLB  0
498C:  RCALL  4656
498E:  MOVLW  00
4990:  BTFSC  01.0
4992:  MOVLW  01
4994:  ANDLW  01
4996:  SUBLW  01
4998:  BTFSS  FD8.2
499A:  BRA    4B3A
....................           
....................         // If the input has changed for more than ~1/3 second 
....................         if ((TickGet() - InStatesChangedTime[i]) > 3) { 
499C:  CALL   10B0
49A0:  MOVFF  02,1F0
49A4:  MOVFF  01,1EF
49A8:  BCF    FD8.0
49AA:  MOVLB  1
49AC:  RLCF   xEE,W
49AE:  CLRF   03
49B0:  ADDLW  D7
49B2:  MOVWF  FE9
49B4:  MOVLW  01
49B6:  ADDWFC 03,W
49B8:  MOVWF  FEA
49BA:  MOVFF  FEC,03
49BE:  MOVF   FED,F
49C0:  MOVF   FEF,W
49C2:  SUBWF  xEF,F
49C4:  MOVF   03,W
49C6:  SUBWFB xF0,F
49C8:  BNZ   49D2
49CA:  MOVF   xEF,W
49CC:  SUBLW  03
49CE:  BTFSC  FD8.0
49D0:  BRA    4B36
....................            
....................           // If the input state now is changed from stored input state 
....................           if ((InStates[i] == FALSE && NewInStates[i] == TRUE) || 
....................                   (InStates[i] == TRUE && NewInStates[i] == FALSE)) { 
49D2:  MOVFF  1EE,1F2
49D6:  MOVLW  01
49D8:  MOVWF  xF4
49DA:  MOVLW  D1
49DC:  MOVWF  xF3
49DE:  MOVLB  0
49E0:  RCALL  4656
49E2:  MOVLW  00
49E4:  BTFSC  01.0
49E6:  MOVLW  01
49E8:  ANDLW  01
49EA:  BNZ   4A0A
49EC:  MOVFF  1EE,1F2
49F0:  MOVLW  01
49F2:  MOVLB  1
49F4:  MOVWF  xF4
49F6:  MOVLW  D3
49F8:  MOVWF  xF3
49FA:  MOVLB  0
49FC:  RCALL  4656
49FE:  MOVLW  00
4A00:  BTFSC  01.0
4A02:  MOVLW  01
4A04:  ANDLW  01
4A06:  SUBLW  01
4A08:  BZ    4A46
4A0A:  MOVFF  1EE,1F2
4A0E:  MOVLW  01
4A10:  MOVLB  1
4A12:  MOVWF  xF4
4A14:  MOVLW  D1
4A16:  MOVWF  xF3
4A18:  MOVLB  0
4A1A:  RCALL  4656
4A1C:  MOVLW  00
4A1E:  BTFSC  01.0
4A20:  MOVLW  01
4A22:  ANDLW  01
4A24:  SUBLW  01
4A26:  BTFSS  FD8.2
4A28:  BRA    4B1E
4A2A:  MOVFF  1EE,1F2
4A2E:  MOVLW  01
4A30:  MOVLB  1
4A32:  MOVWF  xF4
4A34:  MOVLW  D3
4A36:  MOVWF  xF3
4A38:  MOVLB  0
4A3A:  RCALL  4656
4A3C:  MOVLW  00
4A3E:  BTFSC  01.0
4A40:  MOVLW  01
4A42:  ANDLW  01
4A44:  BNZ   4B1E
....................              // The input state change is confirmed 
....................              InStates[i] = NewInStates[i]; 
4A46:  MOVFF  1EE,1F2
4A4A:  MOVLW  01
4A4C:  MOVLB  1
4A4E:  MOVWF  xF4
4A50:  MOVLW  D3
4A52:  MOVWF  xF3
4A54:  MOVLB  0
4A56:  RCALL  4656
4A58:  MOVFF  1EE,20F
4A5C:  MOVLB  2
4A5E:  CLRF   x10
4A60:  BTFSC  01.0
4A62:  INCF   x10,F
4A64:  MOVLW  01
4A66:  MOVWF  x12
4A68:  MOVLW  D1
4A6A:  MOVWF  x11
4A6C:  MOVLB  0
4A6E:  CALL   0E24
....................               
....................               
....................              if (i == 0) { // this is reset input button 
4A72:  MOVLB  1
4A74:  MOVF   xEE,F
4A76:  BNZ   4AA6
....................                 // Reset btn is pressed 
....................                 if (NewInStates[i] == FALSE) { 
4A78:  MOVFF  1EE,1F2
4A7C:  MOVLW  01
4A7E:  MOVWF  xF4
4A80:  MOVLW  D3
4A82:  MOVWF  xF3
4A84:  MOVLB  0
4A86:  RCALL  4656
4A88:  MOVLW  00
4A8A:  BTFSC  01.0
4A8C:  MOVLW  01
4A8E:  ANDLW  01
4A90:  BNZ   4AA0
....................                    ResetPressedTime = TickGet(); 
4A92:  CALL   10B0
4A96:  MOVFF  02,1EC
4A9A:  MOVFF  01,1EB
.................... #ifdef USE_PORTD_LCD 
....................                    printf(lcd_putc, "\f%s", "Reset-Pressed"); 
.................... #endif 
....................                 }                 
....................                 else { // Reset btn is released 
4A9E:  BRA    4AA2
....................                    OnResetBtnReleased(); 
4AA0:  BRA    4688
....................                 }                 
....................              } 
....................              else { // these are normal inputs for controling relays 
4AA2:  BRA    4B06
4AA4:  MOVLB  1
....................                if (MY_INPUT_TYPE_BYTES[i - 1] == INPUT_BUTTON) { 
4AA6:  MOVLW  01
4AA8:  SUBWF  xEE,W
4AAA:  CLRF   03
4AAC:  ADDLW  1A
4AAE:  MOVWF  FE9
4AB0:  MOVLW  00
4AB2:  ADDWFC 03,W
4AB4:  MOVWF  FEA
4AB6:  MOVF   FEF,W
4AB8:  SUBLW  02
4ABA:  BNZ   4AF0
....................                   if (NewInStates[i] == FALSE) { // released button 
4ABC:  MOVFF  1EE,1F2
4AC0:  MOVLW  01
4AC2:  MOVWF  xF4
4AC4:  MOVLW  D3
4AC6:  MOVWF  xF3
4AC8:  MOVLB  0
4ACA:  RCALL  4656
4ACC:  MOVLW  00
4ACE:  BTFSC  01.0
4AD0:  MOVLW  01
4AD2:  ANDLW  01
4AD4:  BNZ   4AEC
....................                      ControlDecisions[i] = TRUE; 
4AD6:  MOVFF  1EE,20F
4ADA:  MOVLW  01
4ADC:  MOVLB  2
4ADE:  MOVWF  x10
4AE0:  MOVWF  x12
4AE2:  MOVLW  E9
4AE4:  MOVWF  x11
4AE6:  MOVLB  0
4AE8:  CALL   0E24
....................                   } 
....................                } 
....................                else { 
4AEC:  BRA    4B06
4AEE:  MOVLB  1
....................                   ControlDecisions[i] = TRUE; 
4AF0:  MOVFF  1EE,20F
4AF4:  MOVLW  01
4AF6:  MOVLB  2
4AF8:  MOVWF  x10
4AFA:  MOVWF  x12
4AFC:  MOVLW  E9
4AFE:  MOVWF  x11
4B00:  MOVLB  0
4B02:  CALL   0E24
....................                } 
....................              } 
....................               
....................              InStatesChanged[i] = FALSE;  
4B06:  MOVFF  1EE,20F
4B0A:  MOVLB  2
4B0C:  CLRF   x10
4B0E:  MOVLW  01
4B10:  MOVWF  x12
4B12:  MOVLW  D5
4B14:  MOVWF  x11
4B16:  MOVLB  0
4B18:  CALL   0E24
....................           } 
....................           else { 
4B1C:  BRA    4B34
....................              InStatesChanged[i] = FALSE; 
4B1E:  MOVFF  1EE,20F
4B22:  MOVLB  2
4B24:  CLRF   x10
4B26:  MOVLW  01
4B28:  MOVWF  x12
4B2A:  MOVLW  D5
4B2C:  MOVWF  x11
4B2E:  MOVLB  0
4B30:  CALL   0E24
4B34:  MOVLB  1
....................           } 
....................         } 
....................       } 
....................       // If new input state is changed from stored input state 
....................       else if ((InStates[i] == FALSE && NewInStates[i] == TRUE) || 
4B36:  BRA    4BF6
4B38:  MOVLB  0
....................          (InStates[i] == TRUE && NewInStates[i] == FALSE)) { 
4B3A:  MOVFF  1EE,1F2
4B3E:  MOVLW  01
4B40:  MOVLB  1
4B42:  MOVWF  xF4
4B44:  MOVLW  D1
4B46:  MOVWF  xF3
4B48:  MOVLB  0
4B4A:  RCALL  4656
4B4C:  MOVLW  00
4B4E:  BTFSC  01.0
4B50:  MOVLW  01
4B52:  ANDLW  01
4B54:  BNZ   4B74
4B56:  MOVFF  1EE,1F2
4B5A:  MOVLW  01
4B5C:  MOVLB  1
4B5E:  MOVWF  xF4
4B60:  MOVLW  D3
4B62:  MOVWF  xF3
4B64:  MOVLB  0
4B66:  RCALL  4656
4B68:  MOVLW  00
4B6A:  BTFSC  01.0
4B6C:  MOVLW  01
4B6E:  ANDLW  01
4B70:  SUBLW  01
4B72:  BZ    4BAE
4B74:  MOVFF  1EE,1F2
4B78:  MOVLW  01
4B7A:  MOVLB  1
4B7C:  MOVWF  xF4
4B7E:  MOVLW  D1
4B80:  MOVWF  xF3
4B82:  MOVLB  0
4B84:  RCALL  4656
4B86:  MOVLW  00
4B88:  BTFSC  01.0
4B8A:  MOVLW  01
4B8C:  ANDLW  01
4B8E:  SUBLW  01
4B90:  BNZ   4BF4
4B92:  MOVFF  1EE,1F2
4B96:  MOVLW  01
4B98:  MOVLB  1
4B9A:  MOVWF  xF4
4B9C:  MOVLW  D3
4B9E:  MOVWF  xF3
4BA0:  MOVLB  0
4BA2:  RCALL  4656
4BA4:  MOVLW  00
4BA6:  BTFSC  01.0
4BA8:  MOVLW  01
4BAA:  ANDLW  01
4BAC:  BNZ   4BF4
....................          #ifdef USE_PORTD_LCD 
....................             printf(lcd_putc, "\fIN_%d%d%d", i + 1, InStates[i], NewInStates[i]); 
....................          #endif 
....................          InStatesChanged[i] = TRUE; 
4BAE:  MOVFF  1EE,20F
4BB2:  MOVLW  01
4BB4:  MOVLB  2
4BB6:  MOVWF  x10
4BB8:  MOVWF  x12
4BBA:  MOVLW  D5
4BBC:  MOVWF  x11
4BBE:  MOVLB  0
4BC0:  CALL   0E24
....................          InStatesChangedTime[i] = TickGet(); 
4BC4:  BCF    FD8.0
4BC6:  MOVLB  1
4BC8:  RLCF   xEE,W
4BCA:  CLRF   03
4BCC:  ADDLW  D7
4BCE:  MOVWF  01
4BD0:  MOVLW  01
4BD2:  ADDWFC 03,F
4BD4:  MOVFF  01,1EF
4BD8:  MOVFF  03,1F0
4BDC:  MOVLB  0
4BDE:  CALL   10B0
4BE2:  MOVFF  1F0,FEA
4BE6:  MOVFF  1EF,FE9
4BEA:  MOVFF  02,FEC
4BEE:  MOVF   FED,F
4BF0:  MOVFF  01,FEF
4BF4:  MOVLB  1
....................       } 
....................    } 
4BF6:  INCF   xEE,F
4BF8:  BRA    4976
....................  
....................    if (ControlDecisions[1] == TRUE) { 
4BFA:  BTFSS  xE9.1
4BFC:  BRA    4C0C
....................       InChangedHandle(OUT_1, 1); 
4BFE:  MOVLW  12
4C00:  MOVWF  xEF
4C02:  MOVLW  01
4C04:  MOVWF  xF0
4C06:  MOVLB  0
4C08:  RCALL  48CA
4C0A:  MOVLB  1
....................    } 
....................    if (ControlDecisions[2] == TRUE) { 
4C0C:  BTFSS  xE9.2
4C0E:  BRA    4C1E
....................       InChangedHandle(OUT_2, 2); 
4C10:  MOVLW  11
4C12:  MOVWF  xEF
4C14:  MOVLW  02
4C16:  MOVWF  xF0
4C18:  MOVLB  0
4C1A:  RCALL  48CA
4C1C:  MOVLB  1
....................    }       
....................    if (ControlDecisions[3] == TRUE) { 
4C1E:  BTFSS  xE9.3
4C20:  BRA    4C30
....................       InChangedHandle(OUT_3, 3); 
4C22:  MOVLW  10
4C24:  MOVWF  xEF
4C26:  MOVLW  03
4C28:  MOVWF  xF0
4C2A:  MOVLB  0
4C2C:  RCALL  48CA
4C2E:  MOVLB  1
....................    } 
....................    if (ControlDecisions[4] == TRUE) { 
4C30:  BTFSS  xE9.4
4C32:  BRA    4C42
....................       InChangedHandle(OUT_4, 4); 
4C34:  MOVLW  22
4C36:  MOVWF  xEF
4C38:  MOVLW  04
4C3A:  MOVWF  xF0
4C3C:  MOVLB  0
4C3E:  RCALL  48CA
4C40:  MOVLB  1
....................    } 
....................    if (ControlDecisions[5] == TRUE) { 
4C42:  BTFSS  xE9.5
4C44:  BRA    4C54
....................       InChangedHandle(OUT_5, 5); 
4C46:  MOVLW  21
4C48:  MOVWF  xEF
4C4A:  MOVLW  05
4C4C:  MOVWF  xF0
4C4E:  MOVLB  0
4C50:  RCALL  48CA
4C52:  MOVLB  1
....................    } 
....................    if (ControlDecisions[6] == TRUE) { 
4C54:  BTFSS  xE9.6
4C56:  BRA    4C66
....................       InChangedHandle(OUT_6, 6); 
4C58:  MOVLW  20
4C5A:  MOVWF  xEF
4C5C:  MOVLW  06
4C5E:  MOVWF  xF0
4C60:  MOVLB  0
4C62:  RCALL  48CA
4C64:  MOVLB  1
....................    } 
....................    if (ControlDecisions[7] == TRUE) { 
4C66:  BTFSS  xE9.7
4C68:  BRA    4C78
....................       InChangedHandle(OUT_7, 7); 
4C6A:  MOVLW  05
4C6C:  MOVWF  xEF
4C6E:  MOVLW  07
4C70:  MOVWF  xF0
4C72:  MOVLB  0
4C74:  RCALL  48CA
4C76:  MOVLB  1
....................    } 
....................    if (ControlDecisions[8] == TRUE) { 
4C78:  BTFSS  xEA.0
4C7A:  BRA    4C8A
....................       InChangedHandle(OUT_8, 8); 
4C7C:  MOVLW  04
4C7E:  MOVWF  xEF
4C80:  MOVLW  08
4C82:  MOVWF  xF0
4C84:  MOVLB  0
4C86:  RCALL  48CA
4C88:  MOVLB  1
....................    } 
.................... } 
4C8A:  MOVLB  0
4C8C:  GOTO   6CD8 (RETURN)
....................  
....................  
....................  
.................... void MyMacInit() { 
....................    MY_MAC_BYTE1 = MY_DEFAULT_MAC_BYTE1; 
*
0CF4:  CLRF   47
....................    MY_MAC_BYTE2 = MY_DEFAULT_MAC_BYTE2; 
0CF6:  MOVLW  04
0CF8:  MOVWF  48
....................    MY_MAC_BYTE3 = MyEEPRom.Macs[0]; 
0CFA:  MOVFF  37,49
....................    MY_MAC_BYTE4 = MyEEPRom.Macs[1]; 
0CFE:  MOVFF  38,4A
....................    MY_MAC_BYTE5 = MyEEPRom.Macs[2]; 
0D02:  MOVFF  39,4B
....................    MY_MAC_BYTE6 = MyEEPRom.Macs[3]; 
0D06:  MOVFF  3A,4C
.................... } 
0D0A:  GOTO   0DD6 (RETURN)
....................  
.................... void MyIpInit() { 
....................    int8 i; 
....................    for (i = 0; i < 4; i++) { 
0D0E:  MOVLB  1
0D10:  CLRF   xEE
0D12:  MOVF   xEE,W
0D14:  SUBLW  03
0D16:  BNC   0D4A
....................       MY_SRV_IP_BYTES[i] = MyEEPRom.SrvIps[i]; 
0D18:  CLRF   03
0D1A:  MOVF   xEE,W
0D1C:  ADDLW  22
0D1E:  MOVWF  01
0D20:  MOVLW  00
0D22:  ADDWFC 03,F
0D24:  MOVFF  03,1F0
0D28:  CLRF   03
0D2A:  MOVF   xEE,W
0D2C:  ADDLW  27
0D2E:  MOVWF  FE9
0D30:  MOVLW  00
0D32:  ADDWFC 03,W
0D34:  MOVWF  FEA
0D36:  MOVFF  FEF,1F1
0D3A:  MOVFF  1F0,FEA
0D3E:  MOVFF  01,FE9
0D42:  MOVFF  1F1,FEF
....................    } 
0D46:  INCF   xEE,F
0D48:  BRA    0D12
....................     
....................    //Direccion IP 
....................    MY_IP_BYTE1 = MyEEPRom.Ips[0]; 
0D4A:  MOVFF  2B,43
....................    MY_IP_BYTE2 = MyEEPRom.Ips[1]; 
0D4E:  MOVFF  2C,44
....................    MY_IP_BYTE3 = MyEEPRom.Ips[2]; 
0D52:  MOVFF  2D,45
....................    MY_IP_BYTE4 = MyEEPRom.Ips[3];   
0D56:  MOVFF  2E,46
....................  
....................    //Puerta de Enlace 
....................    MY_GATE_BYTE1 = MyEEPRom.Gates[0]; 
0D5A:  MOVFF  33,51
....................    MY_GATE_BYTE2 = MyEEPRom.Gates[1]; 
0D5E:  MOVFF  34,52
....................    MY_GATE_BYTE3 = MyEEPRom.Gates[2]; 
0D62:  MOVFF  35,53
....................    MY_GATE_BYTE4 = MyEEPRom.Gates[3]; 
0D66:  MOVFF  36,54
....................  
....................    //Mascara de Subred 
....................    MY_MASK_BYTE1 = MyEEPRom.Masks[0]; 
0D6A:  MOVFF  2F,4D
....................    MY_MASK_BYTE2 = MyEEPRom.Masks[1]; 
0D6E:  MOVFF  30,4E
....................    MY_MASK_BYTE3 = MyEEPRom.Masks[2]; 
0D72:  MOVFF  31,4F
....................    MY_MASK_BYTE4 = MyEEPRom.Masks[3]; 
0D76:  MOVFF  32,50
.................... } 
0D7A:  MOVLB  0
0D7C:  GOTO   0DD8 (RETURN)
....................  
.................... void MyInputTypesInit() { 
....................    int8 i; 
....................    for (i = 0; i < 8; i++) { 
0D80:  MOVLB  1
0D82:  CLRF   xEE
0D84:  MOVF   xEE,W
0D86:  SUBLW  07
0D88:  BNC   0DBC
....................       MY_INPUT_TYPE_BYTES[i] = MyEEPRom.InputTypes[i]; 
0D8A:  CLRF   03
0D8C:  MOVF   xEE,W
0D8E:  ADDLW  1A
0D90:  MOVWF  01
0D92:  MOVLW  00
0D94:  ADDWFC 03,F
0D96:  MOVFF  03,1F0
0D9A:  CLRF   03
0D9C:  MOVF   xEE,W
0D9E:  ADDLW  3B
0DA0:  MOVWF  FE9
0DA2:  MOVLW  00
0DA4:  ADDWFC 03,W
0DA6:  MOVWF  FEA
0DA8:  MOVFF  FEF,1F1
0DAC:  MOVFF  1F0,FEA
0DB0:  MOVFF  01,FE9
0DB4:  MOVFF  1F1,FEF
....................    } 
0DB8:  INCF   xEE,F
0DBA:  BRA    0D84
.................... } 
0DBC:  MOVLB  0
0DBE:  GOTO   0DDA (RETURN)
....................  
.................... void ConfigInit() { 
....................    EEPReadAll(); 
0DC2:  BRA    08D8
....................  
....................    if (MyEEPRom.Flag != TRUE) { 
0DC4:  DECFSZ 26,W
0DC6:  BRA    0DCA
0DC8:  BRA    0DD4
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\f%s", "Use Default"); 
.................... #endif 
....................       MacReset(); 
0DCA:  BRA    0A46
....................       ConfigReset();   
0DCC:  RCALL  0A54
....................       EEPWriteMac(); 
0DCE:  RCALL  0AB4
....................       EEPWriteConfig();       
0DD0:  RCALL  0CE6
....................    } 
....................    else { 
0DD2:  BRA    0DD4
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\f%s", "Use EEPRom"); 
.................... #endif 
....................    } 
....................    MyMacInit(); 
0DD4:  BRA    0CF4
....................    MyIpInit(); 
0DD6:  BRA    0D0E
....................    MyInputTypesInit(); 
0DD8:  BRA    0D80
.................... } 
0DDA:  GOTO   6C5A (RETURN)
....................  
.................... void OutputHigh(int8 pin, BOOLEAN p16fRunning) { 
....................    if (p16fRunning == FALSE) {  
*
0E66:  MOVLB  1
0E68:  MOVF   xF1,F
0E6A:  BNZ   0E8E
....................       // power cut, hold system start 
....................       delay_ms(2500); 
0E6C:  MOVLW  0A
0E6E:  MOVWF  xF2
0E70:  CLRF   19
0E72:  BTFSC  FF2.7
0E74:  BSF    19.7
0E76:  BCF    FF2.7
0E78:  MOVLW  FA
0E7A:  MOVLB  2
0E7C:  MOVWF  xA9
0E7E:  MOVLB  0
0E80:  CALL   00E6
0E84:  BTFSC  19.7
0E86:  BSF    FF2.7
0E88:  MOVLB  1
0E8A:  DECFSZ xF2,F
0E8C:  BRA    0E70
....................    }    
....................    output_high(pin); 
0E8E:  MOVFF  1F0,20F
0E92:  MOVLW  01
0E94:  MOVLB  2
0E96:  MOVWF  x10
0E98:  MOVLW  0F
0E9A:  MOVWF  x12
0E9C:  MOVLW  89
0E9E:  MOVWF  x11
0EA0:  MOVLB  0
0EA2:  RCALL  0E24
0EA4:  MOVFF  1F0,20F
0EA8:  MOVLB  2
0EAA:  CLRF   x10
0EAC:  MOVLW  0F
0EAE:  MOVWF  x12
0EB0:  MOVLW  92
0EB2:  MOVWF  x11
0EB4:  MOVLB  0
0EB6:  RCALL  0E24
.................... } 
0EB8:  RETLW  00
....................  
.................... void IOsConfig() { 
....................     
....................    input(IN_1); 
*
0DDE:  BSF    F94.4
....................    input(IN_2); 
0DE0:  BSF    F94.5
....................    input(IN_3); 
0DE2:  BSF    F95.5
....................    input(IN_4); 
0DE4:  BSF    F95.6
....................    input(IN_5);   
0DE6:  BSF    F95.7
....................    input(IN_6); 
0DE8:  BSF    F93.0
....................    input(IN_7); 
0DEA:  BSF    F93.1
....................    input(IN_8); 
0DEC:  BSF    F93.2
....................    input(IN_RESET); 
0DEE:  BSF    F93.3
....................    input(IN_16F_RUNNING); 
0DF0:  BSF    F95.1
....................  
....................    output_low(OUT_1); 
0DF2:  BCF    F94.2
0DF4:  BCF    F8B.2
....................    output_low(OUT_2); 
0DF6:  BCF    F94.1
0DF8:  BCF    F8B.1
....................    output_low(OUT_3); 
0DFA:  BCF    F94.0
0DFC:  BCF    F8B.0
....................    output_low(OUT_4); 
0DFE:  BCF    F96.2
0E00:  BCF    F8D.2
....................    output_low(OUT_5); 
0E02:  BCF    F96.1
0E04:  BCF    F8D.1
....................    output_low(OUT_6); 
0E06:  BCF    F96.0
0E08:  BCF    F8D.0
....................    output_low(OUT_7); 
0E0A:  BCF    F92.5
0E0C:  BCF    F89.5
....................    output_low(OUT_8); 
0E0E:  BCF    F92.4
0E10:  BCF    F89.4
....................    output_low(OUT_IAM_RUNNING);  
0E12:  BCF    F95.0
0E14:  BCF    F8C.0
....................    output_low(OUT_TCP_STATE);  
0E16:  BCF    F93.4
0E18:  BCF    F8A.4
.................... } 
0E1A:  GOTO   6C5E (RETURN)
....................  
.................... void OutputsRestore(void) { 
*
0EBA:  MOVLB  1
0EBC:  BCF    xEE.0
0EBE:  BTFSC  F83.1
0EC0:  BSF    xEE.0
....................    // If p16f is running, it mean this pic is reset because of WDT 
....................    // Esle the reason of reseting is power cut 
....................    BOOLEAN p16fRunning = input_state(IN_16F_RUNNING); 
....................    if (p16fRunning == FALSE) { 
0EC2:  BTFSC  xEE.0
0EC4:  BRA    0EE4
....................       output_high(OUT_IAM_RUNNING); 
0EC6:  BCF    F95.0
0EC8:  BSF    F8C.0
0ECA:  CLRF   19
0ECC:  BTFSC  FF2.7
0ECE:  BSF    19.7
0ED0:  BCF    FF2.7
....................       delay_ms(100); 
0ED2:  MOVLW  64
0ED4:  MOVLB  2
0ED6:  MOVWF  xA9
0ED8:  MOVLB  0
0EDA:  CALL   00E6
0EDE:  BTFSC  19.7
0EE0:  BSF    FF2.7
0EE2:  MOVLB  1
....................    } 
....................    // Restore ouput states 
....................    if (read_eeprom(29) == TRUE) { 
0EE4:  MOVFF  FF2,1EF
0EE8:  BCF    FF2.7
0EEA:  MOVLW  1D
0EEC:  MOVWF  FA9
0EEE:  BCF    FA6.6
0EF0:  BCF    FA6.7
0EF2:  BSF    FA6.0
0EF4:  MOVF   FA8,W
0EF6:  BTFSC  xEF.7
0EF8:  BSF    FF2.7
0EFA:  SUBLW  01
0EFC:  BNZ   0F14
....................       OutputHigh(OUT_1, p16fRunning); 
0EFE:  MOVLW  00
0F00:  BTFSC  xEE.0
0F02:  MOVLW  01
0F04:  MOVWF  xEF
0F06:  MOVLW  12
0F08:  MOVWF  xF0
0F0A:  MOVFF  1EF,1F1
0F0E:  MOVLB  0
0F10:  RCALL  0E66
0F12:  MOVLB  1
....................    } 
....................    // 
....................    if (read_eeprom(30) == TRUE) { 
0F14:  MOVFF  FF2,1EF
0F18:  BCF    FF2.7
0F1A:  MOVLW  1E
0F1C:  MOVWF  FA9
0F1E:  BCF    FA6.6
0F20:  BCF    FA6.7
0F22:  BSF    FA6.0
0F24:  MOVF   FA8,W
0F26:  BTFSC  xEF.7
0F28:  BSF    FF2.7
0F2A:  SUBLW  01
0F2C:  BNZ   0F44
....................       OutputHigh(OUT_2, p16fRunning); 
0F2E:  MOVLW  00
0F30:  BTFSC  xEE.0
0F32:  MOVLW  01
0F34:  MOVWF  xEF
0F36:  MOVLW  11
0F38:  MOVWF  xF0
0F3A:  MOVFF  1EF,1F1
0F3E:  MOVLB  0
0F40:  RCALL  0E66
0F42:  MOVLB  1
....................    } 
....................    // 
....................    if (read_eeprom(31) == TRUE) { 
0F44:  MOVFF  FF2,1EF
0F48:  BCF    FF2.7
0F4A:  MOVLW  1F
0F4C:  MOVWF  FA9
0F4E:  BCF    FA6.6
0F50:  BCF    FA6.7
0F52:  BSF    FA6.0
0F54:  MOVF   FA8,W
0F56:  BTFSC  xEF.7
0F58:  BSF    FF2.7
0F5A:  SUBLW  01
0F5C:  BNZ   0F74
....................       OutputHigh(OUT_3, p16fRunning); 
0F5E:  MOVLW  00
0F60:  BTFSC  xEE.0
0F62:  MOVLW  01
0F64:  MOVWF  xEF
0F66:  MOVLW  10
0F68:  MOVWF  xF0
0F6A:  MOVFF  1EF,1F1
0F6E:  MOVLB  0
0F70:  RCALL  0E66
0F72:  MOVLB  1
....................    } 
....................    // 
....................    if (read_eeprom(32) == TRUE) { 
0F74:  MOVFF  FF2,1EF
0F78:  BCF    FF2.7
0F7A:  MOVLW  20
0F7C:  MOVWF  FA9
0F7E:  BCF    FA6.6
0F80:  BCF    FA6.7
0F82:  BSF    FA6.0
0F84:  MOVF   FA8,W
0F86:  BTFSC  xEF.7
0F88:  BSF    FF2.7
0F8A:  SUBLW  01
0F8C:  BNZ   0FA4
....................       OutputHigh(OUT_4, p16fRunning); 
0F8E:  MOVLW  00
0F90:  BTFSC  xEE.0
0F92:  MOVLW  01
0F94:  MOVWF  xEF
0F96:  MOVLW  22
0F98:  MOVWF  xF0
0F9A:  MOVFF  1EF,1F1
0F9E:  MOVLB  0
0FA0:  RCALL  0E66
0FA2:  MOVLB  1
....................    } 
....................    // 
....................    if (read_eeprom(33) == TRUE) { 
0FA4:  MOVFF  FF2,1EF
0FA8:  BCF    FF2.7
0FAA:  MOVLW  21
0FAC:  MOVWF  FA9
0FAE:  BCF    FA6.6
0FB0:  BCF    FA6.7
0FB2:  BSF    FA6.0
0FB4:  MOVF   FA8,W
0FB6:  BTFSC  xEF.7
0FB8:  BSF    FF2.7
0FBA:  SUBLW  01
0FBC:  BNZ   0FD4
....................       OutputHigh(OUT_5, p16fRunning); 
0FBE:  MOVLW  00
0FC0:  BTFSC  xEE.0
0FC2:  MOVLW  01
0FC4:  MOVWF  xEF
0FC6:  MOVLW  21
0FC8:  MOVWF  xF0
0FCA:  MOVFF  1EF,1F1
0FCE:  MOVLB  0
0FD0:  RCALL  0E66
0FD2:  MOVLB  1
....................    } 
....................    // 
....................    if (read_eeprom(34) == TRUE) { 
0FD4:  MOVFF  FF2,1EF
0FD8:  BCF    FF2.7
0FDA:  MOVLW  22
0FDC:  MOVWF  FA9
0FDE:  BCF    FA6.6
0FE0:  BCF    FA6.7
0FE2:  BSF    FA6.0
0FE4:  MOVF   FA8,W
0FE6:  BTFSC  xEF.7
0FE8:  BSF    FF2.7
0FEA:  SUBLW  01
0FEC:  BNZ   1004
....................       OutputHigh(OUT_6, p16fRunning); 
0FEE:  MOVLW  00
0FF0:  BTFSC  xEE.0
0FF2:  MOVLW  01
0FF4:  MOVWF  xEF
0FF6:  MOVLW  20
0FF8:  MOVWF  xF0
0FFA:  MOVFF  1EF,1F1
0FFE:  MOVLB  0
1000:  RCALL  0E66
1002:  MOVLB  1
....................    } 
....................    // 
....................    if (read_eeprom(35) == TRUE) { 
1004:  MOVFF  FF2,1EF
1008:  BCF    FF2.7
100A:  MOVLW  23
100C:  MOVWF  FA9
100E:  BCF    FA6.6
1010:  BCF    FA6.7
1012:  BSF    FA6.0
1014:  MOVF   FA8,W
1016:  BTFSC  xEF.7
1018:  BSF    FF2.7
101A:  SUBLW  01
101C:  BNZ   1034
....................       OutputHigh(OUT_7, p16fRunning); 
101E:  MOVLW  00
1020:  BTFSC  xEE.0
1022:  MOVLW  01
1024:  MOVWF  xEF
1026:  MOVLW  05
1028:  MOVWF  xF0
102A:  MOVFF  1EF,1F1
102E:  MOVLB  0
1030:  RCALL  0E66
1032:  MOVLB  1
....................    } 
....................    // 
....................    if (read_eeprom(36) == TRUE) { 
1034:  MOVFF  FF2,1EF
1038:  BCF    FF2.7
103A:  MOVLW  24
103C:  MOVWF  FA9
103E:  BCF    FA6.6
1040:  BCF    FA6.7
1042:  BSF    FA6.0
1044:  MOVF   FA8,W
1046:  BTFSC  xEF.7
1048:  BSF    FF2.7
104A:  SUBLW  01
104C:  BNZ   1064
....................       OutputHigh(OUT_8, p16fRunning); 
104E:  MOVLW  00
1050:  BTFSC  xEE.0
1052:  MOVLW  01
1054:  MOVWF  xEF
1056:  MOVLW  04
1058:  MOVWF  xF0
105A:  MOVFF  1EF,1F1
105E:  MOVLB  0
1060:  RCALL  0E66
1062:  MOVLB  1
....................    } 
....................     
....................    if (p16fRunning == TRUE) { 
1064:  BTFSS  xEE.0
1066:  BRA    106C
....................       output_high(OUT_IAM_RUNNING); 
1068:  BCF    F95.0
106A:  BSF    F8C.0
....................    } 
.................... } 
106C:  MOVLB  0
106E:  GOTO   6C8C (RETURN)
....................  
.................... #byte UCFG = 0xF6F  
.................... #bit UTRDIS = UCFG.3 
....................  
.................... void ResetEnc28J60(void) { 
....................    // Check to reset ENC28J60            
....................    output_low(PIN_ENC_MAC_RST); 
*
088C:  BCF    F95.2
088E:  BCF    F8C.2
....................    delay_ms(100);    
0890:  MOVLW  64
0892:  MOVLB  2
0894:  MOVWF  xA9
0896:  MOVLB  0
0898:  RCALL  00E6
....................    StackInit();    
089A:  RCALL  0854
....................    TCPClientInit(); 
089C:  RCALL  0864
.................... #ifdef USE_PORTD_LCD 
....................    printf(lcd_putc, "\f%s", "ENCRestarted"); 
.................... #endif 
.................... } 
089E:  RETLW  00
....................  
.................... // 
.................... #define T1InterruptPerS   12 
.................... int8 T1InterruptCounter; 
.................... #INT_TIMER1 
.................... void timer1_isr(void) { 
....................    // Will only do the following code if TIMER1 has interrupted 
....................  
....................    T1InterruptCounter++; 
08A0:  MOVLB  1
08A2:  INCF   xED,F
....................  
....................    /* 
....................    It is 1 seconds from reseting the Timer1 counter. 
....................    The loop of while(TRUE) inside main() is not working. Perhaps PIC gets stuck in a method and cannot come out. 
....................    Hmm, try to reset ENC. In many cases, the loop works again. 
....................    */ 
....................    if (T1InterruptCounter == T1InterruptPerS) {   
08A4:  MOVF   xED,W
08A6:  SUBLW  0C
08A8:  BNZ   08B4
.................... #ifdef USE_PORTD_LCD 
....................      printf(lcd_putc, "\f%s", "Crashed!ResetENC"); 
.................... #endif 
....................      ResetEnc28J60(); 
08AA:  MOVLB  0
08AC:  RCALL  088C
....................      clear_interrupt(INT_TIMER1); 
08AE:  BCF    F9E.0
....................    } 
....................  
....................    /* 
....................    It is 2 seconds from reseting the Timer1 counter. 
....................    The loop of while(TRUE) inside main() is not working any more. Perhaps PIC gets stuck in a method and cannot come out. 
....................    Hmm, there is no solution to make it work again unless using WDT to reset. 
....................    */ 
....................    else if (T1InterruptCounter == (T1InterruptPerS * 2)) { 
08B0:  BRA    08CE
08B2:  MOVLB  1
08B4:  MOVF   xED,W
08B6:  SUBLW  18
08B8:  BNZ   08D0
.................... #ifdef USE_PORTD_LCD 
....................      printf(lcd_putc, "\f%s", "Crashed!ResetPIC"); 
.................... #endif 
....................      clear_interrupt(INT_TIMER1); 
08BA:  BCF    F9E.0
....................      output_low(OUT_IAM_RUNNING); 
08BC:  BCF    F95.0
08BE:  BCF    F8C.0
....................      delay_ms(10); 
08C0:  MOVLW  0A
08C2:  MOVLB  2
08C4:  MOVWF  xA9
08C6:  MOVLB  0
08C8:  RCALL  00E6
....................      setup_wdt(WDT_ON);      
08CA:  BSF    FD1.0
....................      restart_wdt(); 
08CC:  CLRWDT
08CE:  MOVLB  1
....................    } 
.................... } 
....................  
08D0:  BCF    F9E.0
08D2:  MOVLB  0
08D4:  GOTO   006C
.................... void Timer1Init(void) { 
....................     setup_timer_1 ( T1_INTERNAL | T1_DIV_BY_4 ); // Internal clock and prescaler 8 
*
1124:  MOVLW  A5
1126:  MOVWF  FCD
....................     set_timer1(0);                               // Preload value 
1128:  CLRF   FCF
112A:  CLRF   FCE
....................     clear_interrupt(INT_TIMER1);                 // Clear Timer1 interrupt flag bit 
112C:  BCF    F9E.0
....................     enable_interrupts(INT_TIMER1);               // Enable Timer1 interrupt 
112E:  BSF    F9D.0
....................     enable_interrupts(GLOBAL); 
1130:  MOVLW  C0
1132:  IORWF  FF2,F
.................... } 
1134:  GOTO   6C94 (RETURN)
....................  
.................... void main(void) { 
*
6B60:  CLRF   FF8
6B62:  BCF    FD0.7
6B64:  BSF    07.7
6B66:  CLRF   FEA
6B68:  CLRF   FE9
6B6A:  CLRF   x7C
6B6C:  CLRF   x7B
6B6E:  CLRF   x7D
6B70:  CLRF   x7E
6B72:  CLRF   x86
6B74:  CLRF   x85
6B76:  MOVLW  04
6B78:  MOVWF  x89
6B7A:  CLRF   x88
6B7C:  MOVLW  FE
6B7E:  MOVLB  1
6B80:  MOVWF  xC9
6B82:  CLRF   xCE
6B84:  CLRF   xD0
6B86:  CLRF   xCF
6B88:  MOVF   FC1,W
6B8A:  ANDLW  C0
6B8C:  IORLW  0F
6B8E:  MOVWF  FC1
6B90:  MOVLW  07
6B92:  MOVWF  FB4
6B94:  MOVLB  0
6B96:  CLRF   x74
6B98:  CLRF   x75
6B9A:  CLRF   x87
6B9C:  BCF    x83.1
6B9E:  MOVLB  1
6BA0:  CLRF   x40
6BA2:  CLRF   x41
6BA4:  CLRF   x42
6BA6:  CLRF   x43
6BA8:  CLRF   x44
6BAA:  CLRF   x45
6BAC:  CLRF   x46
6BAE:  CLRF   x47
6BB0:  CLRF   x48
6BB2:  CLRF   x49
6BB4:  CLRF   x55
6BB6:  CLRF   x56
6BB8:  CLRF   x57
6BBA:  CLRF   x58
6BBC:  CLRF   x59
6BBE:  CLRF   x5A
6BC0:  CLRF   x5B
6BC2:  CLRF   x5C
6BC4:  CLRF   x5D
6BC6:  CLRF   x5E
6BC8:  CLRF   x5F
6BCA:  CLRF   x60
6BCC:  CLRF   x61
6BCE:  CLRF   x62
6BD0:  CLRF   x63
6BD2:  CLRF   x64
6BD4:  CLRF   x65
6BD6:  CLRF   x66
6BD8:  CLRF   x67
6BDA:  CLRF   x68
6BDC:  CLRF   x69
6BDE:  CLRF   x6A
6BE0:  CLRF   x6B
6BE2:  CLRF   x6C
6BE4:  CLRF   x6D
6BE6:  CLRF   x6E
6BE8:  CLRF   x6F
6BEA:  CLRF   x70
6BEC:  CLRF   x71
6BEE:  CLRF   x72
6BF0:  CLRF   x73
6BF2:  CLRF   x74
6BF4:  CLRF   x75
6BF6:  CLRF   x76
6BF8:  CLRF   x77
6BFA:  CLRF   x78
6BFC:  CLRF   x79
6BFE:  CLRF   x7A
6C00:  CLRF   x7B
6C02:  CLRF   x7C
6C04:  CLRF   x7D
6C06:  CLRF   x7E
6C08:  CLRF   x7F
6C0A:  CLRF   x80
6C0C:  CLRF   x81
6C0E:  CLRF   x82
6C10:  CLRF   x83
6C12:  CLRF   x84
6C14:  CLRF   x85
6C16:  CLRF   x86
6C18:  CLRF   x87
6C1A:  CLRF   x88
6C1C:  CLRF   x89
6C1E:  CLRF   x8A
6C20:  CLRF   x8B
6C22:  CLRF   x8C
6C24:  CLRF   x8D
6C26:  CLRF   x8E
6C28:  CLRF   x8F
6C2A:  CLRF   x90
6C2C:  CLRF   x91
6C2E:  CLRF   x92
6C30:  CLRF   x93
6C32:  CLRF   x94
6C34:  CLRF   x95
6C36:  CLRF   x96
6C38:  CLRF   x97
6C3A:  CLRF   x98
6C3C:  CLRF   x99
6C3E:  CLRF   x9A
6C40:  CLRF   xCA
6C42:  CLRF   xCB
6C44:  CLRF   xCC
6C46:  CLRF   xCD
....................    UTRDIS = 1;  
6C48:  BSF    F6F.3
....................    setup_adc(ADC_OFF); 
6C4A:  BCF    FC2.0
....................    setup_adc_ports(NO_ANALOGS);   
6C4C:  MOVF   FC1,W
6C4E:  ANDLW  C0
6C50:  IORLW  0F
6C52:  MOVWF  FC1
....................    ConfigInit(); 
6C54:  MOVLB  0
6C56:  GOTO   0DC2
....................    IOsConfig(); 
6C5A:  GOTO   0DDE
....................    delay_ms(500); 
6C5E:  MOVLW  02
6C60:  MOVLB  1
6C62:  MOVWF  xEE
6C64:  CLRF   19
6C66:  BTFSC  FF2.7
6C68:  BSF    19.7
6C6A:  BCF    FF2.7
6C6C:  MOVLW  FA
6C6E:  MOVLB  2
6C70:  MOVWF  xA9
6C72:  MOVLB  0
6C74:  CALL   00E6
6C78:  BTFSC  19.7
6C7A:  BSF    FF2.7
6C7C:  MOVLB  1
6C7E:  DECFSZ xEE,F
6C80:  BRA    6C64
....................    TCPLedOff(); 
6C82:  MOVLB  0
6C84:  CALL   0E1E
....................     
....................    OutputsRestore(); 
6C88:  GOTO   0EBA
....................    InputsScanInit();    
6C8C:  GOTO   10CA
....................     
.................... // The LCD must be initialized before MAC, IP and Stack    
.................... #ifdef USE_PORTD_LCD 
....................    lcd_init(); 
.................... #endif 
....................  
.................... #ifdef USE_PORTD_LCD 
....................    printf(lcd_putc, "\f%s", "IONOFF-P8"); 
....................    //printf(lcd_putc, "\nIN_RESET %d", input_state(IN_RESET)); 
....................    //printf(lcd_putc, "\n%u.%u.%u.%u", MY_IP_BYTE1, MY_IP_BYTE2, MY_IP_BYTE3, MY_IP_BYTE4); 
....................    printf(lcd_putc, "\n%u.%u.%u.%u", MY_SRV_IP_BYTES[0], MY_SRV_IP_BYTES[1], MY_SRV_IP_BYTES[2], MY_SRV_IP_BYTES[3]); 
....................    //printf(lcd_putc, "\n%u.%u.%u.%u", MY_GATE_BYTE1, MY_GATE_BYTE2, MY_GATE_BYTE3, MY_GATE_BYTE4); 
....................     
.................... #endif 
....................     
....................    Timer1Init(); 
6C90:  GOTO   1124
6C94:  CLRF   19
6C96:  BTFSC  FF2.7
6C98:  BSF    19.7
6C9A:  BCF    FF2.7
....................    StackInit();    
6C9C:  CALL   0854
6CA0:  BTFSC  19.7
6CA2:  BSF    FF2.7
....................    TCPClientInit();   
6CA4:  CALL   0864
....................    delay_ms(500); 
6CA8:  MOVLW  02
6CAA:  MOVLB  1
6CAC:  MOVWF  xEE
6CAE:  CLRF   19
6CB0:  BTFSC  FF2.7
6CB2:  BSF    19.7
6CB4:  BCF    FF2.7
6CB6:  MOVLW  FA
6CB8:  MOVLB  2
6CBA:  MOVWF  xA9
6CBC:  MOVLB  0
6CBE:  CALL   00E6
6CC2:  BTFSC  19.7
6CC4:  BSF    FF2.7
6CC6:  MOVLB  1
6CC8:  DECFSZ xEE,F
6CCA:  BRA    6CAE
....................    while (TRUE) { 
....................       // Reset the timer1 counter 
....................       T1InterruptCounter = 0; 
6CCC:  CLRF   xED
....................       StackTask(); 
6CCE:  MOVLB  0
6CD0:  GOTO   4486
....................       InsListen(); 
6CD4:  GOTO   4918
....................       TCPClientTask(); 
6CD8:  GOTO   6198
....................       if (IsTCPClientBusy == FALSE && EncTransactioCount > 24) { 
6CDC:  BTFSC  x83.4
6CDE:  BRA    6D00
6CE0:  MOVLB  1
6CE2:  MOVF   xA7,W
6CE4:  SUBLW  18
6CE6:  BTFSS  FD8.0
6CE8:  BRA    6CEE
6CEA:  MOVLB  0
6CEC:  BRA    6D00
6CEE:  CLRF   19
6CF0:  BTFSC  FF2.7
6CF2:  BSF    19.7
6CF4:  BCF    FF2.7
....................          ResetEnc28J60(); 
6CF6:  MOVLB  0
6CF8:  CALL   088C
6CFC:  BTFSC  19.7
6CFE:  BSF    FF2.7
....................       } 
....................    } 
6D00:  MOVLB  1
6D02:  BRA    6CCC
.................... } 
....................  
....................  
6D04:  SLEEP 

Configuration Fuses:
   Word  1: 8C24   PLL5 CPUDIV1 USBDIV HS NOFCMEN IESO
   Word  2: 0E19   NOPUT NOBROWNOUT BORV20 NOVREGEN NOWDT WDT128
   Word  3: 8100   CCP2C1 NOPBADEN NOLPT1OSC MCLR
   Word  4: 00A0   NOSTVREN NOLVP ICPRT NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
