CCS PCH C Compiler, Version 4.114, 93460303               23-May-17 22:30

               Filename: D:\Projects\ionoff\ionoff.controller\p4\source\main.lst

               ROM used: 27634 bytes (84%)
                         Largest free fragment is 5134
               RAM used: 495 (24%) at main() level
                         699 (34%) worst case
               Stack:    20 worst case (11 in main + 9 for interrupts)

*
0000:  GOTO   6A4C
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   00BA
0060:  BTFSS  F9D.0
0062:  GOTO   006C
0066:  BTFSC  F9E.0
0068:  GOTO   089C
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include <main.h> 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #include <config.h> 
.................... // ConexiÃ³n entre el PIC18F4550 y el Modulo ENC28J60 (Se conecta directamente sin adaptador de voltajes). 
.................... // Se adjunta el datasheet del Modulo ENC28J60. 
....................  
.................... /* 
.................... // The connection to enc28j60 is now defined in enc28j60.c file 
....................  
.................... #define  PIN_ENC_MAC_SO    PIN_C7   // Connect from PIN MISO to ENC28J60. 
.................... #define  PIN_ENC_MAC_SI    PIN_C6   // Connect from PIN MOSI to ENC28J60. 
.................... #define  PIN_ENC_MAC_CLK   PIN_D1   // Connect from PIN SCK to ENC28J60. 
.................... #define  PIN_ENC_MAC_CS    PIN_C0   // Connect from PIN CS to ENC28J60. 
.................... #define  PIN_ENC_MAC_RST   PIN_C2   // Connect from PIN RST to ENC28J60. 
.................... #define  PIN_ENC_MAC_INT   PIN_B1   // Connect from PIN INT to ENC28J60. 
.................... #define  PIN_ENC_MAC_WOL   PIN_B3   // Connect from PIN WOL to ENC28J60. 
.................... #define  PIN_ENC_MAC_CS    PIN_D3   // Connect from PIN CS to ENC28J60. 
.................... #define  PIN_ENC_MAC_RST   PIN_D2   // Connect from PIN RST to ENC28J60. 
.................... */     
....................  
.................... //Protocolos a utilizar.                           ----------------------------- 
....................  
.................... #define  STACK_USE_MCPENC  TRUE 
.................... #define  STACK_USE_ARP     TRUE 
.................... #define  STACK_USE_ICMP    TRUE 
.................... #define  STACK_USE_TCP     TRUE 
....................  
.................... //Comment to disable LCD 
.................... //#define USE_PORTD_LCD TRUE 
....................  
.................... //Output pins------------------------------------------------------------------- 
.................... #define  OUT_8  PIN_E2 // A4 
.................... #define  OUT_7  PIN_C0 // A5 
.................... #define  OUT_6  PIN_C1 // E0 
.................... #define  OUT_5  PIN_C2 // E1 
....................  
.................... #define  OUT_4  PIN_A4 // E2 
.................... #define  OUT_3  PIN_A5 // C0 
.................... #define  OUT_2  PIN_E0 // C1 
.................... #define  OUT_1  PIN_E1 // C2 
.................... #define  OUT_TCP_STATE PIN_B4 
.................... #define  OUT_IAM_RUNNING PIN_D0 
....................  
.................... //Input pins------------------------------------------------------------------- 
.................... #define  IN_8  PIN_D6 // B2 
.................... #define  IN_7  PIN_D5 // B1 
.................... #define  IN_6  PIN_C5 // B0 
.................... #define  IN_5  PIN_C4 // D7 
....................  
.................... #define  IN_4  PIN_B2 // D6 
.................... #define  IN_3  PIN_B1 // D5 
.................... #define  IN_2  PIN_B0 // C5 
.................... #define  IN_1  PIN_D7 // C4 
.................... #define  IN_RESET  PIN_B3 
.................... #define  IN_16F_RUNNING PIN_D1 
....................  
.................... #define INPUT_SWITCH 1 
.................... #define INPUT_BUTTON 2 
....................  
.................... BYTE MY_INPUT_TYPE_BYTES[8]; 
.................... BYTE MY_SRV_IP_BYTES[4]; 
....................  
.................... typedef struct _EEP_ROM { 
....................  
....................    BYTE Flag; 
....................    BYTE SrvIps[4]; 
....................    BYTE Ips[4]; 
....................    BYTE Masks[4]; 
....................    BYTE Gates[4]; 
....................    BYTE Macs[4]; // MAC bytes from 3-6 
....................    BYTE InputTypes[8];    
.................... } EEP_ROM; 
....................  
.................... EEP_ROM MyEEPRom; 
....................  
....................  
.................... #FUSES HS                       //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES PLL12                    //Divide By 12(48MHz oscillator input) 
.................... #FUSES CPUDIV4                  //System Clock by 4 
.................... #FUSES NOUSBDIV                 //USB clock source comes from primary oscillator 
.................... #FUSES NOFCMEN                  //Fail-safe clock monitor disabled 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES BORV20                   //Brownout reset at 2.0V 
.................... #FUSES NOVREGEN                 //USB voltage regulator disabled 
.................... #FUSES NOPBADEN                 //PORTB pins are configured as digital I/O on RESET 
.................... #FUSES NOLPT1OSC                //Timer1 configured for higher power operation 
.................... //#FUSES NOMCLR                 //Master Clear pin used for I/O 
.................... #FUSES NOSTVREN                 //Stack full/underflow will not cause reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES ICPRT                    //ICPRT enabled 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
....................  
.................... #use delay(crystal=20000000,  clock=20000000) 
*
00E6:  MOVLW  02
00E8:  MOVWF  FEA
00EA:  MOVLW  A9
00EC:  MOVWF  FE9
00EE:  MOVF   FEF,W
00F0:  BZ    010C
00F2:  MOVLW  06
00F4:  MOVWF  01
00F6:  CLRF   00
00F8:  DECFSZ 00,F
00FA:  BRA    00F8
00FC:  DECFSZ 01,F
00FE:  BRA    00F6
0100:  MOVLW  7B
0102:  MOVWF  00
0104:  DECFSZ 00,F
0106:  BRA    0104
0108:  DECFSZ FEF,F
010A:  BRA    00F2
010C:  RETLW  00
....................  
....................  
....................  
....................  
.................... #ifdef USE_PORTD_LCD 
.................... #include "lcd18f.c" 
.................... #endif 
....................  
.................... #include "tcpip/stacktsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *               Microchip TCP/IP Stack FSM Implementation on PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.c 
....................  * Dependencies:    StackTsk.H 
....................  *                  ARPTsk.h 
....................  *                  MAC.h 
....................  *                  IP.h 
....................  *                  ICMP.h 
....................  *                  Tcp.h 
....................  *                  http.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/14/01  Original (Rev. 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Nilesh Rajbharti     12/5/02     Modified UDPProcess() and TCPProcess() 
....................  *                                  to include localIP as third param. 
....................  *                                  This was done to allow these functions 
....................  *                                  to calculate checksum correctly. 
....................  * Nilesh Rajbharti     7/26/04     Added code in StackTask() to not 
....................  *                                  clear statically IP address if link is 
....................  *                                  removed and DHCP module is disabled 
....................  *                                  at runtime. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A break; added to StackTask() after handling an ARP, else it would goto IP handler. 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 improvement that resets DHCP after unlink of ethernet 
....................  * Darren Rook (CCS)    06/29/04 A fix for 2.20 improvement (see above) if DHCP was dynamically disabled 
....................  * Darren Rook (CCS)    06/29/04 smStack no longer static 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    04/08/05 Task() and Init() execute any needed HTTP code 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #define STACK_USE_FTP_SERVER STACK_USE_FTP 
....................  
.................... #define STACK_INCLUDE 
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC18 SFR Definitions 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        pic18.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or later 
....................  * 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     11/14/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  ********************************************************************/ 
.................... #ifndef COMPILER_H 
.................... #define COMPILER_H 
....................  
.................... #if !defined(__PCH__) 
.................... #error "This version only works with CCS PCH or PCWH" 
.................... #endif 
....................  
.................... // ** I/O PORT REGISTERS 
....................  
.................... #byte PORTA    =  0xF80 
.................... #byte PORTB    =  0xF81 
.................... #byte PORTC    =  0xF82 
.................... #byte PORTD    =  0xF83 
.................... #byte PORTE    =  0xF84 
.................... #byte PORTF    =  0xF85 
....................  
.................... #bit PORTA_RA5 =  0xF80.5 
.................... #bit PORTA_RA4 =  0xF80.4 
.................... #bit PORTA_RA3 =  0xF80.3 
.................... #bit PORTA_RA2 =  0xF80.2 
.................... #bit PORTA_RA1 =  0xF80.1 
.................... #bit PORTA_RA0 =  0xF80.0 
....................  
.................... #bit PORTB_RB7 =  0xF81.7 
.................... #bit PORTB_RB6 =  0xF81.6 
.................... #bit PORTB_RB5 =  0xF81.5 
.................... #bit PORTB_RB4 =  0xF81.4 
.................... #bit PORTB_RB3 =  0xF81.3 
.................... #bit PORTB_RB2 =  0xF81.2 
.................... #bit PORTB_RB1 =  0xF81.1 
.................... #bit PORTB_RB0 =  0xF81.0 
....................  
.................... #bit PORTC_RC7 =  0xF82.7 
.................... #bit PORTC_RC6 =  0xF82.6 
.................... #bit PORTC_RC5 =  0xF82.5 
.................... #bit PORTC_RC4 =  0xF82.4 
.................... #bit PORTC_RC3 =  0xF82.3 
.................... #bit PORTC_RC2 =  0xF82.2 
.................... #bit PORTC_RC1 =  0xF82.1 
.................... #bit PORTC_RC0 =  0xF82.0 
....................  
.................... #bit PORTD_RD7 =  0xF83.7 
.................... #bit PORTD_RD6 =  0xF83.6 
.................... #bit PORTD_RD5 =  0xF83.5 
.................... #bit PORTD_RD4 =  0xF83.4 
.................... #bit PORTD_RD3 =  0xF83.3 
.................... #bit PORTD_RD2 =  0xF83.2 
.................... #bit PORTD_RD1 =  0xF83.1 
.................... #bit PORTD_RD0 =  0xF83.0 
....................  
.................... #bit PORTE_RE7 =  0xF84.7 
.................... #bit PORTE_RE6 =  0xF84.6 
.................... #bit PORTE_RE5 =  0xF84.5 
.................... #bit PORTE_RE4 =  0xF84.4 
.................... #bit PORTE_RE3 =  0xF84.3 
.................... #bit PORTE_RE2 =  0xF84.2 
.................... #bit PORTE_RE1 =  0xF84.1 
.................... #bit PORTE_RE0 =  0xF84.0 
....................  
.................... #bit PORTF_RF7 =  0xF85.7 
.................... #bit PORTF_RF6 =  0xF85.6 
.................... #bit PORTF_RF5 =  0xF85.5 
.................... #bit PORTF_RF4 =  0xF85.4 
.................... #bit PORTF_RF3 =  0xF85.3 
.................... #bit PORTF_RF2 =  0xF85.2 
.................... #bit PORTF_RF1 =  0xF85.1 
.................... #bit PORTF_RF0 =  0xF85.0 
....................  
....................  
.................... // *** TRIS REGISTERS 
....................  
.................... #byte TRISA    =  0xF92 
.................... #byte TRISB    =  0xF93 
.................... #byte TRISC    =  0xF94 
.................... #byte TRISD    =  0xF95 
.................... #byte TRISE    =  0xF96 
.................... #byte TRISF    =  0xF97 
....................  
.................... #bit TRISA_RA7 =  0xF92.7 
.................... #bit TRISA_RA6 =  0xF92.6 
.................... #bit TRISA_RA5 =  0xF92.5 
.................... #bit TRISA_RA4 =  0xF92.4 
.................... #bit TRISA_RA3 =  0xF92.3 
.................... #bit TRISA_RA2 =  0xF92.2 
.................... #bit TRISA_RA1 =  0xF92.1 
.................... #bit TRISA_RA0 =  0xF92.0 
....................  
.................... #bit TRISB_RB7 =  0xF93.7 
.................... #bit TRISB_RB6 =  0xF93.6 
.................... #bit TRISB_RB5 =  0xF93.5 
.................... #bit TRISB_RB4 =  0xF93.4 
.................... #bit TRISB_RB3 =  0xF93.3 
.................... #bit TRISB_RB2 =  0xF93.2 
.................... #bit TRISB_RB1 =  0xF93.1 
.................... #bit TRISB_RB0 =  0xF93.0 
....................  
.................... #bit TRISC_RC7 =  0xF94.7 
.................... #bit TRISC_RC6 =  0xF94.6 
.................... #bit TRISC_RC5 =  0xF94.5 
.................... #bit TRISC_RC4 =  0xF94.4 
.................... #bit TRISC_RC3 =  0xF94.3 
.................... #bit TRISC_RC2 =  0xF94.2 
.................... #bit TRISC_RC1 =  0xF94.1 
.................... #bit TRISC_RC0 =  0xF94.0 
....................  
.................... #bit TRISD_RD7 =  0xF95.7 
.................... #bit TRISD_RD6 =  0xF95.6 
.................... #bit TRISD_RD5 =  0xF95.5 
.................... #bit TRISD_RD4 =  0xF95.4 
.................... #bit TRISD_RD3 =  0xF95.3 
.................... #bit TRISD_RD2 =  0xF95.2 
.................... #bit TRISD_RD1 =  0xF95.1 
.................... #bit TRISD_RD0 =  0xF95.0 
....................  
.................... #bit TRISE_RE7 =  0xF96.7 
.................... #bit TRISE_RE6 =  0xF96.6 
.................... #bit TRISE_RE5 =  0xF96.5 
.................... #bit TRISE_RE4 =  0xF96.4 
.................... #bit TRISE_RE3 =  0xF96.3 
.................... #bit TRISE_RE2 =  0xF96.2 
.................... #bit TRISE_RE1 =  0xF96.1 
.................... #bit TRISE_RE0 =  0xF96.0 
....................  
.................... #bit TRISF_RF7 =  0xF97.7 
.................... #bit TRISF_RF6 =  0xF97.6 
.................... #bit TRISF_RF5 =  0xF97.5 
.................... #bit TRISF_RF4 =  0xF97.4 
.................... #bit TRISF_RF3 =  0xF97.3 
.................... #bit TRISF_RF2 =  0xF97.2 
.................... #bit TRISF_RF1 =  0xF97.1 
.................... #bit TRISF_RF0 =  0xF97.0 
....................  
....................  
.................... // *** LAT REGISTERS 
.................... #byte LATA    =  0xF89 
.................... #byte LATB    =  0xF8A 
.................... #byte LATC    =  0xF8B 
.................... #byte LATD    =  0xF8C 
.................... #byte LATE    =  0xF8D 
.................... #byte LATF    =  0xF8E 
....................  
.................... #bit LATA_RA7 =  0xF89.7 
.................... #bit LATA_RA6 =  0xF89.6 
.................... #bit LATA_RA5 =  0xF89.5 
.................... #bit LATA_RA4 =  0xF89.4 
.................... #bit LATA_RA3 =  0xF89.3 
.................... #bit LATA_RA2 =  0xF89.2 
.................... #bit LATA_RA1 =  0xF89.1 
.................... #bit LATA_RA0 =  0xF89.0 
....................  
.................... #bit LATB_RB7 =  0xF8A.7 
.................... #bit LATB_RB6 =  0xF8A.6 
.................... #bit LATB_RB5 =  0xF8A.5 
.................... #bit LATB_RB4 =  0xF8A.4 
.................... #bit LATB_RB3 =  0xF8A.3 
.................... #bit LATB_RB2 =  0xF8A.2 
.................... #bit LATB_RB1 =  0xF8A.1 
.................... #bit LATB_RB0 =  0xF8A.0 
....................  
.................... #bit LATC_RC7 =  0xF8B.7 
.................... #bit LATC_RC6 =  0xF8B.6 
.................... #bit LATC_RC5 =  0xF8B.5 
.................... #bit LATC_RC4 =  0xF8B.4 
.................... #bit LATC_RC3 =  0xF8B.3 
.................... #bit LATC_RC2 =  0xF8B.2 
.................... #bit LATC_RC1 =  0xF8B.1 
.................... #bit LATC_RC0 =  0xF8B.0 
....................  
.................... #bit LATD_RD7 =  0xF8C.7 
.................... #bit LATD_RD6 =  0xF8C.6 
.................... #bit LATD_RD5 =  0xF8C.5 
.................... #bit LATD_RD4 =  0xF8C.4 
.................... #bit LATD_RD3 =  0xF8C.3 
.................... #bit LATD_RD2 =  0xF8C.2 
.................... #bit LATD_RD1 =  0xF8C.1 
.................... #bit LATD_RD0 =  0xF8C.0 
....................  
.................... #bit LATE_RE7 =  0xF8D.7 
.................... #bit LATE_RE6 =  0xF8D.6 
.................... #bit LATE_RE5 =  0xF8D.5 
.................... #bit LATE_RE4 =  0xF8D.4 
.................... #bit LATE_RE3 =  0xF8D.3 
.................... #bit LATE_RE2 =  0xF8D.2 
.................... #bit LATE_RE1 =  0xF8D.1 
.................... #bit LATE_RE0 =  0xF8D.0 
....................  
.................... #bit LATF_RF7 =  0xF8E.7 
.................... #bit LATF_RF6 =  0xF8E.6 
.................... #bit LATF_RF5 =  0xF8E.5 
.................... #bit LATF_RF4 =  0xF8E.4 
.................... #bit LATF_RF3 =  0xF8E.3 
.................... #bit LATF_RF2 =  0xF8E.2 
.................... #bit LATF_RF1 =  0xF8E.1 
.................... #bit LATF_RF0 =  0xF8E.0 
....................  
....................  
.................... // ** OTHER SPECIAL FILE REGISTERS USED BY SLIP 
....................  
.................... #bit  PIE1_TXIE       =  0xF9D.4 
.................... #bit  PIE1_RCIE       =  0xF9D.5 
.................... #bit  PIR1_TXIF       =  0xF9E.4 
.................... #bit  PIR1_RCIF       =  0xF9E.5 
.................... #byte TXSTA           =  0xFAC 
.................... #byte RCSTA           =  0xFAB 
.................... #bit  RCSTA_CREN      =  0xFAB.4 
.................... #byte RCREG           =  0xFAE 
.................... #byte SPBRG           =  0xFAF 
.................... #byte TXREG           =  0xFAD 
....................  
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                         HARDWARE.H                                //// 
.................... ////                                                                   //// 
.................... //// Hardware I/O definitions and TCP/IP stack configuration settings. //// 
.................... ////                                                                   //// 
.................... //// These values will probably change with each application.          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... ////    Jan 15, 2004: MODEM_RESPONSE_TIMEOUT and MODEM_CONNECT_TIMEOUT //// 
.................... ////                  moved to here.                                   //// 
.................... ////                                                                   //// 
.................... ////    Jan 09, 2004: Initial Public Release                           //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF ___TCPIP_STACK_CONFIGURATION 
.................... #define ___TCPIP_STACK_CONFIGURATION 
....................  
.................... #ifndef STACK_USE_CCS_PICNET 
.................... #define STACK_USE_CCS_PICNET  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_CCS_PICENS 
.................... #define STACK_USE_CCS_PICENS  FALSE 
.................... #endif 
....................  
.................... /* 
....................  #use fast_io(A) 
....................  #use fast_io(B) 
....................  #use fast_io(C) 
....................  #if STACK_USE_CCS_PICNET || STACK_USE_CCS_PICEEC || STACK_USE_CCS_EWL3V 
....................  #use fast_io(F) 
....................  #endif 
....................  
....................  
....................  //// VARIOUS MODEM SETTINGS. 
....................  #DEFINE  MODEM_DCD         PIN_G3 
....................  #DEFINE  MODEM_RESET       PIN_G4 
....................  #define  MODEM_TX          PIN_G1 
....................  #define  MODEM_RX          PIN_G2 
....................  #DEFINE  MODEM_INIT_STR    "ATM1L3&K0"   //speaker on, volume high, no hw flow control 
....................  #DEFINE  MODEM_DIAL_STR    "ATDT" 
....................  #DEFINE  MODEM_BAUD_RATE   115200 
....................  
....................  #DEFINE  MODEM_RESPONSE_TIMEOUT  2000     //time to wait for a response to an AT command (in ms) 
....................  #DEFINE  MODEM_CONNECT_TIMEOUT   120000    //time to wait for modem to make a connection (in ms) 
....................  
....................  
....................  //// VARIOUS MAC/NIC SETTINGS. 
....................  #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................  #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................  #define PIN_ENC_MAC_CLK PIN_C3 
....................  #define PIN_ENC_MAC_CS  PIN_C0 
....................  #define PIN_ENC_MAC_RST PIN_C1 
....................  #define PIN_ENC_MAC_INT PIN_C6 
....................  #define PIN_ENC_MAC_WOL PIN_C7 
....................  #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................  #define mac_enc_spi_tris_init()//  TRISB=(TRISB | 0b11); TRISC = (TRISC & 0b11010111) | 0x10; TRISD=TRISD & 0xF4//was 0xFC 
....................  
....................  #if STACK_USE_CCS_PICNET 
....................  //Latch and Directional control SFR locations for the 3 control pins 
....................  #define NIC_RESET_LAT       LATE_RE7 
....................  #define NIC_IOW_LAT         LATE_RE6 
....................  #define NIC_IOR_LAT         LATE_RE5 
....................  #define NIC_RESET_TRIS      TRISE_RE7 
....................  #define NIC_IOW_TRIS        TRISE_RE6 
....................  #define NIC_IOR_TRIS        TRISE_RE5 
....................  
....................  //Latch and Directional control SFR locations for the 5bit address port 
....................  #define NIC_ADDR_LAT        LATE 
....................  #define NIC_ADDR_TRIS       TRISE 
....................  
....................  //Latch, Directional and I/O SFR locations for the 8bit data port 
....................  #define NIC_DATA_IO         PORTF 
....................  #define NIC_DATA_LAT        LATF 
....................  #define NIC_DATA_TRIS       TRISF 
....................  
....................  //This macro takes an address and properly outputs it on the latch register, and sets proper pins to output. 
....................  //Leaves other pins alone. 
....................  #define WRITE_NIC_ADDR(a)   NIC_ADDR_LAT = (NIC_ADDR_LAT & 0xE0)|a; \ 
....................                                 NIC_ADDR_TRIS = NIC_ADDR_TRIS & 0xE0 
....................  #elif STACK_USE_MCPENC 
....................  #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................  #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................  #define PIN_ENC_MAC_CLK PIN_C3 
....................  #define PIN_ENC_MAC_CS  PIN_D1 
....................  #define PIN_ENC_MAC_RST PIN_D0 
....................  #define PIN_ENC_MAC_INT PIN_B0 
....................  #define PIN_ENC_MAC_WOL PIN_B1 
....................  #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................  #define mac_enc_spi_tris_init()  TRISB=(TRISB | 0b11); TRISC = (TRISC & 0b11010111) | 0x10; TRISD=TRISD & 0xF4//was 0xFC 
....................  #elif STACK_USE_CCS_EWL5V 
....................  #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................  #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................  #define PIN_ENC_MAC_CLK PIN_C3 
....................  #define PIN_ENC_MAC_CS  PIN_A4 
....................  #define PIN_ENC_MAC_RST PIN_B5 
....................  #define PIN_ENC_MAC_INT PIN_B2 
....................  #define PIN_ENC_MAC_WOL PIN_B3 
....................  #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................  #define mac_enc_spi_tris_init()  TRISB=(TRISB | 0b00001100)&0b11011111; TRISC = (TRISC & 0b11010111) | 0x10; TRISA=TRISA & 0b11101111 
....................  #else 
....................  #error Please define your MAC/NIC I/O settings 
....................  #endif 
....................  */ 
....................  
.................... //// SET TCP_NO_WAIT_FOR_ACK TO FALSE IF TCP STACK SHOULD WAIT FOR ACK FROM 
.................... //// REMOTE HOST BEFORE TRANSMITTING ANOTHER PACKET.  THIS MAY REDUCE THROUGHPUT. 
.................... //// DEFAULT VALUE (TRUE) GETS LOADED IN TCP.H IF THIS LINE IS REMOVED. 
.................... #define TCP_NO_WAIT_FOR_ACK   FALSE 
....................  
.................... ///DEFAULT HARDCODED IP ADDRESSES. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THESE TO AN EEPROM. 
.................... ///  OR USE AUTO IP ASSIGNMENT (DHCP). 
.................... ///  NO TWO DEVICES ON A NETwORK CAN HAVE THE SAME IP ADDRESS 
.................... #define MY_DEFAULT_IP_ADDR_BYTE1        192   //IP ADDRESS 
.................... #define MY_DEFAULT_IP_ADDR_BYTE2        168   // This unit's IP address. 
.................... #define MY_DEFAULT_IP_ADDR_BYTE3        1 
.................... #define MY_DEFAULT_IP_ADDR_BYTE4        129 
....................  
.................... #define MY_DEFAULT_MASK_BYTE1           255 // NETMASK 
.................... #define MY_DEFAULT_MASK_BYTE2           255 // Netmask tells the IP / ARP stack which 
.................... #define MY_DEFAULT_MASK_BYTE3           255 // IP's are on your local network. 
.................... #define MY_DEFAULT_MASK_BYTE4           0 
....................  
.................... #define MY_DEFAULT_GATE_BYTE1           192  //GATEWAY IP ADDRESS 
.................... #define MY_DEFAULT_GATE_BYTE2           168  // Gateway acts as a conduit between two networks. 
.................... #define MY_DEFAULT_GATE_BYTE3           1 
.................... #define MY_DEFAULT_GATE_BYTE4           1 
....................  
.................... ///DEFAULT HARDCODED MAC ADDRESS. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THIS TO AN EEPROM, OR GENERATE 
.................... ///  A DYNAMIC ONE BASED UPON UNIT'S SERIAL NUMBER. 
.................... ///  NO TWO DEVICES ON THE SAME ETHERNET NETWORK CAN HAVE THE SAME MAC ADDRESS. 
.................... #define MY_DEFAULT_MAC_BYTE1            0x00 
.................... #define MY_DEFAULT_MAC_BYTE2            0x04 
.................... #define MY_DEFAULT_MAC_BYTE3            0xa3 
.................... #define MY_DEFAULT_MAC_BYTE4            0x00 
.................... #define MY_DEFAULT_MAC_BYTE5            0x00 
.................... #define MY_DEFAULT_MAC_BYTE6            0x00 
....................  
.................... ///Maximum sockets to be defined. 
.................... /// Note that each socket consumes 36 bytes of RAM. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... ///Avaialble UDP Socket 
.................... /// DCHP takes 1 socket. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... ///BUFFER SIZE DEFINITIONS 
.................... /// 
.................... /// For SLIP, there can only be one transmit and one receive buffer. 
.................... /// Both buffer must fit in one bank.  If bigger buffer is required, 
.................... /// you must manually locate tx and rx buffer in different bank 
.................... /// or modify your linker script file to support arrays bigger than 
.................... /// 256 bytes. 
.................... /// I think Microchip needs MAC_RX_BUFFER_SIZE to equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For PPP, there can only be one transmit and one receive buffer. 
.................... /// You can receive messages larger than the receive buffer if your 
.................... /// routines are fast enough.  You cannot transmit messages larger 
.................... /// than the TX buffer.  The larger the buffer you can make, the better. 
.................... /// BUG: MAC_RX_BUFFER_SIZE must equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For Ethernet, the Ethernet controler has many buffers that are 
.................... /// 1k in size.   Only one buffer is used for TX, rest are for RX. 
.................... /// Unlike SLIP and PPP, no RAM is used for these buffers. 
.................... #if STACK_USE_MAC 
.................... #define MAC_TX_BUFFER_SIZE          1024 //do not modify this line 
.................... #define MAC_TX_BUFFER_COUNT         1    //do not modify this line 
.................... #elif STACK_USE_PPP 
.................... #define MAC_TX_BUFFER_SIZE          1024 
.................... #define MAC_TX_BUFFER_COUNT         1 
.................... #elif STACK_USE_SLIP 
.................... #define MAC_TX_BUFFER_SIZE          250 
.................... #define MAC_TX_BUFFER_COUNT         1 
.................... #endif 
....................  
.................... #define MAC_RX_BUFFER_SIZE              MAC_TX_BUFFER_SIZE  //do not modify this line unless you are certain you know what you're doing 
....................  
.................... #endif 
....................  
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
58B8:  MOVLB  2
58BA:  CLRF   x2C
....................    sign = 0; 
58BC:  CLRF   x2A
....................    base = 10; 
58BE:  MOVLW  0A
58C0:  MOVWF  x2B
....................    result = 0; 
58C2:  CLRF   x29
....................  
....................    if (!s) 
58C4:  MOVF   x27,W
58C6:  IORWF  x28,W
58C8:  BNZ   58D0
....................       return 0; 
58CA:  MOVLW  00
58CC:  MOVWF  01
58CE:  BRA    5A56
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
58D0:  MOVF   x2C,W
58D2:  INCF   x2C,F
58D4:  CLRF   03
58D6:  ADDWF  x27,W
58D8:  MOVWF  FE9
58DA:  MOVF   x28,W
58DC:  ADDWFC 03,W
58DE:  MOVWF  FEA
58E0:  MOVFF  FEF,22D
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
58E4:  MOVF   x2D,W
58E6:  SUBLW  2D
58E8:  BNZ   5904
....................    { 
....................       sign = 1;         // Set the sign to negative 
58EA:  MOVLW  01
58EC:  MOVWF  x2A
....................       c = s[index++]; 
58EE:  MOVF   x2C,W
58F0:  INCF   x2C,F
58F2:  CLRF   03
58F4:  ADDWF  x27,W
58F6:  MOVWF  FE9
58F8:  MOVF   x28,W
58FA:  ADDWFC 03,W
58FC:  MOVWF  FEA
58FE:  MOVFF  FEF,22D
....................    } 
....................    else if (c == '+') 
5902:  BRA    591E
5904:  MOVF   x2D,W
5906:  SUBLW  2B
5908:  BNZ   591E
....................    { 
....................       c = s[index++]; 
590A:  MOVF   x2C,W
590C:  INCF   x2C,F
590E:  CLRF   03
5910:  ADDWF  x27,W
5912:  MOVWF  FE9
5914:  MOVF   x28,W
5916:  ADDWFC 03,W
5918:  MOVWF  FEA
591A:  MOVFF  FEF,22D
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
591E:  MOVF   x2D,W
5920:  SUBLW  2F
5922:  BTFSC  FD8.0
5924:  BRA    5A46
5926:  MOVF   x2D,W
5928:  SUBLW  39
592A:  BTFSS  FD8.0
592C:  BRA    5A46
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
592E:  MOVF   x2D,W
5930:  SUBLW  30
5932:  BNZ   5976
5934:  CLRF   03
5936:  MOVF   x2C,W
5938:  ADDWF  x27,W
593A:  MOVWF  FE9
593C:  MOVF   x28,W
593E:  ADDWFC 03,W
5940:  MOVWF  FEA
5942:  MOVF   FEF,W
5944:  SUBLW  78
5946:  BZ    595C
5948:  CLRF   03
594A:  MOVF   x2C,W
594C:  ADDWF  x27,W
594E:  MOVWF  FE9
5950:  MOVF   x28,W
5952:  ADDWFC 03,W
5954:  MOVWF  FEA
5956:  MOVF   FEF,W
5958:  SUBLW  58
595A:  BNZ   5976
....................       { 
....................          base = 16; 
595C:  MOVLW  10
595E:  MOVWF  x2B
....................          index++; 
5960:  INCF   x2C,F
....................          c = s[index++]; 
5962:  MOVF   x2C,W
5964:  INCF   x2C,F
5966:  CLRF   03
5968:  ADDWF  x27,W
596A:  MOVWF  FE9
596C:  MOVF   x28,W
596E:  ADDWFC 03,W
5970:  MOVWF  FEA
5972:  MOVFF  FEF,22D
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
5976:  MOVF   x2B,W
5978:  SUBLW  0A
597A:  BNZ   59B6
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
597C:  MOVF   x2D,W
597E:  SUBLW  2F
5980:  BC    59B4
5982:  MOVF   x2D,W
5984:  SUBLW  39
5986:  BNC   59B4
....................             result = 10*result + (c - '0'); 
5988:  MOVLW  0A
598A:  MOVWF  x2E
598C:  MOVFF  229,22F
5990:  MOVLB  0
5992:  BRA    5868
5994:  MOVLW  30
5996:  MOVLB  2
5998:  SUBWF  x2D,W
599A:  ADDWF  01,W
599C:  MOVWF  x29
....................             c = s[index++]; 
599E:  MOVF   x2C,W
59A0:  INCF   x2C,F
59A2:  CLRF   03
59A4:  ADDWF  x27,W
59A6:  MOVWF  FE9
59A8:  MOVF   x28,W
59AA:  ADDWFC 03,W
59AC:  MOVWF  FEA
59AE:  MOVFF  FEF,22D
....................          } 
59B2:  BRA    597C
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
59B4:  BRA    5A46
59B6:  MOVF   x2B,W
59B8:  SUBLW  10
59BA:  BNZ   5A46
....................       { 
....................          c = toupper(c); 
59BC:  MOVF   x2D,W
59BE:  SUBLW  60
59C0:  BC    59CE
59C2:  MOVF   x2D,W
59C4:  SUBLW  7A
59C6:  BNC   59CE
59C8:  MOVF   x2D,W
59CA:  ANDLW  DF
59CC:  BRA    59D0
59CE:  MOVF   x2D,W
59D0:  MOVWF  x2D
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
59D2:  MOVF   x2D,W
59D4:  SUBLW  2F
59D6:  BC    59DE
59D8:  MOVF   x2D,W
59DA:  SUBLW  39
59DC:  BC    59EA
59DE:  MOVF   x2D,W
59E0:  SUBLW  40
59E2:  BC    5A46
59E4:  MOVF   x2D,W
59E6:  SUBLW  46
59E8:  BNC   5A46
....................             if (c >= '0' && c <= '9') 
59EA:  MOVF   x2D,W
59EC:  SUBLW  2F
59EE:  BC    5A08
59F0:  MOVF   x2D,W
59F2:  SUBLW  39
59F4:  BNC   5A08
....................                result = (result << 4) + (c - '0'); 
59F6:  SWAPF  x29,W
59F8:  MOVWF  x2E
59FA:  MOVLW  F0
59FC:  ANDWF  x2E,F
59FE:  MOVLW  30
5A00:  SUBWF  x2D,W
5A02:  ADDWF  x2E,W
5A04:  MOVWF  x29
....................             else 
5A06:  BRA    5A1A
....................                result = (result << 4) + (c - 'A' + 10); 
5A08:  SWAPF  x29,W
5A0A:  MOVWF  x2E
5A0C:  MOVLW  F0
5A0E:  ANDWF  x2E,F
5A10:  MOVLW  41
5A12:  SUBWF  x2D,W
5A14:  ADDLW  0A
5A16:  ADDWF  x2E,W
5A18:  MOVWF  x29
....................  
....................             c = s[index++]; 
5A1A:  MOVF   x2C,W
5A1C:  INCF   x2C,F
5A1E:  CLRF   03
5A20:  ADDWF  x27,W
5A22:  MOVWF  FE9
5A24:  MOVF   x28,W
5A26:  ADDWFC 03,W
5A28:  MOVWF  FEA
5A2A:  MOVFF  FEF,22D
....................             c = toupper(c); 
5A2E:  MOVF   x2D,W
5A30:  SUBLW  60
5A32:  BC    5A40
5A34:  MOVF   x2D,W
5A36:  SUBLW  7A
5A38:  BNC   5A40
5A3A:  MOVF   x2D,W
5A3C:  ANDLW  DF
5A3E:  BRA    5A42
5A40:  MOVF   x2D,W
5A42:  MOVWF  x2D
....................          } 
5A44:  BRA    59D2
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
5A46:  DECFSZ x2A,W
5A48:  BRA    5A52
5A4A:  MOVF   x2B,W
5A4C:  SUBLW  0A
5A4E:  BNZ   5A52
....................        result = -result; 
5A50:  NEGF   x29
....................  
....................    return(result); 
5A52:  MOVFF  229,01
.................... } 
5A56:  MOVLB  0
5A58:  RETLW  00
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
0690:  MOVFF  79,2AE
0694:  MOVFF  78,2AD
0698:  MOVFF  77,2AC
069C:  MOVFF  76,2AB
06A0:  MOVLW  41
06A2:  MOVLB  2
06A4:  MOVWF  xB2
06A6:  MOVLW  C6
06A8:  MOVWF  xB1
06AA:  MOVLW  4E
06AC:  MOVWF  xB0
06AE:  MOVLW  6D
06B0:  MOVWF  xAF
06B2:  MOVLB  0
06B4:  RCALL  05EE
06B6:  MOVLW  39
06B8:  MOVLB  2
06BA:  ADDWF  00,W
06BC:  MOVLB  0
06BE:  MOVWF  x76
06C0:  MOVLW  30
06C2:  MOVLB  2
06C4:  ADDWFC 01,W
06C6:  MOVLB  0
06C8:  MOVWF  x77
06CA:  MOVLW  00
06CC:  MOVLB  2
06CE:  ADDWFC 02,W
06D0:  MOVLB  0
06D2:  MOVWF  x78
06D4:  MOVLW  00
06D6:  MOVLB  2
06D8:  ADDWFC 03,W
06DA:  MOVLB  0
06DC:  MOVWF  x79
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
06DE:  MOVFF  78,00
06E2:  MOVFF  79,01
06E6:  CLRF   02
06E8:  CLRF   03
06EA:  MOVFF  79,2AD
06EE:  MOVFF  78,2AC
06F2:  MOVFF  79,2AF
06F6:  MOVFF  78,2AE
06FA:  MOVLW  7F
06FC:  MOVLB  2
06FE:  MOVWF  xB1
0700:  MOVLW  FF
0702:  MOVWF  xB0
0704:  MOVLB  0
0706:  RCALL  064A
0708:  MOVFF  00,01
070C:  MOVFF  03,02
.................... } 
0710:  RETLW  00
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
05DC:  MOVFF  2AE,79
05E0:  MOVFF  2AD,78
05E4:  MOVFF  2AC,77
05E8:  MOVFF  2AB,76
.................... } 
05EC:  RETLW  00
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Functions for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.C 
....................  * Dependencies:    compiler.h 
....................  *                  helpers.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     6/25/02  Rewritten CalcIPChecksum() to avoid 
....................  *                               multi-byte shift operation. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Howard Schlunder      2/9/05   Added hexatob(), btohexa_high(), and 
....................  *                        btohexa_low() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE hexatob(WORD_VAL AsciiChars) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           Two ascii bytes; each ranged '0'-'9', 'A'-'F', or 
....................  *                  'a'-'f' 
....................  * 
....................  * Output:          The resulting packed byte: 0x00-0xFF 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:         None 
....................  ********************************************************************/ 
.................... BYTE hexatob(WORD_VAL AsciiChars) { 
.................... 	// Convert lowercase to uppercase 
.................... 	if (AsciiChars.v[1] > 'F') 
.................... 		AsciiChars.v[1] -= 'a' - 'A'; 
.................... 	if (AsciiChars.v[0] > 'F') 
.................... 		AsciiChars.v[0] -= 'a' - 'A'; 
....................  
.................... 	// Convert 0-9, A-F to 0x0-0xF 
.................... 	if (AsciiChars.v[1] > '9') 
.................... 		AsciiChars.v[1] -= 'A' - 10; 
.................... 	else 
.................... 		AsciiChars.v[1] -= '0'; 
....................  
.................... 	if (AsciiChars.v[0] > '9') 
.................... 		AsciiChars.v[0] -= 'A' - 10; 
.................... 	else 
.................... 		AsciiChars.v[0] -= '0'; 
....................  
.................... 	// Concatenate 
.................... 	return (AsciiChars.v[1] << 4) | AsciiChars.v[0]; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_high(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *               or 'A'-'F' that corresponds to the upper 4 bits of 
....................  *               the input byte. 
....................  *               ex: b = 0xAE, btohexa_high() returns 'A' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:         None 
....................  ********************************************************************/ 
.................... BYTE btohexa_high(BYTE b) { 
.................... 	b >>= 4; 
.................... 	return (b > 0x9) ? b + 'A' - 10 : b + '0'; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_low(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *               or 'A'-'F' that corresponds to the lower 4 bits of 
....................  *               the input byte. 
....................  *               ex: b = 0xAE, btohexa_low() returns 'E' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:         None 
....................  ********************************************************************/ 
.................... BYTE btohexa_low(BYTE b) { 
.................... 	b &= 0x0F; 
.................... 	return (b > 9) ? b + 'A' - 10 : b + '0'; 
.................... } 
....................  
.................... WORD swaps(WORD_VAL v) { 
.................... 	WORD_VAL new; 
....................  
.................... 	new.v[0] = v.v[1]; 
*
118C:  MOVFF  29A,29B
.................... 	new.v[1] = v.v[0]; 
1190:  MOVFF  299,29C
....................  
.................... 	return (new.Val); 
1194:  MOVLB  2
1196:  MOVFF  29B,01
119A:  MOVFF  29C,02
.................... } 
119E:  MOVLB  0
11A0:  RETLW  00
....................  
.................... DWORD swapl(DWORD_VAL v) { 
.................... 	DWORD_VAL new; 
....................  
.................... 	new.v[0] = v.v[3]; 
*
23BE:  MOVFF  285,286
.................... 	new.v[1] = v.v[2]; 
23C2:  MOVFF  284,287
.................... 	new.v[2] = v.v[1]; 
23C6:  MOVFF  283,288
.................... 	new.v[3] = v.v[0]; 
23CA:  MOVFF  282,289
....................  
.................... 	return (new.Val); 
23CE:  MOVFF  286,00
23D2:  MOVFF  287,01
23D6:  MOVFF  288,02
23DA:  MOVFF  289,03
.................... } 
23DE:  RETLW  00
....................  
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count) { 
.................... 	WORD i; 
.................... 	WORD *val; 
....................  
.................... 	union { 
.................... 		DWORD Val; 
.................... 		struct { 
.................... 			WORD_VAL LSB; 
.................... 			WORD_VAL MSB; 
.................... 		} words; 
.................... 	} tempSum, sum; 
....................  
.................... 	sum.Val = 0; 
*
209E:  MOVLB  2
20A0:  CLRF   x8B
20A2:  CLRF   x8A
20A4:  CLRF   x89
20A6:  CLRF   x88
....................  
.................... 	i = count >> 1; 
20A8:  BCF    FD8.0
20AA:  RRCF   x7F,W
20AC:  MOVWF  x81
20AE:  RRCF   x7E,W
20B0:  MOVWF  x80
.................... 	val = (WORD *) buffer; 
20B2:  MOVFF  27D,283
20B6:  MOVFF  27C,282
....................  
.................... 	while (i--) 
.................... 		sum.Val += *val++; 
20BA:  MOVFF  281,03
20BE:  MOVF   x80,W
20C0:  BTFSC  FD8.2
20C2:  DECF   x81,F
20C4:  DECF   x80,F
20C6:  IORWF  03,W
20C8:  BZ    20F8
20CA:  MOVFF  283,03
20CE:  MOVFF  282,00
20D2:  MOVLW  02
20D4:  ADDWF  x82,F
20D6:  BTFSC  FD8.0
20D8:  INCF   x83,F
20DA:  MOVFF  00,FE9
20DE:  MOVFF  03,FEA
20E2:  MOVFF  FEC,03
20E6:  MOVF   FED,F
20E8:  MOVF   FEF,W
20EA:  ADDWF  x88,F
20EC:  MOVF   03,W
20EE:  ADDWFC x89,F
20F0:  MOVLW  00
20F2:  ADDWFC x8A,F
20F4:  ADDWFC x8B,F
20F6:  BRA    20BA
....................  
.................... 	if (count & 1) 
20F8:  MOVF   x7E,W
20FA:  ANDLW  01
20FC:  MOVWF  00
20FE:  CLRF   03
2100:  MOVF   00,W
2102:  IORWF  03,W
2104:  BZ    211A
.................... 		sum.Val += *(BYTE *) val; 
2106:  MOVFF  282,FE9
210A:  MOVFF  283,FEA
210E:  MOVF   FEF,W
2110:  ADDWF  x88,F
2112:  MOVLW  00
2114:  ADDWFC x89,F
2116:  ADDWFC x8A,F
2118:  ADDWFC x8B,F
....................  
.................... 	tempSum.Val = sum.Val; 
211A:  MOVFF  28B,287
211E:  MOVFF  28A,286
2122:  MOVFF  289,285
2126:  MOVFF  288,284
.................... 	i = tempSum.words.MSB.Val; 
212A:  MOVFF  287,281
212E:  MOVFF  286,280
....................  
.................... 	while (i != 0u) { 
2132:  MOVF   x80,F
2134:  BNZ   213A
2136:  MOVF   x81,F
2138:  BZ    2180
.................... 		sum.words.MSB.Val = 0; 
213A:  CLRF   x8B
213C:  CLRF   x8A
.................... 		sum.Val = (DWORD) sum.words.LSB.Val + (DWORD) i; 
213E:  CLRF   x8F
2140:  CLRF   x8E
2142:  MOVFF  289,28D
2146:  MOVFF  288,28C
214A:  CLRF   02
214C:  CLRF   03
214E:  MOVF   x80,W
2150:  ADDWF  x88,W
2152:  MOVWF  x88
2154:  MOVF   x81,W
2156:  ADDWFC x89,W
2158:  MOVWF  x89
215A:  MOVF   02,W
215C:  ADDWFC x8E,W
215E:  MOVWF  x8A
2160:  MOVF   03,W
2162:  ADDWFC x8F,W
2164:  MOVWF  x8B
.................... 		tempSum.Val = sum.Val; 
2166:  MOVFF  28B,287
216A:  MOVFF  28A,286
216E:  MOVFF  289,285
2172:  MOVFF  288,284
.................... 		i = tempSum.words.MSB.Val; 
2176:  MOVFF  287,281
217A:  MOVFF  286,280
.................... 	} 
217E:  BRA    2132
....................  
.................... 	return (~sum.words.LSB.Val); 
2180:  MOVFF  289,03
2184:  COMF   03,F
2186:  MOVF   x88,W
2188:  XORLW  FF
218A:  MOVWF  01
218C:  MOVFF  03,02
.................... } 
2190:  MOVLB  0
2192:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  MAC buffer pointer set to starting of buffer 
....................  * 
....................  * Input:           len     - Total number of bytes to calculate 
....................  *                          checksum for. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs checksum calculation in 
....................  *                  MAC buffer itself. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if !defined(MCHP_MAC) 
.................... WORD CalcIPBufferChecksum(WORD len) { 
.................... 	BOOL lbMSB; 
.................... 	WORD_VAL checkSum; 
.................... 	BYTE Checkbyte; 
....................  
.................... 	lbMSB = TRUE; 
.................... 	checkSum.Val = 0; 
....................  
.................... 	while (len--) { 
.................... 		Checkbyte = MACGet(); 
....................  
.................... 		if (!lbMSB) { 
.................... 			if ((checkSum.v[0] = Checkbyte + checkSum.v[0]) < Checkbyte) { 
.................... 				if (++checkSum.v[1] == 0) 
.................... 					checkSum.v[0]++; 
.................... 			} 
.................... 		} 
.................... 		else { 
.................... 			if ((checkSum.v[1] = Checkbyte + checkSum.v[1]) < Checkbyte) { 
.................... 				if (++checkSum.v[0] == 0) 
.................... 					checkSum.v[1]++; 
.................... 			} 
.................... 		} 
....................  
.................... 		lbMSB = !lbMSB; 
.................... 	} 
....................  
.................... 	checkSum.v[1] = ~checkSum.v[1]; 
.................... 	checkSum.v[0] = ~checkSum.v[0]; 
.................... 	return checkSum.Val; 
.................... } 
.................... #endif 
....................  
.................... char itoc(BOOLEAN b) { 
.................... 	if (b) { 
.................... 		return '1'; 
.................... 	} 
.................... 	return '0'; 
.................... } 
....................  
.................... #include "tcpip/tick.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.c 
....................  * Dependencies:    stackTSK.h 
....................  *                  Tick.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    01/16/04 Intermediate counter vars added 
....................  * R. Shelquist (CCS)   09/23/04 TickGet() temporarily disables Timer0 interrupt 
....................  ********************************************************************/ 
....................  
.................... #define TICK_INCLUDE 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               12 // 10 original value (MiE) 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... TICKTYPE TickCount = 0;  //increment every 100ms 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void) 
.................... { 
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16); 
*
010E:  MOVLW  83
0110:  MOVWF  FD5
....................     set_timer0(TICK_COUNTER); 
0112:  MOVLW  9A
0114:  MOVWF  FD7
0116:  MOVLW  46
0118:  MOVWF  FD6
....................  
....................     enable_interrupts(INT_TIMER0); 
011A:  BSF    FF2.5
....................     enable_interrupts(GLOBAL); 
011C:  MOVLW  C0
011E:  IORWF  FF2,F
.................... } 
0120:  RETLW  00
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void) 
.................... { 
....................     int16 ret; 
....................     disable_interrupts(INT_TIMER0); 
*
0FE8:  BCF    FF2.5
....................     ret=TickCount; 
0FEA:  MOVFF  7C,241
0FEE:  MOVFF  7B,240
....................     enable_interrupts(INT_TIMER0); 
0FF2:  BSF    FF2.5
....................     return ret; 
0FF4:  MOVLB  2
0FF6:  MOVFF  240,01
0FFA:  MOVFF  241,02
.................... } 
0FFE:  MOVLB  0
1000:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int8 second_counter=0;  //increment this every 1s 
.................... int8 second_counter_intermediate=0; 
....................  
.................... #if STACK_USE_PPP 
....................  int8 ppp_second_counter=0; 
....................  int8 ppp_second_counter_intermediate=0; 
.................... #endif 
....................  
.................... #int_timer0 
.................... void Tick_Isr(void) 
.................... { 
....................         TickCount++;    //increment this every 100ms 
*
00BA:  INCF   x7B,F
00BC:  BTFSC  FD8.2
00BE:  INCF   x7C,F
....................  
....................         second_counter_intermediate++; 
00C0:  INCF   x7E,F
....................         if (second_counter_intermediate >= TICKS_PER_SECOND) { 
00C2:  MOVF   x7E,W
00C4:  SUBLW  0B
00C6:  BC    00CC
....................             second_counter++; //increment this ever 1s 
00C8:  INCF   x7D,F
....................             second_counter_intermediate=0; 
00CA:  CLRF   x7E
....................         } 
....................  
....................  
....................        #if STACK_USE_PPP 
....................         ppp_second_counter_intermediate++; 
....................         if (ppp_second_counter_intermediate >= TICKS_PER_SECOND) { 
....................             ppp_second_counter_intermediate=0; 
....................             ppp_second_counter++; 
....................         } 
....................        #endif 
....................  
....................  
....................     set_timer0(TICK_COUNTER); //set timer0 to properly interrupt every 100ms 
00CC:  MOVLW  9A
00CE:  MOVWF  FD7
00D0:  MOVLW  46
00D2:  MOVWF  FD6
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //#define debug_stack 
.................... //#define debug_stack  debug_printf 
.................... #define debug_stack(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................  
.................... #if STACK_USE_MAC 
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/enc28j60.c" 
.................... /********************************************************************* 
....................  * 
....................  *     MAC Module (Microchip ENC28J60) for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.c 
....................  * Dependencies:    ENC28J60.h 
....................  *                    MAC.h 
....................  *                    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                    Delay.h 
....................  * Processor:       PIC18 
....................  * Complier:        MCC18 v3.00 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder      6/28/04   Original 
....................  * Howard Schlunder      10/8/04   Cleanup 
....................  * Howard Schlunder      10/19/04 Small optimizations and more cleanup 
....................  * Howard Schlunder      11/29/04 Added Set/GetCLKOUT 
....................  * Howard Schlunder      12/23/05 Added B1 silicon errata workarounds 
....................  * Howard Schlunder      1/09/06   Added comments and minor mods 
....................  * Howard Schlunder      1/18/06 Added more silicon errata workarounds 
....................  * Howard Schlunder      2/20/06 Fixed TXSTART, RXSTOP 
....................  * Darren Rook          7/11/06  CCS Port 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
.................... ********************************************************************/ 
.................... #define THIS_IS_MAC_LAYER 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/Helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/MAC.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if STACK_USE_SLIP 
.................... #error Unexpected module is detected. 
.................... #error This file must be linked when SLIP module is not in use. 
.................... #endif 
....................  
.................... #define debug_mac 
.................... //#define debug_mac debug_printf 
....................  
....................  
....................    #ifndef PIN_ENC_MAC_SO 
....................     
....................       #define  PIN_ENC_MAC_SO    PIN_C7   // Connect from PIN MISO to ENC28J60. 
....................      
....................       #define  PIN_ENC_MAC_SI    PIN_C6   // Connect from PIN MOSI to ENC28J60. 
....................      
....................       #define  PIN_ENC_MAC_CLK   PIN_D4   // Connect from PIN SCK to ENC28J60. 
....................      
....................       #define  PIN_ENC_MAC_CS    PIN_D3   // Connect from PIN CS to ENC28J60. 
....................      
....................       #define  PIN_ENC_MAC_RST   PIN_D2   // Connect from PIN RST to ENC28J60. 
....................  
....................        
....................       //#define PIN_ENC_MAC_INT PIN_B0 
....................       //#define PIN_ENC_MAC_WOL PIN_B1 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  *0xF93=(*0xF93 | 0b11); *0xF94 = (*0xF94 & 0b11010111) | 0x10; *0xF95=*0xF95 & 0xFC 
....................      #endif 
....................  
....................  
.................... #define ENC_MAC_USE_SPI FALSE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................                                    // MiE: SPI Hard is not working on SPI2. Soft is working OK on SPI2 
.................... #define mac_enc_spi_tris_init()      
....................  
.................... #define SPISelectEthernet()     output_low(PIN_ENC_MAC_CS)  //changed by ccs 
.................... #define SPIUnselectEthernet()   output_high(PIN_ENC_MAC_CS) //changed by ccs 
....................  
.................... /** D E F I N I T I O N S ****************************************************/ 
.................... /* Hardware interface to NIC. */ 
.................... //#define MCP_RESET_TRIS   (TRISB_RB5)   //CCS wont use these 
.................... //#define MCP_RESET_IO   (LATB5)          //CCS wont use these 
.................... //#define MCP_CS_TRIS      (TRISB_RB3)   //CCS wont use these 
.................... //#define MCP_CS_IO      (LATB3)          //CCS wont use these 
.................... // The following SPI pins are used but are not configurable 
.................... //   RC3 is used for the SCK pin and is an output 
.................... //   RC4 is used for the SDI pin and is an input 
.................... //   RC5 is used for the SDO pin and is an output 
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt 
.................... //      flag (PIR1_SSPIF) be clear at all times.  If the SPI is shared with 
.................... //      other hardware, the other code should clear the PIR1_SSPIF when it is 
.................... //      done using the SPI. 
....................  
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is 
.................... // not compatible with most switches/routers.  If a dedicated network is used 
.................... // where the duplex of the remote node can be manually configured, you may 
.................... // change this configuration.  Otherwise, half duplex should always be used. 
.................... #define HALF_DUPLEX 
.................... //#define FULL_DUPLEX 
.................... //#define LEDB_DUPLEX 
....................  
.................... // Pseudo Functions 
.................... #define LOW(a)                (a & 0xFF) 
.................... #define HIGH(a)             ((a>>8) & 0xFF) 
....................  
.................... // NIC RAM definitions 
.................... #define RAMSIZE   8192ul 
.................... #define TXSTART (RAMSIZE-(MAC_TX_BUFFER_COUNT * (MAC_TX_BUFFER_SIZE + 8ul))) 
.................... #define RXSTART   (0ul)                  // Should be an even memory address 
.................... #define RXSTOP   ((TXSTART-2ul) | 0x0001ul)   // Odd for errata workaround 
.................... #define RXSIZE   (RXSTOP-RXSTART+1ul) 
....................  
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address) 
.................... #define  WCR (0b010<<5)         // Write Control Register command 
.................... #define  BFS (0b100<<5)         // Bit Field Set command 
.................... #define  BFC (0b101<<5)         // Bit Field Clear command 
.................... #define  RCR (0b000<<5)         // Read Control Register command 
.................... #define  RBM ((0b001<<5) | 0x1A)   // Read Buffer Memory command 
.................... #define  WBM ((0b011<<5) | 0x1A) // Write Buffer Memory command 
.................... #define  SR  ((0b111<<5) | 0x1F)   // System Reset command does not use an address. 
....................                         //   It requires 0x1F, however. 
....................  
.................... #define ETHER_IP   (0x00u) 
.................... #define ETHER_ARP   (0x06u) 
....................  
.................... #define MAXFRAMEC   (1500u+sizeof(ETHER_HEADER)+4u) 
....................  
.................... // A generic structure representing the Ethernet header starting all Ethernet 
.................... // frames 
00D4:  BCF    FF2.2
00D6:  GOTO   006C
.................... typedef struct _ETHER_HEADER 
.................... { 
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ETHER_HEADER; 
....................  
.................... // A header appended at the start of all RX frames by the hardware 
.................... typedef struct _ENC_PREAMBLE 
.................... { 
....................     int16         NextPacketPointer; 
....................     RXSTATUS      StatusVector; 
....................  
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ENC_PREAMBLE; 
....................  
.................... typedef struct _DATA_BUFFER 
.................... { 
....................    WORD_VAL StartAddress; 
....................    WORD_VAL EndAddress; 
....................    struct 
....................    { 
....................       unsigned char bFree : 1; 
....................       unsigned char bTransmitted : 1; 
....................    } Flags; 
.................... } DATA_BUFFER; 
....................  
.................... void MACSetDuplex(DUPLEX DuplexState); 
....................  
.................... // Prototypes of functions intended for MAC layer use only. 
.................... static void BankSel(WORD Register); 
.................... static REG ReadETHReg(BYTE Address); 
.................... static REG ReadMACReg(BYTE Address); 
.................... static void WriteReg(BYTE Address, BYTE Data); 
.................... static void BFCReg(BYTE Address, BYTE Data); 
.................... static void BFSReg(BYTE Address, BYTE Data); 
.................... static void SendSystemReset(void); 
.................... //static void GetRegs(void); 
.................... #ifdef MAC_POWER_ON_TEST 
.................... static BOOL TestMemory(void); 
.................... #endif 
....................  
.................... /* Internal and externally used MAC level variables */ 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... #endif 
....................  
.................... // Internal and externally used MAC level variables. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... BUFFER LastTXedBuffer; 
.................... #endif 
....................  
....................  
.................... // Internal MAC level variables and flags. 
.................... WORD_VAL NextPacketLocation; 
.................... WORD_VAL CurrentPacketLocation; 
.................... BOOL WasDiscarded; 
.................... BYTE ENCRevID; 
....................  
.................... //ENCSPIInit() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... void ENCSPIInit(void) 
.................... { 
....................    mac_enc_spi_tris_init();  //MCP_RESET_TRIS = 0; 
....................  #if ENC_MAC_USE_SPI 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4); 
....................  #else 
....................    output_low(PIN_ENC_MAC_CLK); 
*
0122:  BCF    F95.4
0124:  BCF    F8C.4
....................    output_float(PIN_ENC_MAC_SO); 
0126:  BSF    F94.7
....................  #endif 
....................    // 
....................    // Set up the SPI module on the PIC for communications with the ENC28J60 
....................    // 
....................    SPIUnselectEthernet(); 
0128:  BCF    F95.3
012A:  BSF    F8C.3
....................  
....................    // Deassert the nRESET pin on the ENC28J60.  The internal 
....................    // weak pull on the nRESET pin will get the job done anyway, 
....................    // so this isn't necessary, but it may provide extra noise immunity, 
....................    // should someone put their finger on the pin or otherwise cause a leakage 
....................    // path to ground on this pin. 
....................    output_high(PIN_ENC_MAC_RST);            //MCP_RESET_IO = 1; 
012C:  BCF    F95.2
012E:  BSF    F8C.2
.................... } 
0130:  RETLW  00
....................  
.................... //ENCSPIXfer() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... char ENCSPIXfer(char c) 
.................... { 
....................  #if ENC_MAC_USE_SPI 
....................    return(spi_read(c)); 
....................  #else 
....................    int8 i, in; 
....................    for (i=0;i<8;i++) { 
0132:  MOVLB  2
0134:  CLRF   xB9
0136:  MOVF   xB9,W
0138:  SUBLW  07
013A:  BNC   0164
....................       output_bit(PIN_ENC_MAC_SI, shift_left(&c, 1, 0)); 
013C:  BCF    FD8.0
013E:  RLCF   xB8,F
0140:  BC    0146
0142:  BCF    F8B.6
0144:  BRA    0148
0146:  BSF    F8B.6
0148:  BCF    F94.6
....................       output_high(PIN_ENC_MAC_CLK); 
014A:  BCF    F95.4
014C:  BSF    F8C.4
....................       shift_left(&in, 1, input(PIN_ENC_MAC_SO)); 
014E:  BSF    F94.7
0150:  BTFSC  F82.7
0152:  BRA    0158
0154:  BCF    FD8.0
0156:  BRA    015A
0158:  BSF    FD8.0
015A:  RLCF   xBA,F
....................       output_low(PIN_ENC_MAC_CLK); 
015C:  BCF    F95.4
015E:  BCF    F8C.4
....................    } 
0160:  INCF   xB9,F
0162:  BRA    0136
....................    return(in); 
0164:  MOVFF  2BA,01
....................  #endif 
.................... } 
0168:  MOVLB  0
016A:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACInit sets up the PIC's SPI module and all the 
....................  *               registers in the ENC28J60 so that normal operation can 
....................  *               begin. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACInit(void) 
.................... { 
....................    BYTE i; 
....................  
....................    ENCSPIInit(); 
*
03F2:  RCALL  0122
....................  
....................    // Wait for CLKRDY to become set. 
....................    // Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that 
....................    // means the part is in RESET or otherwise our SPI pin is being driven 
....................    // incorrectly.  Make sure it is working before proceeding. 
....................    do 
....................    { 
....................       i = ReadETHReg(ESTAT).Val; 
03F4:  MOVLW  1D
03F6:  MOVLB  2
03F8:  MOVWF  xA9
03FA:  MOVLB  0
03FC:  RCALL  016C
03FE:  MOVFF  01,2A8
....................    } while((i & 0x08) || (~i & ESTAT_CLKRDY)); 
0402:  MOVLB  2
0404:  BTFSS  xA8.3
0406:  BRA    040C
0408:  MOVLB  0
040A:  BRA    03F4
040C:  MOVF   xA8,W
040E:  XORLW  FF
0410:  ANDLW  01
0412:  BTFSC  FD8.2
0414:  BRA    041A
0416:  MOVLB  0
0418:  BRA    03F4
....................  
....................  
.................... #ifdef MAC_POWER_ON_TEST 
....................    // Do the memory test and enter a while always trap if a hardware error 
....................    // occured.  The LEDA and LEDB pins will be configured to blink 
....................    // periodically in an abnormal manner to indicate to the user that the 
....................    // error occured. 
....................    if( !TestMemory() ) 
....................    { 
....................       SetLEDConfig(0x0AA2);      // Set LEDs to blink periodically 
....................       while(1); 
....................    } 
.................... #endif 
....................  
....................    // RESET the entire ENC28J60, clearing all registers 
....................    SendSystemReset(); 
041A:  MOVLB  0
041C:  RCALL  0196
....................     delay_ms(1); 
041E:  MOVLW  01
0420:  MOVLB  2
0422:  MOVWF  xA9
0424:  MOVLB  0
0426:  RCALL  00E6
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................     // On Init, all transmit buffers are free. 
....................     for (i = 0; i < MAC_TX_BUFFER_COUNT; i++ ) 
....................     { 
....................         TxBuffers[i].StartAddress.Val = TXSTART + ((WORD)i * (MAC_TX_BUFFER_SIZE+8)); 
....................         TxBuffers[i].Flags.bFree = TRUE; 
....................     } 
.................... #endif 
....................     CurrentTxBuffer = 0; 
0428:  CLRF   x7A
....................  
....................    // Start up in Bank 0 and configure the receive buffer boundary pointers 
....................    // and the buffer write protect pointer (receive buffer read pointer) 
....................    WasDiscarded = TRUE; 
042A:  BSF    x83.0
....................    NextPacketLocation.Val = RXSTART; 
042C:  CLRF   x80
042E:  CLRF   x7F
....................    WriteReg(ERXSTL, LOW(RXSTART)); 
0430:  MOVLW  08
0432:  MOVLB  2
0434:  MOVWF  xB3
0436:  CLRF   xB4
0438:  MOVLB  0
043A:  RCALL  01AA
....................    WriteReg(ERXSTH, HIGH(RXSTART)); 
043C:  MOVLW  09
043E:  MOVLB  2
0440:  MOVWF  xB3
0442:  CLRF   xB4
0444:  MOVLB  0
0446:  RCALL  01AA
....................    WriteReg(ERXRDPTL, LOW(RXSTOP));   // Write low byte first 
0448:  MOVLW  0C
044A:  MOVLB  2
044C:  MOVWF  xB3
044E:  MOVLW  F7
0450:  MOVWF  xB4
0452:  MOVLB  0
0454:  RCALL  01AA
....................    WriteReg(ERXRDPTH, HIGH(RXSTOP));   // Write high byte last 
0456:  MOVLW  0D
0458:  MOVLB  2
045A:  MOVWF  xB3
045C:  MOVLW  1B
045E:  MOVWF  xB4
0460:  MOVLB  0
0462:  RCALL  01AA
.................... #if RXSTOP != 0x1FFF   // The RESET default ERXND is 0x1FFF 
....................    WriteReg(ERXNDL, LOW(RXSTOP)); 
0464:  MOVLW  0A
0466:  MOVLB  2
0468:  MOVWF  xB3
046A:  MOVLW  F7
046C:  MOVWF  xB4
046E:  MOVLB  0
0470:  RCALL  01AA
....................    WriteReg(ERXNDH, HIGH(RXSTOP)); 
0472:  MOVLW  0B
0474:  MOVLB  2
0476:  MOVWF  xB3
0478:  MOVLW  1B
047A:  MOVWF  xB4
047C:  MOVLB  0
047E:  RCALL  01AA
.................... #endif 
.................... #if TXSTART != 0      // The RESET default ETXST is 0 
....................    WriteReg(ETXSTL, LOW(TXSTART)); 
0480:  MOVLW  04
0482:  MOVLB  2
0484:  MOVWF  xB3
0486:  MOVLW  F8
0488:  MOVWF  xB4
048A:  MOVLB  0
048C:  RCALL  01AA
....................    WriteReg(ETXSTH, HIGH(TXSTART)); 
048E:  MOVLW  05
0490:  MOVLB  2
0492:  MOVWF  xB3
0494:  MOVLW  1B
0496:  MOVWF  xB4
0498:  MOVLB  0
049A:  RCALL  01AA
.................... #endif 
....................  
....................    // Enter Bank 1 and configure Receive Filters 
....................    // (No need to reconfigure - Unicast OR Broadcast with CRC checking is 
....................    // acceptable) 
....................    // Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode 
....................    //BankSel(ERXFCON); 
....................    //WriteReg((BYTE)ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN | ERXFCON_HTEN); 
....................  
....................    // Enter Bank 2 and configure the MAC 
....................    BankSel(MACON1); 
049C:  MOVLW  02
049E:  MOVLB  2
04A0:  MOVWF  xB1
04A2:  CLRF   xB0
04A4:  MOVLB  0
04A6:  RCALL  0204
....................  
....................    // Enable the receive portion of the MAC 
....................    WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN); 
04A8:  MOVLB  2
04AA:  CLRF   xB3
04AC:  MOVLW  0D
04AE:  MOVWF  xB4
04B0:  MOVLB  0
04B2:  RCALL  01AA
....................  
....................    // Pad packets to 60 bytes, add CRC, and check Type/Length field. 
....................    WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN); 
04B4:  MOVLW  02
04B6:  MOVLB  2
04B8:  MOVWF  xB3
04BA:  MOVLW  32
04BC:  MOVWF  xB4
04BE:  MOVLB  0
04C0:  RCALL  01AA
....................  
....................     // Allow infinite deferals if the medium is continuously busy 
....................     // (do not time out a transmission if the half duplex medium is 
....................     // completely saturated with other people's data) 
....................     WriteReg((BYTE)MACON4, MACON4_DEFER); 
04C2:  MOVLW  03
04C4:  MOVLB  2
04C6:  MOVWF  xB3
04C8:  MOVLW  40
04CA:  MOVWF  xB4
04CC:  MOVLB  0
04CE:  RCALL  01AA
....................  
....................    // Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter) 
....................    // 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
....................    // collisions will occur less often with a larger number. 
....................     WriteReg((BYTE)MACLCON2, 63); 
04D0:  MOVLW  09
04D2:  MOVLB  2
04D4:  MOVWF  xB3
04D6:  MOVLW  3F
04D8:  MOVWF  xB4
04DA:  MOVLB  0
04DC:  RCALL  01AA
....................  
....................    // Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
....................    // inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
....................    // later. 
....................    WriteReg((BYTE)MAIPGL, 0x12); 
04DE:  MOVLW  06
04E0:  MOVLB  2
04E2:  MOVWF  xB3
04E4:  MOVLW  12
04E6:  MOVWF  xB4
04E8:  MOVLB  0
04EA:  RCALL  01AA
....................    WriteReg((BYTE)MAIPGH, 0x0C); 
04EC:  MOVLW  07
04EE:  MOVLB  2
04F0:  MOVWF  xB3
04F2:  MOVLW  0C
04F4:  MOVWF  xB4
04F6:  MOVLB  0
04F8:  RCALL  01AA
....................  
....................    // Set the maximum packet size which the controller will accept 
....................    WriteReg((BYTE)MAMXFLL, LOW(MAXFRAMEC)); 
04FA:  MOVLW  0A
04FC:  MOVLB  2
04FE:  MOVWF  xB3
0500:  MOVLW  EE
0502:  MOVWF  xB4
0504:  MOVLB  0
0506:  RCALL  01AA
....................    WriteReg((BYTE)MAMXFLH, HIGH(MAXFRAMEC)); 
0508:  MOVLW  0B
050A:  MOVLB  2
050C:  MOVWF  xB3
050E:  MOVLW  05
0510:  MOVWF  xB4
0512:  MOVLB  0
0514:  RCALL  01AA
....................  
....................     // Enter Bank 3 and initialize physical MAC address registers 
....................    BankSel(MAADR1); 
0516:  MOVLW  03
0518:  MOVLB  2
051A:  MOVWF  xB1
051C:  MOVLW  04
051E:  MOVWF  xB0
0520:  MOVLB  0
0522:  RCALL  0204
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]); 
0524:  MOVLW  04
0526:  MOVLB  2
0528:  MOVWF  xB3
052A:  MOVFF  47,2B4
052E:  MOVLB  0
0530:  RCALL  01AA
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]); 
0532:  MOVLW  05
0534:  MOVLB  2
0536:  MOVWF  xB3
0538:  MOVFF  48,2B4
053C:  MOVLB  0
053E:  RCALL  01AA
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]); 
0540:  MOVLW  02
0542:  MOVLB  2
0544:  MOVWF  xB3
0546:  MOVFF  49,2B4
054A:  MOVLB  0
054C:  RCALL  01AA
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]); 
054E:  MOVLW  03
0550:  MOVLB  2
0552:  MOVWF  xB3
0554:  MOVFF  4A,2B4
0558:  MOVLB  0
055A:  RCALL  01AA
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]); 
055C:  MOVLB  2
055E:  CLRF   xB3
0560:  MOVFF  4B,2B4
0564:  MOVLB  0
0566:  RCALL  01AA
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]); 
0568:  MOVLW  01
056A:  MOVLB  2
056C:  MOVWF  xB3
056E:  MOVFF  4C,2B4
0572:  MOVLB  0
0574:  RCALL  01AA
....................  
....................    // Get the Rev ID so that we can implement the correct errata workarounds 
....................    ENCRevID = ReadETHReg((BYTE)EREVID).Val; 
0576:  MOVLW  12
0578:  MOVLB  2
057A:  MOVWF  xA9
057C:  MOVLB  0
057E:  RCALL  016C
0580:  MOVFF  01,84
....................  
....................    // Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a 
....................    // side effect. 
....................    WritePHYReg(PHCON2, PHCON2_HDLDIS); 
0584:  MOVLW  10
0586:  MOVLB  2
0588:  MOVWF  xAD
058A:  MOVLW  01
058C:  MOVWF  xAF
058E:  CLRF   xAE
0590:  MOVLB  0
0592:  RCALL  0260
....................  
....................    // Configure LEDA to display LINK status, LEDB to display TX/RX activity 
....................    SetLEDConfig(0x0472); 
0594:  MOVLW  14
0596:  MOVLB  2
0598:  MOVWF  xAD
059A:  MOVLW  04
059C:  MOVWF  xAF
059E:  MOVLW  72
05A0:  MOVWF  xAE
05A2:  MOVLB  0
05A4:  RCALL  0260
....................  
....................    // Set the MAC and PHY into the proper duplex state 
.................... #if defined(FULL_DUPLEX) 
....................    MACSetDuplex(FULL);      // Function exits with Bank 2 selected 
.................... #elif defined(HALF_DUPLEX) 
....................    MACSetDuplex(HALF);      // Function exits with Bank 2 selected 
05A6:  MOVLB  2
05A8:  CLRF   xA9
05AA:  MOVLB  0
05AC:  RCALL  0358
.................... #else 
....................    // Use the external LEDB polarity to determine weather full or half duplex 
....................    // communication mode should be set. 
....................    MACSetDuplex(USE_PHY);   // Function exits with Bank 2 selected 
.................... #endif 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
05AE:  MOVLW  1F
05B0:  MOVLB  2
05B2:  MOVWF  xB5
05B4:  MOVLW  04
05B6:  MOVWF  xB6
05B8:  MOVLB  0
05BA:  RCALL  01E6
.................... }//end MACInit 
05BC:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsLinked(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If the PHY reports that a link partner is present 
....................  *                    and the link has been up continuously since the last 
....................  *                    call to MACIsLinked() 
....................  *               FALSE: If the PHY reports no link partner, or the link went 
....................  *                     down momentarily since the last call to MACIsLinked() 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsLinked(void) 
.................... { 
....................    // LLSTAT is a latching low link status bit.  Therefore, if the link 
....................    // goes down and comes back up before a higher level stack program calls 
....................    // MACIsLinked(), MACIsLinked() will still return FALSE.  The next 
....................    // call to MACIsLinked() will return TRUE (unless the link goes down 
....................    // again). 
....................    return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT; 
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           HighPriority: TRUE: Check the hardware ECON1.TXRTS bit 
....................  *                          FALSE: Check if a TX buffer is free 
....................  * 
....................  * Output:          TRUE: If no Ethernet transmission is in progress 
....................  *               FALSE: If a previous transmission was started, and it has 
....................  *                     not completed yet.  While FALSE, the data in the 
....................  *                     transmit buffer and the TXST/TXND pointers must not 
....................  *                     be changed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the ECON1.TXRTS bit 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsTxReady(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
*
2906:  CLRF   19
2908:  BTFSC  FF2.7
290A:  BSF    19.7
290C:  BCF    FF2.7
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
290E:  MOVLW  1F
2910:  MOVLB  2
2912:  MOVWF  xA9
2914:  MOVLB  0
2916:  CALL   016C
291A:  BTFSC  19.7
291C:  BSF    FF2.7
291E:  MOVLW  00
2920:  BTFSS  01.3
2922:  MOVLW  01
2924:  MOVWF  01
2926:  BRA    2928
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................  
....................    // Check if the current buffer can be modified.  It cannot be modified if 
....................    // the TX hardware is currently transmitting it. 
....................    if(CurrentTxBuffer == LastTXedBuffer) 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
....................    } 
....................  
....................    // Check if a buffer is available for a new packet 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          return TRUE; 
....................       } 
....................    } 
....................  
....................    return FALSE; 
.................... #endif 
.................... } 
2928:  RETLW  00
....................  
.................... BUFFER MACGetTxBuffer(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
*
14D4:  CLRF   19
14D6:  BTFSC  FF2.7
14D8:  BSF    19.7
14DA:  BCF    FF2.7
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................       return !ReadETHReg(ECON1).ECON1bits.TXRTS ? 0 : INVALID_BUFFER; 
14DC:  MOVLW  1F
14DE:  MOVLB  2
14E0:  MOVWF  xA9
14E2:  MOVLB  0
14E4:  CALL   016C
14E8:  BTFSC  19.7
14EA:  BSF    FF2.7
14EC:  BTFSC  01.3
14EE:  BRA    14F4
14F0:  MOVLW  00
14F2:  BRA    14F6
14F4:  MOVLW  FF
14F6:  MOVWF  01
14F8:  BRA    14FA
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Find a free buffer.  Do not use buffer 0, it is reserved for 
....................    // high priority messages that don't need to be acknowledged 
....................    // before being discarded (TCP control packets, all ICMP 
....................    // packets, all UDP packets, etc.) 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       // If this buffer is free, then mark it as used and return with it 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          TxBuffers[i].Flags.bFree = FALSE; 
....................          TxBuffers[i].Flags.bTransmitted = FALSE; 
....................          return i; 
....................       } 
....................    } 
....................  
....................    return INVALID_BUFFER; 
.................... #endif 
.................... } 
14FA:  RETLW  00
....................  
....................  
.................... void MACDiscardTx(BUFFER buffer) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    if(buffer < sizeof(TxBuffers)/sizeof(TxBuffers[0])) 
....................    { 
....................        TxBuffers[buffer].Flags.bFree = TRUE; 
....................        CurrentTxBuffer = buffer; 
....................    } 
.................... #endif 
.................... } 
*
0004:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDiscardRx(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Marks the last received packet (obtained using 
....................  *               MACGetHeader())as being processed and frees the buffer 
....................  *               memory associated with it 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDiscardRx(void) 
.................... { 
....................    WORD_VAL NewRXRDLocation; 
....................  
....................    // Make sure the current packet was not already discarded 
....................    if( WasDiscarded ) 
*
1070:  BTFSS  x83.0
1072:  BRA    1076
....................       return; 
1074:  BRA    110E
....................    WasDiscarded = TRUE; 
1076:  BSF    x83.0
....................  
....................    // Decrement the next packet pointer before writing it into 
....................    // the ERXRDPT registers.  This is a silicon errata workaround. 
....................    // RX buffer wrapping must be taken into account if the 
....................    // NextPacketLocation is precisely RXSTART. 
....................    NewRXRDLocation.Val = NextPacketLocation.Val - 1; 
1078:  MOVLW  01
107A:  SUBWF  x7F,W
107C:  MOVLB  2
107E:  MOVWF  x40
1080:  MOVLW  00
1082:  MOVLB  0
1084:  SUBWFB x80,W
1086:  MOVLB  2
1088:  MOVWF  x41
.................... #if RXSTART == 0 
....................    if(NewRXRDLocation.Val > RXSTOP) 
108A:  MOVF   x41,W
108C:  SUBLW  1A
108E:  BC    10A2
1090:  XORLW  FF
1092:  BNZ   109A
1094:  MOVF   x40,W
1096:  SUBLW  F7
1098:  BC    10A2
.................... #else 
....................    if(NewRXRDLocation.Val < RXSTART || NewRXRDLocation.Val > RXSTOP) 
.................... #endif 
....................    { 
....................       NewRXRDLocation.Val = RXSTOP; 
109A:  MOVLW  1B
109C:  MOVWF  x41
109E:  MOVLW  F7
10A0:  MOVWF  x40
10A2:  CLRF   19
10A4:  BTFSC  FF2.7
10A6:  BSF    19.7
10A8:  BCF    FF2.7
....................    } 
....................  
....................    // Decrement the RX packet counter register, EPKTCNT 
....................    BFSReg(ECON2, ECON2_PKTDEC); 
10AA:  MOVLW  1E
10AC:  MOVWF  xB5
10AE:  MOVLW  40
10B0:  MOVWF  xB6
10B2:  MOVLB  0
10B4:  CALL   01E6
10B8:  BTFSC  19.7
10BA:  BSF    FF2.7
10BC:  CLRF   19
10BE:  BTFSC  FF2.7
10C0:  BSF    19.7
10C2:  BCF    FF2.7
....................  
....................    // Move the receive read pointer to unwrite-protect the memory used by the 
....................    // last packet.  The writing order is important: set the low byte first, 
....................    // high byte last. 
....................    BankSel(ERXRDPTL); 
10C4:  MOVLB  2
10C6:  CLRF   xB1
10C8:  MOVLW  0C
10CA:  MOVWF  xB0
10CC:  MOVLB  0
10CE:  CALL   0204
10D2:  BTFSC  19.7
10D4:  BSF    FF2.7
10D6:  CLRF   19
10D8:  BTFSC  FF2.7
10DA:  BSF    19.7
10DC:  BCF    FF2.7
....................    WriteReg(ERXRDPTL, NewRXRDLocation.v[0]); 
10DE:  MOVLW  0C
10E0:  MOVLB  2
10E2:  MOVWF  xB3
10E4:  MOVFF  240,2B4
10E8:  MOVLB  0
10EA:  CALL   01AA
10EE:  BTFSC  19.7
10F0:  BSF    FF2.7
10F2:  CLRF   19
10F4:  BTFSC  FF2.7
10F6:  BSF    19.7
10F8:  BCF    FF2.7
....................    WriteReg(ERXRDPTH, NewRXRDLocation.v[1]); 
10FA:  MOVLW  0D
10FC:  MOVLB  2
10FE:  MOVWF  xB3
1100:  MOVFF  241,2B4
1104:  MOVLB  0
1106:  CALL   01AA
110A:  BTFSC  19.7
110C:  BSF    FF2.7
.................... } 
110E:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetFreeRxSize(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A WORD estimate of how much RX buffer space is free at 
....................  *               the present time. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetFreeRxSize(void) 
.................... { 
*
292A:  CLRF   19
292C:  BTFSC  FF2.7
292E:  BSF    19.7
2930:  BCF    FF2.7
....................    WORD_VAL ReadPT, WritePT; 
....................  
....................    // Read the Ethernet hardware buffer write pointer.  Because packets can be 
....................    // received at any time, it can change between reading the low and high 
....................    // bytes.  A loop is necessary to make certain a proper low/high byte pair 
....................    // is read. 
....................    BankSel(EPKTCNT); 
2932:  MOVLW  01
2934:  MOVLB  2
2936:  MOVWF  xB1
2938:  MOVLW  19
293A:  MOVWF  xB0
293C:  MOVLB  0
293E:  CALL   0204
2942:  BTFSC  19.7
2944:  BSF    FF2.7
2946:  CLRF   19
2948:  BTFSC  FF2.7
294A:  BSF    19.7
294C:  BCF    FF2.7
....................    do { 
....................       // Save EPKTCNT in a temporary location 
....................       ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val; 
294E:  MOVLW  19
2950:  MOVLB  2
2952:  MOVWF  xA9
2954:  MOVLB  0
2956:  CALL   016C
295A:  BTFSC  19.7
295C:  BSF    FF2.7
295E:  MOVFF  01,27A
2962:  CLRF   19
2964:  BTFSC  FF2.7
2966:  BSF    19.7
2968:  BCF    FF2.7
....................  
....................       BankSel(ERXWRPTL); 
296A:  MOVLB  2
296C:  CLRF   xB1
296E:  MOVLW  0E
2970:  MOVWF  xB0
2972:  MOVLB  0
2974:  CALL   0204
2978:  BTFSC  19.7
297A:  BSF    FF2.7
297C:  CLRF   19
297E:  BTFSC  FF2.7
2980:  BSF    19.7
2982:  BCF    FF2.7
....................       WritePT.v[0] = ReadETHReg(ERXWRPTL).Val; 
2984:  MOVLW  0E
2986:  MOVLB  2
2988:  MOVWF  xA9
298A:  MOVLB  0
298C:  CALL   016C
2990:  BTFSC  19.7
2992:  BSF    FF2.7
2994:  MOVFF  01,27C
2998:  CLRF   19
299A:  BTFSC  FF2.7
299C:  BSF    19.7
299E:  BCF    FF2.7
....................       WritePT.v[1] = ReadETHReg(ERXWRPTH).Val; 
29A0:  MOVLW  0F
29A2:  MOVLB  2
29A4:  MOVWF  xA9
29A6:  MOVLB  0
29A8:  CALL   016C
29AC:  BTFSC  19.7
29AE:  BSF    FF2.7
29B0:  MOVFF  01,27D
29B4:  CLRF   19
29B6:  BTFSC  FF2.7
29B8:  BSF    19.7
29BA:  BCF    FF2.7
....................  
....................       BankSel(EPKTCNT); 
29BC:  MOVLW  01
29BE:  MOVLB  2
29C0:  MOVWF  xB1
29C2:  MOVLW  19
29C4:  MOVWF  xB0
29C6:  MOVLB  0
29C8:  CALL   0204
29CC:  BTFSC  19.7
29CE:  BSF    FF2.7
29D0:  CLRF   19
29D2:  BTFSC  FF2.7
29D4:  BSF    19.7
29D6:  BCF    FF2.7
....................    } while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]); 
29D8:  MOVLW  19
29DA:  MOVLB  2
29DC:  MOVWF  xA9
29DE:  MOVLB  0
29E0:  CALL   016C
29E4:  BTFSC  19.7
29E6:  BSF    FF2.7
29E8:  MOVLB  2
29EA:  MOVF   x7A,W
29EC:  SUBWF  01,W
29EE:  BTFSC  FD8.2
29F0:  BRA    29F6
29F2:  MOVLB  0
29F4:  BRA    2946
29F6:  CLRF   19
29F8:  BTFSC  FF2.7
29FA:  BSF    19.7
29FC:  BCF    FF2.7
....................  
....................    // Determine where the write protection pointer is 
....................    BankSel(ERXRDPTL); 
29FE:  CLRF   xB1
2A00:  MOVLW  0C
2A02:  MOVWF  xB0
2A04:  MOVLB  0
2A06:  CALL   0204
2A0A:  BTFSC  19.7
2A0C:  BSF    FF2.7
2A0E:  CLRF   19
2A10:  BTFSC  FF2.7
2A12:  BSF    19.7
2A14:  BCF    FF2.7
....................    ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val; 
2A16:  MOVLW  0C
2A18:  MOVLB  2
2A1A:  MOVWF  xA9
2A1C:  MOVLB  0
2A1E:  CALL   016C
2A22:  BTFSC  19.7
2A24:  BSF    FF2.7
2A26:  MOVFF  01,27A
2A2A:  CLRF   19
2A2C:  BTFSC  FF2.7
2A2E:  BSF    19.7
2A30:  BCF    FF2.7
....................    ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val; 
2A32:  MOVLW  0D
2A34:  MOVLB  2
2A36:  MOVWF  xA9
2A38:  MOVLB  0
2A3A:  CALL   016C
2A3E:  BTFSC  19.7
2A40:  BSF    FF2.7
2A42:  MOVFF  01,27B
....................  
....................    // Calculate the difference between the pointers, taking care to account 
....................    // for buffer wrapping conditions 
....................    if ( WritePT.Val > ReadPT.Val ) 
2A46:  MOVLB  2
2A48:  MOVF   x7B,W
2A4A:  SUBWF  x7D,W
2A4C:  BNC   2A7A
2A4E:  BNZ   2A56
2A50:  MOVF   x7C,W
2A52:  SUBWF  x7A,W
2A54:  BC    2A7A
....................    { 
....................       return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val); 
2A56:  MOVF   x7A,W
2A58:  SUBWF  x7C,W
2A5A:  MOVWF  00
2A5C:  MOVF   x7B,W
2A5E:  SUBWFB x7D,W
2A60:  MOVWF  03
2A62:  MOVF   00,W
2A64:  XORLW  FF
2A66:  ADDLW  F8
2A68:  MOVWF  00
2A6A:  MOVLW  1B
2A6C:  SUBFWB 03,F
2A6E:  MOVFF  00,01
2A72:  MOVFF  03,02
2A76:  BRA    2AB2
....................    } 
....................    else if ( WritePT.Val == ReadPT.Val ) 
2A78:  BRA    2AB2
2A7A:  MOVF   x7A,W
2A7C:  SUBWF  x7C,W
2A7E:  BNZ   2A92
2A80:  MOVF   x7B,W
2A82:  SUBWF  x7D,W
2A84:  BNZ   2A92
....................    { 
....................       return RXSIZE - 1; 
2A86:  MOVLW  F7
2A88:  MOVWF  01
2A8A:  MOVLW  1B
2A8C:  MOVWF  02
2A8E:  BRA    2AB2
....................    } 
....................    else 
2A90:  BRA    2AB2
....................     { 
....................       return ReadPT.Val - WritePT.Val - 1; 
2A92:  MOVF   x7C,W
2A94:  SUBWF  x7A,W
2A96:  MOVWF  x7E
2A98:  MOVF   x7D,W
2A9A:  SUBWFB x7B,W
2A9C:  MOVWF  x7F
2A9E:  MOVLW  01
2AA0:  SUBWF  x7E,W
2AA2:  MOVWF  00
2AA4:  MOVLW  00
2AA6:  SUBWFB x7F,W
2AA8:  MOVWF  03
2AAA:  MOVFF  00,01
2AAE:  MOVWF  02
2AB0:  BRA    2AB2
....................    } 
.................... } 
2AB2:  MOVLB  0
2AB4:  GOTO   2D9C (RETURN)
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           *remote: Location to store the Source MAC address of the 
....................  *                      received frame. 
....................  *               *type: Location of a BYTE to store the constant 
....................  *                     MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing 
....................  *                     the contents of the Ethernet type field. 
....................  * 
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The 
....................  *                    remote, and type values are updated. 
....................  *               FALSE: If a packet was not pending.  remote and type are 
....................  *                     not changed. 
....................  * 
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already 
....................  *               been called. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
.................... { 
*
11A2:  CLRF   19
11A4:  BTFSC  FF2.7
11A6:  BSF    19.7
11A8:  BCF    FF2.7
....................    ENC_PREAMBLE header; 
....................  
....................    // Test if at least one packet has been received and is waiting 
....................    BankSel(EPKTCNT); 
11AA:  MOVLW  01
11AC:  MOVLB  2
11AE:  MOVWF  xB1
11B0:  MOVLW  19
11B2:  MOVWF  xB0
11B4:  MOVLB  0
11B6:  CALL   0204
11BA:  BTFSC  19.7
11BC:  BSF    FF2.7
11BE:  CLRF   19
11C0:  BTFSC  FF2.7
11C2:  BSF    19.7
11C4:  BCF    FF2.7
....................    if(ReadETHReg((BYTE)EPKTCNT).Val == 0) 
11C6:  MOVLW  19
11C8:  MOVLB  2
11CA:  MOVWF  xA9
11CC:  MOVLB  0
11CE:  CALL   016C
11D2:  BTFSC  19.7
11D4:  BSF    FF2.7
11D6:  MOVF   01,F
11D8:  BNZ   11E0
....................       return FALSE; 
11DA:  MOVLW  00
11DC:  MOVWF  01
11DE:  BRA    1314
....................  
....................    // Make absolutely certain that any previous packet was discarded 
....................    if(WasDiscarded == FALSE) 
11E0:  BTFSC  x83.0
11E2:  BRA    11EC
....................    { 
....................       MACDiscardRx(); 
11E4:  RCALL  1070
....................       return FALSE; 
11E6:  MOVLW  00
11E8:  MOVWF  01
11EA:  BRA    1314
....................    } 
....................  
....................    // Save the location of this packet 
....................    CurrentPacketLocation.Val = NextPacketLocation.Val; 
11EC:  MOVFF  80,82
11F0:  MOVFF  7F,81
11F4:  CLRF   19
11F6:  BTFSC  FF2.7
11F8:  BSF    19.7
11FA:  BCF    FF2.7
....................  
....................    // Set the SPI read pointer to the beginning of the next unprocessed packet 
....................    BankSel(ERDPTL); 
11FC:  MOVLB  2
11FE:  CLRF   xB1
1200:  CLRF   xB0
1202:  MOVLB  0
1204:  CALL   0204
1208:  BTFSC  19.7
120A:  BSF    FF2.7
120C:  CLRF   19
120E:  BTFSC  FF2.7
1210:  BSF    19.7
1212:  BCF    FF2.7
....................    WriteReg(ERDPTL, NextPacketLocation.v[0]); 
1214:  MOVLB  2
1216:  CLRF   xB3
1218:  MOVFF  7F,2B4
121C:  MOVLB  0
121E:  CALL   01AA
1222:  BTFSC  19.7
1224:  BSF    FF2.7
1226:  CLRF   19
1228:  BTFSC  FF2.7
122A:  BSF    19.7
122C:  BCF    FF2.7
....................    WriteReg(ERDPTH, NextPacketLocation.v[1]); 
122E:  MOVLW  01
1230:  MOVLB  2
1232:  MOVWF  xB3
1234:  MOVFF  80,2B4
1238:  MOVLB  0
123A:  CALL   01AA
123E:  BTFSC  19.7
1240:  BSF    FF2.7
....................  
....................    // Obtain the MAC header from the Ethernet buffer 
....................    MACGetArray((BYTE*)&header, sizeof(header)); 
1242:  MOVLW  01
1244:  MOVLB  2
1246:  MOVWF  x0D
1248:  MOVLW  F8
124A:  MOVFF  20D,289
124E:  MOVWF  x88
1250:  CLRF   x8B
1252:  MOVLW  14
1254:  MOVWF  x8A
1256:  MOVLB  0
1258:  RCALL  1110
....................  
....................    // The EtherType field, like most items transmitted on the Ethernet medium 
....................    // are in big endian. 
....................     header.Type.Val = swaps(header.Type.Val); 
125A:  MOVFF  20B,29A
125E:  MOVFF  20A,299
1262:  RCALL  118C
1264:  MOVFF  02,20B
1268:  MOVFF  01,20A
....................  
....................    // Validate the data returned from the ENC28J60.  Random data corruption, 
....................    // such as if a single SPI bit error occurs while communicating or a 
....................    // momentary power glitch could cause this to occur in rare circumstances. 
....................    if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 || 
....................       header.StatusVector.bits.Zero || 
....................       header.StatusVector.bits.CRCError || 
....................       header.StatusVector.bits.ByteCount > 1518 || 
....................       !header.StatusVector.bits.ReceiveOk) 
126C:  MOVLB  1
126E:  MOVF   xF9,W
1270:  SUBLW  1A
1272:  BC    127E
1274:  XORLW  FF
1276:  BNZ   12A6
1278:  MOVF   xF8,W
127A:  SUBLW  F7
127C:  BNC   12A6
127E:  MOVLW  01
1280:  MOVWF  FEA
1282:  MOVLW  F8
1284:  MOVWF  FE9
1286:  BTFSC  FEF.0
1288:  BRA    12A6
128A:  BTFSC  xFD.7
128C:  BRA    12A6
128E:  BTFSC  xFC.4
1290:  BRA    12A6
1292:  MOVF   xFB,W
1294:  SUBLW  04
1296:  BC    12A2
1298:  XORLW  FF
129A:  BNZ   12A6
129C:  MOVF   xFA,W
129E:  SUBLW  EE
12A0:  BNC   12A6
12A2:  BTFSC  xFC.7
12A4:  BRA    12A8
....................    { 
....................       //Reset(); 
....................       reset_cpu(); 
12A6:  RESET
....................    } 
....................  
....................    // Save the location where the hardware will write the next packet to 
....................    NextPacketLocation.Val = header.NextPacketPointer; 
12A8:  MOVFF  1F9,80
12AC:  MOVFF  1F8,7F
....................  
....................    // Return the Ethernet frame's Source MAC address field to the caller 
....................    // This parameter is useful for replying to requests without requiring an 
....................    // ARP cycle. 
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote)); 
12B0:  MOVFF  1F5,03
12B4:  MOVFF  1F4,20C
12B8:  MOVLB  2
12BA:  MOVFF  1F5,20D
12BE:  MOVFF  1F5,FEA
12C2:  MOVFF  1F4,FE9
12C6:  MOVLW  02
12C8:  MOVWF  FE2
12CA:  MOVLW  04
12CC:  MOVWF  FE1
12CE:  MOVLW  06
12D0:  MOVWF  01
12D2:  MOVFF  FE6,FEE
12D6:  DECFSZ 01,F
12D8:  BRA    12D2
....................  
....................    // Return a simplified version of the EtherType field to the caller 
....................     *type = MAC_UNKNOWN; 
12DA:  MOVFF  1F7,03
12DE:  MOVLB  1
12E0:  MOVFF  1F6,FE9
12E4:  MOVFF  03,FEA
12E8:  MOVLW  FF
12EA:  MOVWF  FEF
....................     if( (header.Type.v[1] == 0x08u) && 
....................        ((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) ) 
12EC:  MOVLB  2
12EE:  MOVF   x0B,W
12F0:  SUBLW  08
12F2:  BNZ   130C
12F4:  MOVF   x0A,F
12F6:  BZ    12FE
12F8:  MOVF   x0A,W
12FA:  SUBLW  06
12FC:  BNZ   130C
....................     { 
....................        *type = header.Type.v[0]; 
12FE:  MOVLB  1
1300:  MOVFF  1F6,FE9
1304:  MOVFF  1F7,FEA
1308:  MOVFF  20A,FEF
....................     } 
....................  
....................     // Mark this packet as discardable 
....................     WasDiscarded = FALSE; 
130C:  MOVLB  0
130E:  BCF    x83.0
....................    return TRUE; 
1310:  MOVLW  01
1312:  MOVWF  01
.................... } 
1314:  GOTO   43EC (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void    MACPutHeader(MAC_ADDR *remote, 
....................  *                                    BYTE type, 
....................  *                                   WORD dataLen) 
....................  * 
....................  * PreCondition:    MACIsTxReady() must return TRUE. 
....................  * 
....................  * Input:           *remote: Pointer to memory which contains the destination 
....................  *                       MAC address (6 bytes) 
....................  *               type: The constant ETHER_ARP or ETHER_IP, defining which 
....................  *                    value to write into the Ethernet header's type field. 
....................  *               dataLen: Length of the Ethernet data payload 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Because of the dataLen parameter, it is probably 
....................  *               advantagous to call this function immediately before 
....................  *               transmitting a packet rather than initially when the 
....................  *               packet is first created.  The order in which the packet 
....................  *               is constructed (header first or data first) is not 
....................  *               important. 
....................  *****************************************************************************/ 
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen) 
.................... { 
*
165E:  CLRF   19
1660:  BTFSC  FF2.7
1662:  BSF    19.7
1664:  BCF    FF2.7
....................  
....................    BankSel(EWRPTL); 
1666:  MOVLB  2
1668:  CLRF   xB1
166A:  MOVLW  02
166C:  MOVWF  xB0
166E:  MOVLB  0
1670:  CALL   0204
1674:  BTFSC  19.7
1676:  BSF    FF2.7
1678:  CLRF   19
167A:  BTFSC  FF2.7
167C:  BSF    19.7
167E:  BCF    FF2.7
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(EWRPTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TxBuffers[CurrentTxBuffer].StartAddress.Val; 
....................    TxBuffers[CurrentTxBuffer].EndAddress.Val = dataLen; 
.................... #else 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
1680:  MOVLW  02
1682:  MOVLB  2
1684:  MOVWF  xB3
1686:  MOVLW  F8
1688:  MOVWF  xB4
168A:  MOVLB  0
168C:  CALL   01AA
1690:  BTFSC  19.7
1692:  BSF    FF2.7
1694:  CLRF   19
1696:  BTFSC  FF2.7
1698:  BSF    19.7
169A:  BCF    FF2.7
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
169C:  MOVLW  03
169E:  MOVLB  2
16A0:  MOVWF  xB3
16A2:  MOVLW  1B
16A4:  MOVWF  xB4
16A6:  MOVLB  0
16A8:  CALL   01AA
16AC:  BTFSC  19.7
16AE:  BSF    FF2.7
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART; 
16B0:  MOVLW  06
16B2:  MOVLB  2
16B4:  ADDWF  x9A,F
16B6:  MOVLW  1C
16B8:  ADDWFC x9B,F
....................  
....................    // Write the TXND pointer into the registers, given the dataLen given 
....................    WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]); 
16BA:  MOVLW  02
16BC:  MOVWF  FEA
16BE:  MOVLW  9A
16C0:  MOVWF  FE9
16C2:  MOVFF  FEF,29E
16C6:  CLRF   19
16C8:  BTFSC  FF2.7
16CA:  BSF    19.7
16CC:  BCF    FF2.7
16CE:  MOVLW  06
16D0:  MOVWF  xB3
16D2:  MOVFF  29E,2B4
16D6:  MOVLB  0
16D8:  CALL   01AA
16DC:  BTFSC  19.7
16DE:  BSF    FF2.7
....................    WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]); 
16E0:  MOVLW  02
16E2:  MOVWF  FEA
16E4:  MOVLW  9B
16E6:  MOVWF  FE9
16E8:  MOVFF  FEF,29E
16EC:  CLRF   19
16EE:  BTFSC  FF2.7
16F0:  BSF    19.7
16F2:  BCF    FF2.7
16F4:  MOVLW  07
16F6:  MOVLB  2
16F8:  MOVWF  xB3
16FA:  MOVFF  29E,2B4
16FE:  MOVLB  0
1700:  CALL   01AA
1704:  BTFSC  19.7
1706:  BSF    FF2.7
.................... #endif 
....................  
....................  
....................    // Set the per-packet control byte and write the Ethernet destination 
....................    // address 
....................    MACPut(0x00);   // Use default control configuration 
1708:  MOVLB  2
170A:  CLRF   x9D
170C:  MOVLB  0
170E:  RCALL  15C2
....................     MACPutArray((BYTE*)remote, sizeof(*remote)); 
1710:  MOVFF  298,29F
1714:  MOVFF  297,29E
1718:  MOVLB  2
171A:  CLRF   xA1
171C:  MOVLW  06
171E:  MOVWF  xA0
1720:  MOVLB  0
1722:  RCALL  15F8
....................  
....................    // Write our MAC address in the Ethernet source field 
....................    MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
1724:  MOVLB  2
1726:  CLRF   x9D
1728:  MOVLW  47
172A:  MOVFF  29D,29F
172E:  MOVWF  x9E
1730:  CLRF   xA1
1732:  MOVLW  06
1734:  MOVWF  xA0
1736:  MOVLB  0
1738:  RCALL  15F8
....................  
....................    // Write the appropriate Ethernet Type WORD for the protocol being used 
....................     MACPut(0x08); 
173A:  MOVLW  08
173C:  MOVLB  2
173E:  MOVWF  x9D
1740:  MOVLB  0
1742:  RCALL  15C2
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP); 
1744:  MOVLB  2
1746:  MOVF   x99,F
1748:  BNZ   174E
174A:  MOVLW  00
174C:  BRA    1750
174E:  MOVLW  06
1750:  MOVWF  x9D
1752:  MOVLB  0
1754:  RCALL  15C2
.................... } 
1756:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACFlush(void) 
....................  * 
....................  * PreCondition:    A packet has been created by calling MACPut() and 
....................  *               MACPutHeader(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACFlush causes the current TX packet to be sent out on 
....................  *               the Ethernet medium.  The hardware MAC will take control 
....................  *               and handle CRC generation, collision retransmission and 
....................  *               other details. 
....................  * 
....................  * Note:         After transmission completes (MACIsTxReady() returns TRUE), 
....................  *               the packet can be modified and transmitted again by calling 
....................  *               MACFlush() again.  Until MACPutHeader() or MACPut() is 
....................  *               called (in the TX data area), the data in the TX buffer 
....................  *               will not be corrupted. 
....................  *****************************************************************************/ 
.................... void MACFlush(void) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
1758:  CLRF   19
175A:  BTFSC  FF2.7
175C:  BSF    19.7
175E:  BCF    FF2.7
....................    // Set the packet start and end address pointers 
....................    BankSel(ETXSTL); 
....................    WriteReg(ETXSTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(ETXSTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................    WriteReg(ETXNDL, TxBuffers[CurrentTxBuffer].EndAddress.v[0]); 
....................    WriteReg(ETXNDH, TxBuffers[CurrentTxBuffer].EndAddress.v[1]); 
....................    LastTXedBuffer = CurrentTxBuffer; 
....................    TxBuffers[CurrentTxBuffer].Flags.bTransmitted = TRUE; 
.................... #endif 
....................  
....................    // Reset transmit logic if a TX Error has previously occured 
....................    // This is a silicon errata workaround 
....................    if(ReadETHReg(EIR).EIRbits.TXERIF) 
1760:  MOVLW  1C
1762:  MOVLB  2
1764:  MOVWF  xA9
1766:  MOVLB  0
1768:  CALL   016C
176C:  BTFSC  19.7
176E:  BSF    FF2.7
1770:  BTFSS  01.1
1772:  BRA    17AC
1774:  CLRF   19
1776:  BTFSC  FF2.7
1778:  BSF    19.7
177A:  BCF    FF2.7
....................    { 
....................       BFSReg(ECON1, ECON1_TXRST); 
177C:  MOVLW  1F
177E:  MOVLB  2
1780:  MOVWF  xB5
1782:  MOVLW  80
1784:  MOVWF  xB6
1786:  MOVLB  0
1788:  CALL   01E6
178C:  BTFSC  19.7
178E:  BSF    FF2.7
1790:  CLRF   19
1792:  BTFSC  FF2.7
1794:  BSF    19.7
1796:  BCF    FF2.7
....................       BFCReg(ECON1, ECON1_TXRST); 
1798:  MOVLW  1F
179A:  MOVLB  2
179C:  MOVWF  xB2
179E:  MOVLW  80
17A0:  MOVWF  xB3
17A2:  MOVLB  0
17A4:  CALL   01C8
17A8:  BTFSC  19.7
17AA:  BSF    FF2.7
17AC:  CLRF   19
17AE:  BTFSC  FF2.7
17B0:  BSF    19.7
17B2:  BCF    FF2.7
....................    } 
....................    BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
17B4:  MOVLW  1C
17B6:  MOVLB  2
17B8:  MOVWF  xB2
17BA:  MOVLW  0A
17BC:  MOVWF  xB3
17BE:  MOVLB  0
17C0:  CALL   01C8
17C4:  BTFSC  19.7
17C6:  BSF    FF2.7
17C8:  CLRF   19
17CA:  BTFSC  FF2.7
17CC:  BSF    19.7
17CE:  BCF    FF2.7
....................  
....................    // Start the transmission 
....................    // After transmission completes (MACIsTxReady() returns TRUE), the packet 
....................    // can be modified and transmitted again by calling MACFlush() again. 
....................    // Until MACPutHeader() is called, the data in the TX buffer will not be 
....................    // corrupted. 
....................    BFSReg(ECON1, ECON1_TXRTS); 
17D0:  MOVLW  1F
17D2:  MOVLB  2
17D4:  MOVWF  xB5
17D6:  MOVLW  08
17D8:  MOVWF  xB6
17DA:  MOVLB  0
17DC:  CALL   01E6
17E0:  BTFSC  19.7
17E2:  BSF    FF2.7
....................  
....................    // Revision B5 silicon errata workaround 
....................    if(ENCRevID == 0x05) 
17E4:  MOVF   x84,W
17E6:  SUBLW  05
17E8:  BTFSS  FD8.2
17EA:  BRA    1A88
17EC:  CLRF   19
17EE:  BTFSC  FF2.7
17F0:  BSF    19.7
17F2:  BCF    FF2.7
....................    { 
....................       while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
17F4:  MOVLW  1C
17F6:  MOVLB  2
17F8:  MOVWF  xA9
17FA:  MOVLB  0
17FC:  CALL   016C
1800:  BTFSC  19.7
1802:  BSF    FF2.7
1804:  MOVF   01,W
1806:  ANDLW  0A
1808:  BZ    17EC
180A:  CLRF   19
180C:  BTFSC  FF2.7
180E:  BSF    19.7
1810:  BCF    FF2.7
....................       if(ReadETHReg(EIR).EIRbits.TXERIF) 
1812:  MOVLW  1C
1814:  MOVLB  2
1816:  MOVWF  xA9
1818:  MOVLB  0
181A:  CALL   016C
181E:  BTFSC  19.7
1820:  BSF    FF2.7
1822:  BTFSS  01.1
1824:  BRA    1A88
1826:  CLRF   19
1828:  BTFSC  FF2.7
182A:  BSF    19.7
182C:  BCF    FF2.7
....................       { 
....................          WORD_VAL ReadPtrSave; 
....................          WORD_VAL TXEnd; 
....................          TXSTATUS TXStatus; 
....................          BYTE i; 
....................  
....................          // Cancel the previous transmission if it has become stuck set 
....................          BFCReg(ECON1, ECON1_TXRTS); 
182E:  MOVLW  1F
1830:  MOVLB  2
1832:  MOVWF  xB2
1834:  MOVLW  08
1836:  MOVWF  xB3
1838:  MOVLB  0
183A:  CALL   01C8
183E:  BTFSC  19.7
1840:  BSF    FF2.7
1842:  CLRF   19
1844:  BTFSC  FF2.7
1846:  BSF    19.7
1848:  BCF    FF2.7
....................  
....................          // Save the current read pointer (controlled by application) 
....................          BankSel(ERDPTL); 
184A:  MOVLB  2
184C:  CLRF   xB1
184E:  CLRF   xB0
1850:  MOVLB  0
1852:  CALL   0204
1856:  BTFSC  19.7
1858:  BSF    FF2.7
185A:  CLRF   19
185C:  BTFSC  FF2.7
185E:  BSF    19.7
1860:  BCF    FF2.7
....................          ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val; 
1862:  MOVLB  2
1864:  CLRF   xA9
1866:  MOVLB  0
1868:  CALL   016C
186C:  BTFSC  19.7
186E:  BSF    FF2.7
1870:  MOVFF  01,27A
1874:  CLRF   19
1876:  BTFSC  FF2.7
1878:  BSF    19.7
187A:  BCF    FF2.7
....................          ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val; 
187C:  MOVLW  01
187E:  MOVLB  2
1880:  MOVWF  xA9
1882:  MOVLB  0
1884:  CALL   016C
1888:  BTFSC  19.7
188A:  BSF    FF2.7
188C:  MOVFF  01,27B
1890:  CLRF   19
1892:  BTFSC  FF2.7
1894:  BSF    19.7
1896:  BCF    FF2.7
....................  
....................          // Get the location of the transmit status vector 
....................          TXEnd.v[0] = ReadETHReg(ETXNDL).Val; 
1898:  MOVLW  06
189A:  MOVLB  2
189C:  MOVWF  xA9
189E:  MOVLB  0
18A0:  CALL   016C
18A4:  BTFSC  19.7
18A6:  BSF    FF2.7
18A8:  MOVFF  01,27C
18AC:  CLRF   19
18AE:  BTFSC  FF2.7
18B0:  BSF    19.7
18B2:  BCF    FF2.7
....................          TXEnd.v[1] = ReadETHReg(ETXNDH).Val; 
18B4:  MOVLW  07
18B6:  MOVLB  2
18B8:  MOVWF  xA9
18BA:  MOVLB  0
18BC:  CALL   016C
18C0:  BTFSC  19.7
18C2:  BSF    FF2.7
18C4:  MOVFF  01,27D
....................          TXEnd.Val++; 
18C8:  MOVLB  2
18CA:  INCF   x7C,F
18CC:  BTFSC  FD8.2
18CE:  INCF   x7D,F
18D0:  CLRF   19
18D2:  BTFSC  FF2.7
18D4:  BSF    19.7
18D6:  BCF    FF2.7
....................  
....................          // Read the transmit status vector 
....................          WriteReg(ERDPTL, TXEnd.v[0]); 
18D8:  CLRF   xB3
18DA:  MOVFF  27C,2B4
18DE:  MOVLB  0
18E0:  CALL   01AA
18E4:  BTFSC  19.7
18E6:  BSF    FF2.7
18E8:  CLRF   19
18EA:  BTFSC  FF2.7
18EC:  BSF    19.7
18EE:  BCF    FF2.7
....................          WriteReg(ERDPTH, TXEnd.v[1]); 
18F0:  MOVLW  01
18F2:  MOVLB  2
18F4:  MOVWF  xB3
18F6:  MOVFF  27D,2B4
18FA:  MOVLB  0
18FC:  CALL   01AA
1900:  BTFSC  19.7
1902:  BSF    FF2.7
....................          MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
1904:  MOVLW  02
1906:  MOVLB  2
1908:  MOVWF  x87
190A:  MOVLW  7E
190C:  MOVFF  287,289
1910:  MOVWF  x88
1912:  CLRF   x8B
1914:  MOVLW  07
1916:  MOVWF  x8A
1918:  MOVLB  0
191A:  CALL   1110
....................  
....................          // Implement retransmission if a late collision occured (this can 
....................          // happen on B5 when certain link pulses arrive at the same time 
....................          // as the transmission) 
....................          for(i = 0; i < 16; i++) 
191E:  MOVLB  2
1920:  CLRF   x85
1922:  MOVF   x85,W
1924:  SUBLW  0F
1926:  BTFSS  FD8.0
1928:  BRA    1A54
192A:  CLRF   19
192C:  BTFSC  FF2.7
192E:  BSF    19.7
1930:  BCF    FF2.7
....................          { 
....................             if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision) 
1932:  MOVLW  1C
1934:  MOVWF  xA9
1936:  MOVLB  0
1938:  CALL   016C
193C:  BTFSC  19.7
193E:  BSF    FF2.7
1940:  BTFSS  01.1
1942:  BRA    1A48
1944:  MOVLB  2
1946:  BTFSC  x81.5
1948:  BRA    194E
194A:  MOVLB  0
194C:  BRA    1A48
194E:  CLRF   19
1950:  BTFSC  FF2.7
1952:  BSF    19.7
1954:  BCF    FF2.7
....................             { 
....................                // Reset the TX logic 
....................                BFSReg(ECON1, ECON1_TXRST); 
1956:  MOVLW  1F
1958:  MOVWF  xB5
195A:  MOVLW  80
195C:  MOVWF  xB6
195E:  MOVLB  0
1960:  CALL   01E6
1964:  BTFSC  19.7
1966:  BSF    FF2.7
1968:  CLRF   19
196A:  BTFSC  FF2.7
196C:  BSF    19.7
196E:  BCF    FF2.7
....................                BFCReg(ECON1, ECON1_TXRST); 
1970:  MOVLW  1F
1972:  MOVLB  2
1974:  MOVWF  xB2
1976:  MOVLW  80
1978:  MOVWF  xB3
197A:  MOVLB  0
197C:  CALL   01C8
1980:  BTFSC  19.7
1982:  BSF    FF2.7
1984:  CLRF   19
1986:  BTFSC  FF2.7
1988:  BSF    19.7
198A:  BCF    FF2.7
....................                BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
198C:  MOVLW  1C
198E:  MOVLB  2
1990:  MOVWF  xB2
1992:  MOVLW  0A
1994:  MOVWF  xB3
1996:  MOVLB  0
1998:  CALL   01C8
199C:  BTFSC  19.7
199E:  BSF    FF2.7
19A0:  CLRF   19
19A2:  BTFSC  FF2.7
19A4:  BSF    19.7
19A6:  BCF    FF2.7
....................  
....................                // Transmit the packet again 
....................                BFSReg(ECON1, ECON1_TXRTS); 
19A8:  MOVLW  1F
19AA:  MOVLB  2
19AC:  MOVWF  xB5
19AE:  MOVLW  08
19B0:  MOVWF  xB6
19B2:  MOVLB  0
19B4:  CALL   01E6
19B8:  BTFSC  19.7
19BA:  BSF    FF2.7
19BC:  CLRF   19
19BE:  BTFSC  FF2.7
19C0:  BSF    19.7
19C2:  BCF    FF2.7
....................                while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
19C4:  MOVLW  1C
19C6:  MOVLB  2
19C8:  MOVWF  xA9
19CA:  MOVLB  0
19CC:  CALL   016C
19D0:  BTFSC  19.7
19D2:  BSF    FF2.7
19D4:  MOVF   01,W
19D6:  ANDLW  0A
19D8:  BZ    19BC
19DA:  CLRF   19
19DC:  BTFSC  FF2.7
19DE:  BSF    19.7
19E0:  BCF    FF2.7
....................  
....................                // Cancel the previous transmission if it has become stuck set 
....................                BFCReg(ECON1, ECON1_TXRTS); 
19E2:  MOVLW  1F
19E4:  MOVLB  2
19E6:  MOVWF  xB2
19E8:  MOVLW  08
19EA:  MOVWF  xB3
19EC:  MOVLB  0
19EE:  CALL   01C8
19F2:  BTFSC  19.7
19F4:  BSF    FF2.7
19F6:  CLRF   19
19F8:  BTFSC  FF2.7
19FA:  BSF    19.7
19FC:  BCF    FF2.7
....................  
....................                // Read transmit status vector 
....................                WriteReg(ERDPTL, TXEnd.v[0]); 
19FE:  MOVLB  2
1A00:  CLRF   xB3
1A02:  MOVFF  27C,2B4
1A06:  MOVLB  0
1A08:  CALL   01AA
1A0C:  BTFSC  19.7
1A0E:  BSF    FF2.7
1A10:  CLRF   19
1A12:  BTFSC  FF2.7
1A14:  BSF    19.7
1A16:  BCF    FF2.7
....................                WriteReg(ERDPTH, TXEnd.v[1]); 
1A18:  MOVLW  01
1A1A:  MOVLB  2
1A1C:  MOVWF  xB3
1A1E:  MOVFF  27D,2B4
1A22:  MOVLB  0
1A24:  CALL   01AA
1A28:  BTFSC  19.7
1A2A:  BSF    FF2.7
....................                MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
1A2C:  MOVLW  02
1A2E:  MOVLB  2
1A30:  MOVWF  x87
1A32:  MOVLW  7E
1A34:  MOVFF  287,289
1A38:  MOVWF  x88
1A3A:  CLRF   x8B
1A3C:  MOVLW  07
1A3E:  MOVWF  x8A
1A40:  MOVLB  0
1A42:  CALL   1110
....................             } 
....................             else 
1A46:  BRA    1A4E
....................             { 
....................                break; 
1A48:  MOVLB  2
1A4A:  BRA    1A54
1A4C:  MOVLB  0
....................             } 
....................          } 
1A4E:  MOVLB  2
1A50:  INCF   x85,F
1A52:  BRA    1922
1A54:  CLRF   19
1A56:  BTFSC  FF2.7
1A58:  BSF    19.7
1A5A:  BCF    FF2.7
....................  
....................          // Restore the current read pointer 
....................          WriteReg(ERDPTL, ReadPtrSave.v[0]); 
1A5C:  CLRF   xB3
1A5E:  MOVFF  27A,2B4
1A62:  MOVLB  0
1A64:  CALL   01AA
1A68:  BTFSC  19.7
1A6A:  BSF    FF2.7
1A6C:  CLRF   19
1A6E:  BTFSC  FF2.7
1A70:  BSF    19.7
1A72:  BCF    FF2.7
....................          WriteReg(ERDPTH, ReadPtrSave.v[1]); 
1A74:  MOVLW  01
1A76:  MOVLB  2
1A78:  MOVWF  xB3
1A7A:  MOVFF  27B,2B4
1A7E:  MOVLB  0
1A80:  CALL   01AA
1A84:  BTFSC  19.7
1A86:  BSF    FF2.7
....................       } 
....................    } 
.................... } 
1A88:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetRxBuffer(WORD offset) 
....................  * 
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and 
....................  *               getting a TRUE result. 
....................  * 
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         RXSTOP must be statically defined as being > RXSTART for 
....................  *               this function to work correctly.  In other words, do not 
....................  *               define an RX buffer which spans the 0x1FFF->0x0000 memory 
....................  *               boundary. 
....................  *****************************************************************************/ 
.................... void MACSetRxBuffer(WORD offset) 
.................... { 
....................    WORD_VAL ReadPT; 
....................  
....................    // Determine the address of the beginning of the entire packet 
....................    // and adjust the address to the desired location 
....................    ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
1E16:  MOVLW  14
1E18:  ADDWF  x81,W
1E1A:  MOVLB  2
1E1C:  MOVWF  x29
1E1E:  MOVLW  00
1E20:  MOVLB  0
1E22:  ADDWFC x82,W
1E24:  MOVLB  2
1E26:  MOVWF  x2A
1E28:  MOVF   x25,W
1E2A:  ADDWF  x29,W
1E2C:  MOVWF  x27
1E2E:  MOVF   x26,W
1E30:  ADDWFC x2A,W
1E32:  MOVWF  x28
....................  
....................    // Since the receive buffer is circular, adjust if a wraparound is needed 
....................    if ( ReadPT.Val > RXSTOP ) 
1E34:  MOVF   x28,W
1E36:  SUBLW  1A
1E38:  BC    1E4C
1E3A:  XORLW  FF
1E3C:  BNZ   1E44
1E3E:  MOVF   x27,W
1E40:  SUBLW  F7
1E42:  BC    1E4C
....................       ReadPT.Val -= RXSIZE; 
1E44:  MOVLW  F8
1E46:  SUBWF  x27,F
1E48:  MOVLW  1B
1E4A:  SUBWFB x28,F
1E4C:  CLRF   19
1E4E:  BTFSC  FF2.7
1E50:  BSF    19.7
1E52:  BCF    FF2.7
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(ERDPTL); 
1E54:  CLRF   xB1
1E56:  CLRF   xB0
1E58:  MOVLB  0
1E5A:  CALL   0204
1E5E:  BTFSC  19.7
1E60:  BSF    FF2.7
1E62:  CLRF   19
1E64:  BTFSC  FF2.7
1E66:  BSF    19.7
1E68:  BCF    FF2.7
....................    WriteReg(ERDPTL, ReadPT.v[0]); 
1E6A:  MOVLB  2
1E6C:  CLRF   xB3
1E6E:  MOVFF  227,2B4
1E72:  MOVLB  0
1E74:  CALL   01AA
1E78:  BTFSC  19.7
1E7A:  BSF    FF2.7
1E7C:  CLRF   19
1E7E:  BTFSC  FF2.7
1E80:  BSF    19.7
1E82:  BCF    FF2.7
....................    WriteReg(ERDPTH, ReadPT.v[1]); 
1E84:  MOVLW  01
1E86:  MOVLB  2
1E88:  MOVWF  xB3
1E8A:  MOVFF  228,2B4
1E8E:  MOVLB  0
1E90:  CALL   01AA
1E94:  BTFSC  19.7
1E96:  BSF    FF2.7
1E98:  CLRF   19
1E9A:  BTFSC  FF2.7
1E9C:  BSF    19.7
1E9E:  BCF    FF2.7
....................    WriteReg(EWRPTL, ReadPT.v[0]); 
1EA0:  MOVLW  02
1EA2:  MOVLB  2
1EA4:  MOVWF  xB3
1EA6:  MOVFF  227,2B4
1EAA:  MOVLB  0
1EAC:  CALL   01AA
1EB0:  BTFSC  19.7
1EB2:  BSF    FF2.7
1EB4:  CLRF   19
1EB6:  BTFSC  FF2.7
1EB8:  BSF    19.7
1EBA:  BCF    FF2.7
....................    WriteReg(EWRPTH, ReadPT.v[1]); 
1EBC:  MOVLW  03
1EBE:  MOVLB  2
1EC0:  MOVWF  xB3
1EC2:  MOVFF  228,2B4
1EC6:  MOVLB  0
1EC8:  CALL   01AA
1ECC:  BTFSC  19.7
1ECE:  BSF    FF2.7
.................... } 
1ED0:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetTxBuffer(BUFFER buffer, WORD offset) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           buffer: BYTE specifying which transmit buffer to seek 
....................  *                     within.  If MAC_TX_BUFFER_COUNT <= 1, this 
....................  *                     parameter is not used. 
....................  *               offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         None 
....................  *****************************************************************************/ 
.................... void MACSetTxBuffer(BUFFER buffer, WORD offset) 
.................... { 
....................     CurrentTxBuffer = buffer; 
*
14FC:  MOVFF  293,7A
....................  
....................    // Calculate the proper address.  Since the TX memory area is not circular, 
....................    // no wrapparound checks are necessary. +1 adjustment is needed because of 
....................    // the per packet control byte which preceeds the packet in the TX memory 
....................    // area. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    offset += TxBuffers[buffer].StartAddress.Val + 1 + sizeof(ETHER_HEADER); 
.................... #else 
....................    offset += TXSTART + 1 + sizeof(ETHER_HEADER); 
1500:  MOVLW  07
1502:  MOVLB  2
1504:  ADDWF  x94,F
1506:  MOVLW  1C
1508:  ADDWFC x95,F
150A:  CLRF   19
150C:  BTFSC  FF2.7
150E:  BSF    19.7
1510:  BCF    FF2.7
.................... #endif 
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(EWRPTL); 
1512:  CLRF   xB1
1514:  MOVLW  02
1516:  MOVWF  xB0
1518:  MOVLB  0
151A:  CALL   0204
151E:  BTFSC  19.7
1520:  BSF    FF2.7
....................    WriteReg(ERDPTL, ((WORD_VAL*)&offset)->v[0]); 
1522:  MOVLW  02
1524:  MOVWF  FEA
1526:  MOVLW  94
1528:  MOVWF  FE9
152A:  MOVFF  FEF,298
152E:  CLRF   19
1530:  BTFSC  FF2.7
1532:  BSF    19.7
1534:  BCF    FF2.7
1536:  MOVLB  2
1538:  CLRF   xB3
153A:  MOVFF  298,2B4
153E:  MOVLB  0
1540:  CALL   01AA
1544:  BTFSC  19.7
1546:  BSF    FF2.7
....................    WriteReg(ERDPTH, ((WORD_VAL*)&offset)->v[1]); 
1548:  MOVLW  02
154A:  MOVWF  FEA
154C:  MOVLW  95
154E:  MOVWF  FE9
1550:  MOVFF  FEF,298
1554:  CLRF   19
1556:  BTFSC  FF2.7
1558:  BSF    19.7
155A:  BCF    FF2.7
155C:  MOVLW  01
155E:  MOVLB  2
1560:  MOVWF  xB3
1562:  MOVFF  298,2B4
1566:  MOVLB  0
1568:  CALL   01AA
156C:  BTFSC  19.7
156E:  BSF    FF2.7
....................    WriteReg(EWRPTL, ((WORD_VAL*)&offset)->v[0]); 
1570:  MOVLW  02
1572:  MOVWF  FEA
1574:  MOVLW  94
1576:  MOVWF  FE9
1578:  MOVFF  FEF,298
157C:  CLRF   19
157E:  BTFSC  FF2.7
1580:  BSF    19.7
1582:  BCF    FF2.7
1584:  MOVLW  02
1586:  MOVLB  2
1588:  MOVWF  xB3
158A:  MOVFF  298,2B4
158E:  MOVLB  0
1590:  CALL   01AA
1594:  BTFSC  19.7
1596:  BSF    FF2.7
....................    WriteReg(EWRPTH, ((WORD_VAL*)&offset)->v[1]); 
1598:  MOVLW  02
159A:  MOVWF  FEA
159C:  MOVLW  95
159E:  MOVWF  FE9
15A0:  MOVFF  FEF,298
15A4:  CLRF   19
15A6:  BTFSC  FF2.7
15A8:  BSF    19.7
15AA:  BCF    FF2.7
15AC:  MOVLW  03
15AE:  MOVLB  2
15B0:  MOVWF  xB3
15B2:  MOVFF  298,2B4
15B6:  MOVLB  0
15B8:  CALL   01AA
15BC:  BTFSC  19.7
15BE:  BSF    FF2.7
.................... } 
15C0:  RETLW  00
....................  
....................  
.................... #if defined(MCHP_MAC) 
.................... // MACCalcRxChecksum() and MACCalcTxChecksum() use the DMA module to calculate 
.................... // checksums.  These two functions have been tested. 
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcRxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Add the offset requested by firmware plus the Ethernet header 
....................    temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
1CAE:  MOVLW  14
1CB0:  ADDWF  x81,W
1CB2:  MOVLB  2
1CB4:  MOVWF  x53
1CB6:  MOVLW  00
1CB8:  MOVLB  0
1CBA:  ADDWFC x82,W
1CBC:  MOVLB  2
1CBE:  MOVWF  x54
1CC0:  MOVF   x4D,W
1CC2:  ADDWF  x53,W
1CC4:  MOVWF  x51
1CC6:  MOVF   x4E,W
1CC8:  ADDWFC x54,W
1CCA:  MOVWF  x52
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
1CCC:  MOVF   x52,W
1CCE:  SUBLW  1A
1CD0:  BC    1CE4
1CD2:  XORLW  FF
1CD4:  BNZ   1CDC
1CD6:  MOVF   x51,W
1CD8:  SUBLW  F7
1CDA:  BC    1CE4
....................    { 
....................       temp.Val -= RXSIZE; 
1CDC:  MOVLW  F8
1CDE:  SUBWF  x51,F
1CE0:  MOVLW  1B
1CE2:  SUBWFB x52,F
1CE4:  CLRF   19
1CE6:  BTFSC  FF2.7
1CE8:  BSF    19.7
1CEA:  BCF    FF2.7
....................    } 
....................  
....................    // Program the start address of the DMA 
....................    BankSel(EDMASTL); 
1CEC:  CLRF   xB1
1CEE:  MOVLW  10
1CF0:  MOVWF  xB0
1CF2:  MOVLB  0
1CF4:  CALL   0204
1CF8:  BTFSC  19.7
1CFA:  BSF    FF2.7
1CFC:  CLRF   19
1CFE:  BTFSC  FF2.7
1D00:  BSF    19.7
1D02:  BCF    FF2.7
....................    WriteReg(EDMASTL, temp.v[0]); 
1D04:  MOVLW  10
1D06:  MOVLB  2
1D08:  MOVWF  xB3
1D0A:  MOVFF  251,2B4
1D0E:  MOVLB  0
1D10:  CALL   01AA
1D14:  BTFSC  19.7
1D16:  BSF    FF2.7
1D18:  CLRF   19
1D1A:  BTFSC  FF2.7
1D1C:  BSF    19.7
1D1E:  BCF    FF2.7
....................    WriteReg(EDMASTH, temp.v[1]); 
1D20:  MOVLW  11
1D22:  MOVLB  2
1D24:  MOVWF  xB3
1D26:  MOVFF  252,2B4
1D2A:  MOVLB  0
1D2C:  CALL   01AA
1D30:  BTFSC  19.7
1D32:  BSF    FF2.7
....................  
....................    // Calculate the end address, given the start address and len 
....................    temp.Val += len-1; 
1D34:  MOVLW  01
1D36:  MOVLB  2
1D38:  SUBWF  x4F,W
1D3A:  MOVWF  00
1D3C:  MOVLW  00
1D3E:  SUBWFB x50,W
1D40:  MOVWF  03
1D42:  MOVF   00,W
1D44:  ADDWF  x51,F
1D46:  MOVF   03,W
1D48:  ADDWFC x52,F
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
1D4A:  MOVF   x52,W
1D4C:  SUBLW  1A
1D4E:  BC    1D62
1D50:  XORLW  FF
1D52:  BNZ   1D5A
1D54:  MOVF   x51,W
1D56:  SUBLW  F7
1D58:  BC    1D62
....................    { 
....................       temp.Val -= RXSIZE; 
1D5A:  MOVLW  F8
1D5C:  SUBWF  x51,F
1D5E:  MOVLW  1B
1D60:  SUBWFB x52,F
1D62:  CLRF   19
1D64:  BTFSC  FF2.7
1D66:  BSF    19.7
1D68:  BCF    FF2.7
....................    } 
....................  
....................    // Program the end address of the DMA 
....................    WriteReg(EDMANDL, temp.v[0]); 
1D6A:  MOVLW  12
1D6C:  MOVWF  xB3
1D6E:  MOVFF  251,2B4
1D72:  MOVLB  0
1D74:  CALL   01AA
1D78:  BTFSC  19.7
1D7A:  BSF    FF2.7
1D7C:  CLRF   19
1D7E:  BTFSC  FF2.7
1D80:  BSF    19.7
1D82:  BCF    FF2.7
....................    WriteReg(EDMANDH, temp.v[1]); 
1D84:  MOVLW  13
1D86:  MOVLB  2
1D88:  MOVWF  xB3
1D8A:  MOVFF  252,2B4
1D8E:  MOVLB  0
1D90:  CALL   01AA
1D94:  BTFSC  19.7
1D96:  BSF    FF2.7
1D98:  CLRF   19
1D9A:  BTFSC  FF2.7
1D9C:  BSF    19.7
1D9E:  BCF    FF2.7
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
1DA0:  MOVLW  1F
1DA2:  MOVLB  2
1DA4:  MOVWF  xB5
1DA6:  MOVLW  30
1DA8:  MOVWF  xB6
1DAA:  MOVLB  0
1DAC:  CALL   01E6
1DB0:  BTFSC  19.7
1DB2:  BSF    FF2.7
1DB4:  CLRF   19
1DB6:  BTFSC  FF2.7
1DB8:  BSF    19.7
1DBA:  BCF    FF2.7
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
1DBC:  MOVLW  1F
1DBE:  MOVLB  2
1DC0:  MOVWF  xA9
1DC2:  MOVLB  0
1DC4:  CALL   016C
1DC8:  BTFSC  19.7
1DCA:  BSF    FF2.7
1DCC:  BTFSC  01.5
1DCE:  BRA    1DB4
1DD0:  CLRF   19
1DD2:  BTFSC  FF2.7
1DD4:  BSF    19.7
1DD6:  BCF    FF2.7
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
1DD8:  MOVLW  16
1DDA:  MOVLB  2
1DDC:  MOVWF  xA9
1DDE:  MOVLB  0
1DE0:  CALL   016C
1DE4:  BTFSC  19.7
1DE6:  BSF    FF2.7
1DE8:  MOVFF  01,252
1DEC:  CLRF   19
1DEE:  BTFSC  FF2.7
1DF0:  BSF    19.7
1DF2:  BCF    FF2.7
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
1DF4:  MOVLW  17
1DF6:  MOVLB  2
1DF8:  MOVWF  xA9
1DFA:  MOVLB  0
1DFC:  CALL   016C
1E00:  BTFSC  19.7
1E02:  BSF    FF2.7
1E04:  MOVFF  01,251
....................    return temp.Val; 
1E08:  MOVLB  2
1E0A:  MOVFF  251,01
1E0E:  MOVFF  252,02
.................... } 
1E12:  MOVLB  0
1E14:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcTxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcTxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Program the start address of the DMA, after adjusting for the Ethernet 
....................    // header 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    temp.Val = TxBuffers[CurrentTxBuffer].StartAddress.Val + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
.................... #else 
....................    temp.Val = TXSTART + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
*
2AB8:  MOVLW  06
2ABA:  MOVLB  2
2ABC:  ADDWF  x93,W
2ABE:  MOVWF  x99
2AC0:  MOVLW  1C
2AC2:  ADDWFC x94,W
2AC4:  MOVWF  x9A
2AC6:  MOVLW  01
2AC8:  ADDWF  x99,W
2ACA:  MOVWF  x97
2ACC:  MOVLW  00
2ACE:  ADDWFC x9A,W
2AD0:  MOVWF  x98
2AD2:  CLRF   19
2AD4:  BTFSC  FF2.7
2AD6:  BSF    19.7
2AD8:  BCF    FF2.7
.................... #endif 
....................    BankSel(EDMASTL); 
2ADA:  CLRF   xB1
2ADC:  MOVLW  10
2ADE:  MOVWF  xB0
2AE0:  MOVLB  0
2AE2:  CALL   0204
2AE6:  BTFSC  19.7
2AE8:  BSF    FF2.7
2AEA:  CLRF   19
2AEC:  BTFSC  FF2.7
2AEE:  BSF    19.7
2AF0:  BCF    FF2.7
....................    WriteReg(EDMASTL, temp.v[0]); 
2AF2:  MOVLW  10
2AF4:  MOVLB  2
2AF6:  MOVWF  xB3
2AF8:  MOVFF  297,2B4
2AFC:  MOVLB  0
2AFE:  CALL   01AA
2B02:  BTFSC  19.7
2B04:  BSF    FF2.7
2B06:  CLRF   19
2B08:  BTFSC  FF2.7
2B0A:  BSF    19.7
2B0C:  BCF    FF2.7
....................    WriteReg(EDMASTH, temp.v[1]); 
2B0E:  MOVLW  11
2B10:  MOVLB  2
2B12:  MOVWF  xB3
2B14:  MOVFF  298,2B4
2B18:  MOVLB  0
2B1A:  CALL   01AA
2B1E:  BTFSC  19.7
2B20:  BSF    FF2.7
....................  
....................    // Program the end address of the DMA. 
....................    temp.Val += len-1; 
2B22:  MOVLW  01
2B24:  MOVLB  2
2B26:  SUBWF  x95,W
2B28:  MOVWF  00
2B2A:  MOVLW  00
2B2C:  SUBWFB x96,W
2B2E:  MOVWF  03
2B30:  MOVF   00,W
2B32:  ADDWF  x97,F
2B34:  MOVF   03,W
2B36:  ADDWFC x98,F
2B38:  CLRF   19
2B3A:  BTFSC  FF2.7
2B3C:  BSF    19.7
2B3E:  BCF    FF2.7
....................    WriteReg(EDMANDL, temp.v[0]); 
2B40:  MOVLW  12
2B42:  MOVWF  xB3
2B44:  MOVFF  297,2B4
2B48:  MOVLB  0
2B4A:  CALL   01AA
2B4E:  BTFSC  19.7
2B50:  BSF    FF2.7
2B52:  CLRF   19
2B54:  BTFSC  FF2.7
2B56:  BSF    19.7
2B58:  BCF    FF2.7
....................    WriteReg(EDMANDH, temp.v[1]); 
2B5A:  MOVLW  13
2B5C:  MOVLB  2
2B5E:  MOVWF  xB3
2B60:  MOVFF  298,2B4
2B64:  MOVLB  0
2B66:  CALL   01AA
2B6A:  BTFSC  19.7
2B6C:  BSF    FF2.7
2B6E:  CLRF   19
2B70:  BTFSC  FF2.7
2B72:  BSF    19.7
2B74:  BCF    FF2.7
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
2B76:  MOVLW  1F
2B78:  MOVLB  2
2B7A:  MOVWF  xB5
2B7C:  MOVLW  30
2B7E:  MOVWF  xB6
2B80:  MOVLB  0
2B82:  CALL   01E6
2B86:  BTFSC  19.7
2B88:  BSF    FF2.7
2B8A:  CLRF   19
2B8C:  BTFSC  FF2.7
2B8E:  BSF    19.7
2B90:  BCF    FF2.7
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
2B92:  MOVLW  1F
2B94:  MOVLB  2
2B96:  MOVWF  xA9
2B98:  MOVLB  0
2B9A:  CALL   016C
2B9E:  BTFSC  19.7
2BA0:  BSF    FF2.7
2BA2:  BTFSC  01.5
2BA4:  BRA    2B8A
2BA6:  CLRF   19
2BA8:  BTFSC  FF2.7
2BAA:  BSF    19.7
2BAC:  BCF    FF2.7
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
2BAE:  MOVLW  16
2BB0:  MOVLB  2
2BB2:  MOVWF  xA9
2BB4:  MOVLB  0
2BB6:  CALL   016C
2BBA:  BTFSC  19.7
2BBC:  BSF    FF2.7
2BBE:  MOVFF  01,298
2BC2:  CLRF   19
2BC4:  BTFSC  FF2.7
2BC6:  BSF    19.7
2BC8:  BCF    FF2.7
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
2BCA:  MOVLW  17
2BCC:  MOVLB  2
2BCE:  MOVWF  xA9
2BD0:  MOVLB  0
2BD2:  CALL   016C
2BD6:  BTFSC  19.7
2BD8:  BSF    FF2.7
2BDA:  MOVFF  01,297
....................    return temp.Val; 
2BDE:  MOVLB  2
2BE0:  MOVFF  297,01
2BE4:  MOVFF  298,02
.................... } 
2BE8:  MOVLB  0
2BEA:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    Read buffer pointer set to starting of checksum data 
....................  * 
....................  * Input:           len: Total number of bytes to calculate the checksum over. 
....................  *                   The first byte included in the checksum is the byte 
....................  *                   pointed to by ERDPT, which is updated by calls to 
....................  *                   MACGet(), MACSetRxBuffer(), MACSetTxBuffer(), etc. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module 
....................  *               which can calculate the checksum faster than software, so 
....................  *               this function replaces the CaclIPBufferChecksum() function 
....................  *               defined in the helpers.c file.  Through the use of 
....................  *               preprocessor defines, this replacement is automatic. 
....................  * 
....................  * Note:            This function works either in the RX buffer area or the TX 
....................  *               buffer area.  No validation is done on the len parameter. 
....................  *****************************************************************************/ 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Take care of special cases which the DMA cannot be used for 
....................    if(len == 0u) 
*
21D8:  MOVLB  2
21DA:  MOVF   x7A,F
21DC:  BNZ   21EC
21DE:  MOVF   x7B,F
21E0:  BNZ   21EC
....................    { 
....................       return 0xFFFF; 
21E2:  MOVLW  FF
21E4:  MOVWF  01
21E6:  MOVWF  02
21E8:  BRA    23A0
....................    } 
....................    else if(len == 1u) 
21EA:  BRA    221A
21EC:  DECFSZ x7A,W
21EE:  BRA    221A
21F0:  MOVF   x7B,F
21F2:  BNZ   221A
....................    { 
....................       return ~(((WORD)MACGet())<<8); 
21F4:  MOVLB  0
21F6:  RCALL  2194
21F8:  MOVLB  2
21FA:  CLRF   x7F
21FC:  MOVFF  01,27E
2200:  MOVFF  01,03
2204:  MOVLW  00
2206:  CLRF   00
2208:  DECF   00,F
220A:  XORWF  00,F
220C:  MOVLW  FF
220E:  XORWF  03,F
2210:  MOVFF  00,01
2214:  MOVFF  03,02
2218:  BRA    23A0
221A:  CLRF   19
221C:  BTFSC  FF2.7
221E:  BSF    19.7
2220:  BCF    FF2.7
....................    } 
....................  
....................  
....................    // Set the DMA starting address to the SPI read pointer value 
....................    BankSel(ERDPTL); 
2222:  CLRF   xB1
2224:  CLRF   xB0
2226:  MOVLB  0
2228:  CALL   0204
222C:  BTFSC  19.7
222E:  BSF    FF2.7
2230:  CLRF   19
2232:  BTFSC  FF2.7
2234:  BSF    19.7
2236:  BCF    FF2.7
....................    temp.v[0] = ReadETHReg(ERDPTL).Val; 
2238:  MOVLB  2
223A:  CLRF   xA9
223C:  MOVLB  0
223E:  CALL   016C
2242:  BTFSC  19.7
2244:  BSF    FF2.7
2246:  MOVFF  01,27C
224A:  CLRF   19
224C:  BTFSC  FF2.7
224E:  BSF    19.7
2250:  BCF    FF2.7
....................    temp.v[1] = ReadETHReg(ERDPTH).Val; 
2252:  MOVLW  01
2254:  MOVLB  2
2256:  MOVWF  xA9
2258:  MOVLB  0
225A:  CALL   016C
225E:  BTFSC  19.7
2260:  BSF    FF2.7
2262:  MOVFF  01,27D
2266:  CLRF   19
2268:  BTFSC  FF2.7
226A:  BSF    19.7
226C:  BCF    FF2.7
....................    WriteReg(EDMASTL, temp.v[0]); 
226E:  MOVLW  10
2270:  MOVLB  2
2272:  MOVWF  xB3
2274:  MOVFF  27C,2B4
2278:  MOVLB  0
227A:  CALL   01AA
227E:  BTFSC  19.7
2280:  BSF    FF2.7
2282:  CLRF   19
2284:  BTFSC  FF2.7
2286:  BSF    19.7
2288:  BCF    FF2.7
....................    WriteReg(EDMASTH, temp.v[1]); 
228A:  MOVLW  11
228C:  MOVLB  2
228E:  MOVWF  xB3
2290:  MOVFF  27D,2B4
2294:  MOVLB  0
2296:  CALL   01AA
229A:  BTFSC  19.7
229C:  BSF    FF2.7
....................  
....................    // See if we are calculating a checksum within the RX buffer (where 
....................    // wrapping rules apply) or TX/unused area (where wrapping rules are 
....................    // not applied) 
.................... #if RXSTART == 0 
....................    if(temp.Val <= RXSTOP) 
229E:  MOVLB  2
22A0:  MOVF   x7D,W
22A2:  SUBLW  1B
22A4:  BNC   22DC
22A6:  BNZ   22AE
22A8:  MOVF   x7C,W
22AA:  SUBLW  F7
22AC:  BNC   22DC
.................... #else 
....................    if(temp.Val >= RXSTART && temp.Val <= RXSTOP) 
.................... #endif 
....................    { 
....................       // Calculate the DMA ending address given the starting address and len 
....................       // parameter.  The DMA will follow the receive buffer wrapping boundary. 
....................       temp.Val += len-1; 
22AE:  MOVLW  01
22B0:  SUBWF  x7A,W
22B2:  MOVWF  00
22B4:  MOVLW  00
22B6:  SUBWFB x7B,W
22B8:  MOVWF  03
22BA:  MOVF   00,W
22BC:  ADDWF  x7C,F
22BE:  MOVF   03,W
22C0:  ADDWFC x7D,F
....................       if(temp.Val > RXSTOP) 
22C2:  MOVF   x7D,W
22C4:  SUBLW  1A
22C6:  BC    22DA
22C8:  XORLW  FF
22CA:  BNZ   22D2
22CC:  MOVF   x7C,W
22CE:  SUBLW  F7
22D0:  BC    22DA
....................       { 
....................          temp.Val -= RXSIZE; 
22D2:  MOVLW  F8
22D4:  SUBWF  x7C,F
22D6:  MOVLW  1B
22D8:  SUBWFB x7D,F
....................       } 
....................    } 
....................    else 
22DA:  BRA    22F0
....................    { 
....................       temp.Val += len-1; 
22DC:  MOVLW  01
22DE:  SUBWF  x7A,W
22E0:  MOVWF  00
22E2:  MOVLW  00
22E4:  SUBWFB x7B,W
22E6:  MOVWF  03
22E8:  MOVF   00,W
22EA:  ADDWF  x7C,F
22EC:  MOVF   03,W
22EE:  ADDWFC x7D,F
22F0:  CLRF   19
22F2:  BTFSC  FF2.7
22F4:  BSF    19.7
22F6:  BCF    FF2.7
....................    } 
....................  
....................    // Write the DMA end address 
....................    WriteReg(EDMANDL, temp.v[0]); 
22F8:  MOVLW  12
22FA:  MOVWF  xB3
22FC:  MOVFF  27C,2B4
2300:  MOVLB  0
2302:  CALL   01AA
2306:  BTFSC  19.7
2308:  BSF    FF2.7
230A:  CLRF   19
230C:  BTFSC  FF2.7
230E:  BSF    19.7
2310:  BCF    FF2.7
....................    WriteReg(EDMANDH, temp.v[1]); 
2312:  MOVLW  13
2314:  MOVLB  2
2316:  MOVWF  xB3
2318:  MOVFF  27D,2B4
231C:  MOVLB  0
231E:  CALL   01AA
2322:  BTFSC  19.7
2324:  BSF    FF2.7
2326:  CLRF   19
2328:  BTFSC  FF2.7
232A:  BSF    19.7
232C:  BCF    FF2.7
....................  
....................    // Begin the DMA checksum calculation and wait until it is finished 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
232E:  MOVLW  1F
2330:  MOVLB  2
2332:  MOVWF  xB5
2334:  MOVLW  30
2336:  MOVWF  xB6
2338:  MOVLB  0
233A:  CALL   01E6
233E:  BTFSC  19.7
2340:  BSF    FF2.7
2342:  CLRF   19
2344:  BTFSC  FF2.7
2346:  BSF    19.7
2348:  BCF    FF2.7
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
234A:  MOVLW  1F
234C:  MOVLB  2
234E:  MOVWF  xA9
2350:  MOVLB  0
2352:  CALL   016C
2356:  BTFSC  19.7
2358:  BSF    FF2.7
235A:  BTFSC  01.5
235C:  BRA    2342
235E:  CLRF   19
2360:  BTFSC  FF2.7
2362:  BSF    19.7
2364:  BCF    FF2.7
....................  
....................    // Return the resulting good stuff 
....................    temp.v[0] = ReadETHReg(EDMACSL).Val; 
2366:  MOVLW  16
2368:  MOVLB  2
236A:  MOVWF  xA9
236C:  MOVLB  0
236E:  CALL   016C
2372:  BTFSC  19.7
2374:  BSF    FF2.7
2376:  MOVFF  01,27C
237A:  CLRF   19
237C:  BTFSC  FF2.7
237E:  BSF    19.7
2380:  BCF    FF2.7
....................    temp.v[1] = ReadETHReg(EDMACSH).Val; 
2382:  MOVLW  17
2384:  MOVLB  2
2386:  MOVWF  xA9
2388:  MOVLB  0
238A:  CALL   016C
238E:  BTFSC  19.7
2390:  BSF    FF2.7
2392:  MOVFF  01,27D
....................    return temp.Val; 
2396:  MOVLB  2
2398:  MOVFF  27C,01
239C:  MOVFF  27D,02
.................... } 
23A0:  MOVLB  0
23A2:  RETLW  00
.................... #endif   // End of MCHP_MAC specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           RxOffset: Offset in the RX buffer (0=first byte of 
....................  *                        destination MAC address) to copy from. 
....................  *               TxOffset: Offset in the TX buffer (0=first byte of 
....................  *                       destination MAC address) to copy to. 
....................  *               len:     Number of bytes to copy 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        If the TX logic is transmitting a packet (ECON1.TXRTS is 
....................  *               set), the hardware will wait until it is finished.  Then, 
....................  *               the DMA module will copy the data from the receive buffer 
....................  *               to the transmit buffer. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... // Remove this line if your application needs to use this 
.................... // function.  This code has NOT been tested. 
.................... #if 0 
.................... void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    temp.Val = CurrentPacketLocation.Val + RxOffset + sizeof(ENC_PREAMBLE); 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    BankSel(EDMASTL); 
....................    WriteReg(EDMASTL, temp.v[0]); 
....................    WriteReg(EDMASTH, temp.v[1]); 
....................  
....................    temp.Val += len-1; 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    WriteReg(EDMANDL, temp.v[0]); 
....................    WriteReg(EDMANDH, temp.v[1]); 
....................  
....................    TxOffset += TXSTART+1; 
....................    WriteReg(EDMADSTL, ((WORD_VAL*)&TxOffset)->v[0]); 
....................    WriteReg(EDMADSTH, ((WORD_VAL*)&TxOffset)->v[1]); 
....................  
....................    // Do the DMA Copy.  The DMA module will wait for TXRTS to become clear 
....................    // before starting the copy. 
....................    BFCReg(ECON1, ECON1_CSUMEN); 
....................    BFSReg(ECON1, ECON1_DMAST); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
.................... } 
.................... #endif 
....................  
....................  
.................... #if defined(MAC_FILTER_BROADCASTS) 
.................... // NOTE: This code has NOT been tested.  See StackTsk.h's explanation 
.................... // of MAC_FILTER_BROADCASTS. 
.................... /****************************************************************************** 
....................  * Function:        void MACSetPMFilter(BYTE *Pattern, 
....................  *                              BYTE *PatternMask, 
....................  *                              WORD PatternOffset) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                MACIsTxReady() must return TRUE 
....................  * 
....................  * Input:           *Pattern: Pointer to an intial pattern to compare against 
....................  *               *PatternMask: Pointer to an 8 byte pattern mask which 
....................  *                          defines which bytes of the pattern are 
....................  *                          important.  At least one bit must be set. 
....................  *               PatternOffset: Offset from the beginning of the Ethernet 
....................  *                           frame (1st byte of destination address), to 
....................  *                           begin comparing with the given pattern. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Contents of the TX buffer space are overwritten 
....................  * 
....................  * Overview:        MACSetPMFilter sets the hardware receive filters for: 
....................  *               CRC AND (Unicast OR Pattern Match).  As a result, only a 
....................  *               subset of the broadcast packets which are normally 
....................  *               received will be received. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACSetPMFilter(BYTE *Pattern, 
....................                BYTE *PatternMask, 
....................                WORD PatternOffset) 
.................... { 
....................    WORD_VAL i; 
....................    BYTE *MaskPtr; 
....................    BYTE UnmaskedPatternLen; 
....................  
....................    // Set the SPI write pointer and DMA startting address to the beginning of 
....................    // the transmit buffer 
....................    BankSel(EWRPTL); 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
....................    WriteReg(EDMASTL, LOW(TXSTART)); 
....................    WriteReg(EDMASTH, HIGH(TXSTART)); 
....................  
....................    // Fill the transmit buffer with the pattern to match against.  Only the 
....................    // bytes which have a mask bit of 1 are written into the buffer and will 
....................    // subsequently be used for checksum computation. 
....................    MaskPtr = PatternMask; 
....................    for(i.Val = 0x0100; i.v[0] < 64; i.v[0]++) 
....................    { 
....................       if( *MaskPtr & i.v[1] ) 
....................       { 
....................          MACPut(*Pattern); 
....................          UnmaskedPatternLen++; 
....................       } 
....................       Pattern++; 
....................  
....................       i.v[1] <<= 1; 
....................       if( i.v[1] == 0u ) 
....................       { 
....................          i.v[1] = 0x01; 
....................          MaskPtr++; 
....................       } 
....................    } 
....................  
....................    // Calculate and set the DMA end address 
....................    i.Val = TXSTART + (WORD)UnmaskedPatternLen - 1; 
....................    WriteReg(EDMANDL, i.v[0]); 
....................    WriteReg(EDMANDH, i.v[1]); 
....................  
....................    // Calculate the checksum on the given pattern using the DMA module 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Make certain that the PM filter isn't enabled while it is 
....................    // being reconfigured. 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................  
....................    // Get the calculated DMA checksum and store it in the PM 
....................    // checksum registers 
....................    i.v[0] == ReadETHReg(EDMACSL).Val; 
....................    i.v[1] == ReadETHReg(EDMACSH).Val; 
....................    WriteReg(EPMCSL, i.v[0]); 
....................    WriteReg(EPMCSH, i.v[0]); 
....................  
....................    // Set the Pattern Match offset and 8 byte mask 
....................    WriteReg(EPMOL, ((WORD_VAL*)&PatternOffset)->v[0]); 
....................    WriteReg(EPMOH, ((WORD_VAL*)&PatternOffset)->v[1]); 
....................    for(i.Val = EPMM0; i.Val <= EPMM7 ; i.Val++) 
....................    { 
....................       WriteReg(i.Val, *PatternMask++); 
....................    } 
....................  
....................    // Begin using the new Pattern Match filter instead of the 
....................    // broadcast filter 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_PMEN); 
.................... }//end MACSetPMFilter 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDisablePMFilter(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACDisablePMFilter disables the Pattern Match receive 
....................  *               filter (if enabled) and returns to the default filter 
....................  *               configuration of: CRC AND (Unicast OR Broadcast). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDisablePMFilter(void) 
.................... { 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................    return; 
.................... }//end MACDisablePMFilter 
.................... #endif // end of MAC_FILTER_BROADCASTS specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE MACGet() 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and 
....................  *               increments ERDPT so MACGet() can be called again.  The 
....................  *               increment will follow the receive buffer wrapping boundary. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE MACGet() 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return SSPBUF; 
.................... */ 
....................    char c; 
....................  
....................    SPISelectEthernet(); 
*
2194:  BCF    F95.3
2196:  BCF    F8C.3
2198:  CLRF   19
219A:  BTFSC  FF2.7
219C:  BSF    19.7
219E:  BCF    FF2.7
....................    ENCSPIXfer(RBM); 
21A0:  MOVLW  3A
21A2:  MOVLB  2
21A4:  MOVWF  xB8
21A6:  MOVLB  0
21A8:  CALL   0132
21AC:  BTFSC  19.7
21AE:  BSF    FF2.7
21B0:  CLRF   19
21B2:  BTFSC  FF2.7
21B4:  BSF    19.7
21B6:  BCF    FF2.7
....................    c=ENCSPIXfer(0); 
21B8:  MOVLB  2
21BA:  CLRF   xB8
21BC:  MOVLB  0
21BE:  CALL   0132
21C2:  BTFSC  19.7
21C4:  BSF    FF2.7
21C6:  MOVFF  01,27E
....................    SPIUnselectEthernet(); 
21CA:  BCF    F95.3
21CC:  BSF    F8C.3
....................    return(c); 
21CE:  MOVLB  2
21D0:  MOVFF  27E,01
.................... }//end MACGet 
21D4:  MOVLB  0
21D6:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           *val: Pointer to storage location 
....................  *               len:  Number of bytes to read from the data buffer. 
....................  * 
....................  * Output:          Byte(s) of data read from the data buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Burst reads several sequential bytes from the data buffer 
....................  *               and places them into local memory.  With SPI burst support, 
....................  *               it performs much faster than multiple MACGet() calls. 
....................  *               ERDPT is incremented after each byte, following the same 
....................  *               rules as MACGet(). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetArray(BYTE *val, WORD len) 
.................... { 
*
1110:  MOVLB  2
1112:  CLRF   x8D
1114:  CLRF   x8C
.................... /* 
....................    int16 i; 
....................  
....................    // Start the burst operation 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM;         // Send the Read Buffer Memory opcode. 
....................    i = 0; 
....................    val--; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Read the data 
....................    while(i<len) 
....................    { 
....................       SSPBUF = 0;         // Send a dummy byte to receive a byte 
....................       i++; 
....................       val++; 
....................       while(!PIR1_SSPIF);   // Wait until byte is received. 
....................       PIR1_SSPIF = 0; 
....................       *val = SSPBUF; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
....................  
....................    return i; 
.................... */ 
....................  
....................    int16 i=0; 
....................  
....................    SPISelectEthernet(); 
1116:  BCF    F95.3
1118:  BCF    F8C.3
111A:  CLRF   19
111C:  BTFSC  FF2.7
111E:  BSF    19.7
1120:  BCF    FF2.7
....................    ENCSPIXfer(RBM); 
1122:  MOVLW  3A
1124:  MOVWF  xB8
1126:  MOVLB  0
1128:  CALL   0132
112C:  BTFSC  19.7
112E:  BSF    FF2.7
....................    while(i<len) 
....................    { 
1130:  MOVLB  2
1132:  MOVF   x8D,W
1134:  SUBWF  x8B,W
1136:  BNC   117C
1138:  BNZ   1140
113A:  MOVF   x8A,W
113C:  SUBWF  x8C,W
113E:  BC    117C
....................       *val=ENCSPIXfer(0); 
1140:  MOVFF  289,03
1144:  MOVFF  288,28E
1148:  MOVFF  289,28F
114C:  CLRF   19
114E:  BTFSC  FF2.7
1150:  BSF    19.7
1152:  BCF    FF2.7
1154:  CLRF   xB8
1156:  MOVLB  0
1158:  CALL   0132
115C:  BTFSC  19.7
115E:  BSF    FF2.7
1160:  MOVFF  28F,FEA
1164:  MOVFF  28E,FE9
1168:  MOVFF  01,FEF
....................       val++; 
116C:  MOVLB  2
116E:  INCF   x88,F
1170:  BTFSC  FD8.2
1172:  INCF   x89,F
....................       i++; 
1174:  INCF   x8C,F
1176:  BTFSC  FD8.2
1178:  INCF   x8D,F
....................    } 
117A:  BRA    1132
....................    SPIUnselectEthernet(); 
117C:  BCF    F95.3
117E:  BSF    F8C.3
....................  
....................    return(i); 
1180:  MOVFF  28C,01
1184:  MOVFF  28D,02
.................... }//end MACGetArray 
1188:  MOVLB  0
118A:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPut(BYTE val) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           Byte to write into the ENC28J60 buffer memory 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant 
....................  *               (8 bits) and data to write (8 bits) over the SPI. 
....................  *               EWRPT is incremented after the write. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPut(BYTE val) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the opcode and constant. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = val;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until byte is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
15C2:  BCF    F95.3
15C4:  BCF    F8C.3
15C6:  CLRF   19
15C8:  BTFSC  FF2.7
15CA:  BSF    19.7
15CC:  BCF    FF2.7
....................    ENCSPIXfer(WBM); 
15CE:  MOVLW  7A
15D0:  MOVLB  2
15D2:  MOVWF  xB8
15D4:  MOVLB  0
15D6:  CALL   0132
15DA:  BTFSC  19.7
15DC:  BSF    FF2.7
15DE:  CLRF   19
15E0:  BTFSC  FF2.7
15E2:  BSF    19.7
15E4:  BCF    FF2.7
....................    ENCSPIXfer(val); 
15E6:  MOVFF  29D,2B8
15EA:  CALL   0132
15EE:  BTFSC  19.7
15F0:  BSF    FF2.7
....................    SPIUnselectEthernet(); 
15F2:  BCF    F95.3
15F4:  BSF    F8C.3
.................... }//end MACPut 
15F6:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *               len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *               ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *               calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutArray(BYTE *val, WORD len) 
.................... { 
.................... /* 
....................    // Select the chip and send the proper opcode 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the Write Buffer Memory opcode 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Send the data 
....................    while(len) 
....................    { 
....................       SSPBUF = *val;      // Start sending the byte 
....................       val++;            // Increment after writing to SSPBUF to increase speed 
....................       len--;            // Decrement after writing to SSPBUF to increase speed 
....................       while(!PIR1_SSPIF);   // Wait until byte is transmitted 
....................       PIR1_SSPIF = 0; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
15F8:  BCF    F95.3
15FA:  BCF    F8C.3
15FC:  CLRF   19
15FE:  BTFSC  FF2.7
1600:  BSF    19.7
1602:  BCF    FF2.7
....................    ENCSPIXfer(WBM); 
1604:  MOVLW  7A
1606:  MOVLB  2
1608:  MOVWF  xB8
160A:  MOVLB  0
160C:  CALL   0132
1610:  BTFSC  19.7
1612:  BSF    FF2.7
....................    while(len--) 
....................    { 
1614:  MOVLB  2
1616:  MOVFF  2A1,03
161A:  MOVF   xA0,W
161C:  BTFSC  FD8.2
161E:  DECF   xA1,F
1620:  DECF   xA0,F
1622:  IORWF  03,W
1624:  BZ    1656
....................       ENCSPIXfer(*val); 
1626:  MOVFF  29F,03
162A:  MOVFF  29E,FE9
162E:  MOVFF  29F,FEA
1632:  MOVFF  FEF,2A2
1636:  CLRF   19
1638:  BTFSC  FF2.7
163A:  BSF    19.7
163C:  BCF    FF2.7
163E:  MOVFF  2A2,2B8
1642:  MOVLB  0
1644:  CALL   0132
1648:  BTFSC  19.7
164A:  BSF    FF2.7
....................       val++; 
164C:  MOVLB  2
164E:  INCF   x9E,F
1650:  BTFSC  FD8.2
1652:  INCF   x9F,F
....................    } 
1654:  BRA    1616
....................    SPIUnselectEthernet(); 
1656:  BCF    F95.3
1658:  BSF    F8C.3
.................... }//end MACPutArray 
165A:  MOVLB  0
165C:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static void SendSystemReset(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SendSystemReset sends the System Reset SPI command to 
....................  *               the Ethernet controller.  It resets all register contents 
....................  *               (except for ECOCON) and returns the device to the power 
....................  *               on default state. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void SendSystemReset(void) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = SR; 
....................    while(!PIR1_SSPIF);      // Wait until the command is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
0196:  BCF    F95.3
0198:  BCF    F8C.3
....................    ENCSPIXfer(SR); 
019A:  MOVLW  FF
019C:  MOVLB  2
019E:  MOVWF  xB8
01A0:  MOVLB  0
01A2:  RCALL  0132
....................    SPIUnselectEthernet(); 
01A4:  BCF    F95.3
01A6:  BSF    F8C.3
.................... }//end SendSystemReset 
01A8:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadETHReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the ETH control register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's ETH register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over 
....................  *               the SPI and then retrives the register contents in the 
....................  *               next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access MAC/MII or PHY 
....................  *               registers.  Use ReadMACReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadETHReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    // Select the chip and send the Read Control Register opcode/address 
....................    SPISelectEthernet(); 
....................    SSPBUF = RCR | Address; 
....................  
....................    while(!PIR1_SSPIF);      // Wait until the opcode/address is transmitted 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents 
....................    while(!PIR1_SSPIF);      // Wait until the register is received 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
....................    */ 
....................  
....................    SPISelectEthernet(); 
*
016C:  BCF    F95.3
016E:  BCF    F8C.3
....................    ENCSPIXfer(RCR | Address); 
0170:  MOVFF  2A9,2AB
0174:  MOVFF  2A9,2B8
0178:  MOVLB  0
017A:  RCALL  0132
....................    c=ENCSPIXfer(0); 
017C:  MOVLB  2
017E:  CLRF   xB8
0180:  MOVLB  0
0182:  RCALL  0132
0184:  MOVFF  01,2AA
....................    SPIUnselectEthernet(); 
0188:  BCF    F95.3
018A:  BSF    F8C.3
....................    return(c); 
018C:  MOVLB  2
018E:  MOVFF  2AA,01
.................... }//end ReadETHReg 
0192:  MOVLB  0
0194:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadMACReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the MAC or MII register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well 
....................  *               as a dummy byte over the SPI and then retrives the 
....................  *               register contents in the last 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access ETH or PHY 
....................  *               registers.  Use ReadETHReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadMACReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    SPISelectEthernet(); 
....................  
....................    SSPBUF = RCR | Address;   // Send the Read Control Register opcode and 
....................                      //   address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send a dummy byte 
....................    while(!PIR1_SSPIF);      // Wait for the dummy byte to be transmitted 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send another dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
.................... */ 
....................    SPISelectEthernet(); 
*
022E:  BCF    F95.3
0230:  BCF    F8C.3
....................  
....................    ENCSPIXfer(RCR | Address); 
0232:  MOVFF  2B0,2B2
0236:  MOVFF  2B0,2B8
023A:  MOVLB  0
023C:  RCALL  0132
....................    ENCSPIXfer(0); 
023E:  MOVLB  2
0240:  CLRF   xB8
0242:  MOVLB  0
0244:  RCALL  0132
....................    c=ENCSPIXfer(0); 
0246:  MOVLB  2
0248:  CLRF   xB8
024A:  MOVLB  0
024C:  RCALL  0132
024E:  MOVFF  01,2B1
....................  
....................    SPIUnselectEthernet(); 
0252:  BCF    F95.3
0254:  BSF    F8C.3
....................  
....................    return(c); 
0256:  MOVLB  2
0258:  MOVFF  2B1,01
.................... }//end ReadMACReg 
025C:  MOVLB  0
025E:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        ReadPHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to read from. 
....................  * 
....................  * Output:          16 bits of data read from the PHY register. 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 2 
....................  * 
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PHYREG ReadPHYReg(BYTE Register) 
.................... { 
....................    PHYREG Result; 
....................  
....................    // Set the right address and start the register read operation 
....................    BankSel(MIREGADR); 
*
02CE:  MOVLW  02
02D0:  MOVLB  2
02D2:  MOVWF  xB1
02D4:  MOVLW  14
02D6:  MOVWF  xB0
02D8:  MOVLB  0
02DA:  RCALL  0204
....................    WriteReg(MIREGADR, Register); 
02DC:  MOVLW  14
02DE:  MOVLB  2
02E0:  MOVWF  xB3
02E2:  MOVFF  2AD,2B4
02E6:  MOVLB  0
02E8:  RCALL  01AA
....................    WriteReg(MICMD, MICMD_MIIRD); 
02EA:  MOVLW  12
02EC:  MOVLB  2
02EE:  MOVWF  xB3
02F0:  MOVLW  01
02F2:  MOVWF  xB4
02F4:  MOVLB  0
02F6:  RCALL  01AA
....................  
....................    // Loop to wait until the PHY register has been read through the MII 
....................    // This requires 10.24us 
....................    BankSel(MISTAT); 
02F8:  MOVLW  03
02FA:  MOVLB  2
02FC:  MOVWF  xB1
02FE:  MOVLW  0A
0300:  MOVWF  xB0
0302:  MOVLB  0
0304:  RCALL  0204
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
0306:  MOVLW  0A
0308:  MOVLB  2
030A:  MOVWF  xB0
030C:  MOVLB  0
030E:  RCALL  022E
0310:  BTFSC  01.0
0312:  BRA    0306
....................  
....................    // Stop reading 
....................    BankSel(MIREGADR); 
0314:  MOVLW  02
0316:  MOVLB  2
0318:  MOVWF  xB1
031A:  MOVLW  14
031C:  MOVWF  xB0
031E:  MOVLB  0
0320:  RCALL  0204
....................    WriteReg(MICMD, 0x00); 
0322:  MOVLW  12
0324:  MOVLB  2
0326:  MOVWF  xB3
0328:  CLRF   xB4
032A:  MOVLB  0
032C:  RCALL  01AA
....................  
....................    // Obtain results and return 
....................    Result.VAL.v[0] = ReadMACReg(MIRDL).Val; 
032E:  MOVLW  18
0330:  MOVLB  2
0332:  MOVWF  xB0
0334:  MOVLB  0
0336:  RCALL  022E
0338:  MOVFF  01,2AE
....................    Result.VAL.v[1] = ReadMACReg(MIRDH).Val; 
033C:  MOVLW  19
033E:  MOVLB  2
0340:  MOVWF  xB0
0342:  MOVLB  0
0344:  RCALL  022E
0346:  MOVFF  01,2AF
....................    return Result; 
034A:  MOVLB  2
034C:  MOVFF  2AE,01
0350:  MOVFF  2AF,02
.................... }//end ReadPHYReg 
0354:  MOVLB  0
0356:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void WriteReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify. 
....................  *                 The top 3 bits must be 0. 
....................  *               Byte to be written into the register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the 
....................  *               SPI and then sends the data to write in the next 8 SPI 
....................  *               clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the BFCReg() and 
....................  *               BFSReg() functions.  It is seperate to maximize speed. 
....................  *               Unlike the ReadETHReg/ReadMACReg functions, WriteReg() 
....................  *               can write to any ETH or MAC register.  Writing to PHY 
....................  *               registers must be accomplished with WritePHYReg(). 
....................  *****************************************************************************/ 
.................... static void WriteReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WCR | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
01AA:  BCF    F95.3
01AC:  BCF    F8C.3
....................    ENCSPIXfer(WCR | Address); 
01AE:  MOVLB  2
01B0:  MOVF   xB3,W
01B2:  IORLW  40
01B4:  MOVWF  xB5
01B6:  MOVWF  xB8
01B8:  MOVLB  0
01BA:  RCALL  0132
....................    ENCSPIXfer(Data); 
01BC:  MOVFF  2B4,2B8
01C0:  RCALL  0132
....................    SPIUnselectEthernet(); 
01C2:  BCF    F95.3
01C4:  BSF    F8C.3
.................... }//end WriteReg 
01C6:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFCReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                 to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Clear operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFSReg() functions.  It is separate to maximize speed. 
....................  *               BFCReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFCReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFC | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
01C8:  BCF    F95.3
01CA:  BCF    F8C.3
....................    ENCSPIXfer(BFC | Address); 
01CC:  MOVLB  2
01CE:  MOVF   xB2,W
01D0:  IORLW  A0
01D2:  MOVWF  xB4
01D4:  MOVWF  xB8
01D6:  MOVLB  0
01D8:  RCALL  0132
....................    ENCSPIXfer(Data); 
01DA:  MOVFF  2B3,2B8
01DE:  RCALL  0132
....................    SPIUnselectEthernet(); 
01E0:  BCF    F95.3
01E2:  BSF    F8C.3
.................... }//end BFCReg 
01E4:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFSReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Set operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFCReg() functions.  It is separate to maximize speed. 
....................  *               BFSReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFSReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFS | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
01E6:  BCF    F95.3
01E8:  BCF    F8C.3
....................    ENCSPIXfer(BFS | Address); 
01EA:  MOVLB  2
01EC:  MOVF   xB5,W
01EE:  IORLW  80
01F0:  MOVWF  xB7
01F2:  MOVWF  xB8
01F4:  MOVLB  0
01F6:  RCALL  0132
....................    ENCSPIXfer(Data); 
01F8:  MOVFF  2B6,2B8
01FC:  RCALL  0132
....................    SPIUnselectEthernet(); 
01FE:  BCF    F95.3
0200:  BSF    F8C.3
.................... }//end BFSReg 
0202:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WritePHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to write to. 
....................  *               16 bits of data to write to PHY register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 3 
....................  * 
....................  * Overview:        WritePHYReg performs an MII write operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void WritePHYReg(BYTE Register, WORD Data) 
.................... { 
....................    // Write the register address 
....................    BankSel(MIREGADR); 
*
0260:  MOVLW  02
0262:  MOVLB  2
0264:  MOVWF  xB1
0266:  MOVLW  14
0268:  MOVWF  xB0
026A:  MOVLB  0
026C:  RCALL  0204
....................    WriteReg(MIREGADR, Register); 
026E:  MOVLW  14
0270:  MOVLB  2
0272:  MOVWF  xB3
0274:  MOVFF  2AD,2B4
0278:  MOVLB  0
027A:  RCALL  01AA
....................  
....................    // Write the data 
....................    // Order is important: write low byte first, high byte last 
....................    WriteReg(MIWRL, ((WORD_VAL*)&Data)->v[0]); 
027C:  MOVLW  02
027E:  MOVWF  FEA
0280:  MOVLW  AE
0282:  MOVWF  FE9
0284:  MOVFF  FEF,2B2
0288:  MOVLW  16
028A:  MOVLB  2
028C:  MOVWF  xB3
028E:  MOVFF  2B2,2B4
0292:  MOVLB  0
0294:  RCALL  01AA
....................    WriteReg(MIWRH, ((WORD_VAL*)&Data)->v[1]); 
0296:  MOVLW  02
0298:  MOVWF  FEA
029A:  MOVLW  AF
029C:  MOVWF  FE9
029E:  MOVFF  FEF,2B2
02A2:  MOVLW  17
02A4:  MOVLB  2
02A6:  MOVWF  xB3
02A8:  MOVFF  2B2,2B4
02AC:  MOVLB  0
02AE:  RCALL  01AA
....................  
....................    // Wait until the PHY register has been written 
....................    BankSel(MISTAT); 
02B0:  MOVLW  03
02B2:  MOVLB  2
02B4:  MOVWF  xB1
02B6:  MOVLW  0A
02B8:  MOVWF  xB0
02BA:  MOVLB  0
02BC:  RCALL  0204
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
02BE:  MOVLW  0A
02C0:  MOVLB  2
02C2:  MOVWF  xB0
02C4:  MOVLB  0
02C6:  RCALL  022E
02C8:  BTFSC  01.0
02CA:  BRA    02BE
.................... }//end WritePHYReg 
02CC:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BankSel 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Register address with the high byte containing the 2 bank 
....................  *                 select 2 bits. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BankSel takes the high byte of a register address and 
....................  *               changes the bank select bits in ETHCON1 to match. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void BankSel(WORD Register) 
.................... { 
....................    BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0); 
*
0204:  MOVLW  1F
0206:  MOVLB  2
0208:  MOVWF  xB2
020A:  MOVLW  03
020C:  MOVWF  xB3
020E:  MOVLB  0
0210:  RCALL  01C8
....................    BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]); 
0212:  MOVLW  02
0214:  MOVWF  FEA
0216:  MOVLW  B1
0218:  MOVWF  FE9
021A:  MOVFF  FEF,2B4
021E:  MOVLW  1F
0220:  MOVLB  2
0222:  MOVWF  xB5
0224:  MOVFF  2B4,2B6
0228:  MOVLB  0
022A:  RCALL  01E6
.................... }//end BankSel 
022C:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static BOOL TestMemory(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if the memory tests have passed 
....................  *               FALSE if the BIST has detected a hardware fault 
....................  * 
....................  * Side Effects:    Alters the state of numerous control registers and all 
....................  *               RAM bytes. 
....................  * 
....................  * Overview:        The internal BIST and DMA modules are used to fill the 
....................  *               entire dual port memory and calculate a checksum of the 
....................  *               data stored within.  Address and Random fill modes are 
....................  *               used. 
....................  * 
....................  * Note:            For the Random Fill mode, the random number generator is 
....................  *               seeded by the contents of the TMR0L PIC SFR.  If the timer 
....................  *               is running, additional confidence that the memory is 
....................  *               working can be obtained by calling TestMemory multiple 
....................  *               times. 
....................  *****************************************************************************/ 
.................... #if defined(MAC_POWER_ON_TEST) 
.................... static BOOL TestMemory(void) 
.................... { 
....................    #define RANDOM_FILL      0b0000 
....................    #define ADDRESS_FILL   0b0100 
....................    #define PATTERN_SHIFT   0b1000 
....................  
....................    WORD_VAL DMAChecksum, BISTChecksum; 
....................  
....................  
....................    // Select Bank 0 and disable anything that could have been in progress 
....................    WriteReg(ECON1, 0x00); 
....................  
....................    // Set up necessary pointers for the DMA to calculate over the entire 
....................    // memory 
....................    WriteReg(EDMASTL, 0x00); 
....................    WriteReg(EDMASTH, 0x00); 
....................    WriteReg(EDMANDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(EDMANDH, HIGH(RAMSIZE-1u)); 
....................    WriteReg(ERXNDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(ERXNDH, HIGH(RAMSIZE-1u)); 
....................  
....................    // Enable Test Mode and do an Address Fill 
....................    BankSel(EBSTCON); 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                    EBSTCON_BISTST | 
....................                    ADDRESS_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode before 
....................    // starting any DMA operations. 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................    // Compare the results 
....................    // 0xF807 should always be generated in Address fill mode 
....................    if( (DMAChecksum.Val != BISTChecksum.Val) || (DMAChecksum.Val != 0xF807) ) 
....................       return FALSE; 
....................  
....................    // Seed the random number generator and begin another Random Fill test 
....................    // with the DMA and BIST memory access ports swapped. 
.................... #ifdef __C30__ 
....................    WriteReg((BYTE)EBSTSD, TMR1); 
.................... #else 
....................    WriteReg((BYTE)EBSTSD, TMR0L); 
.................... #endif 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                  EBSTCON_PSEL | 
....................                  EBSTCON_BISTST | 
....................                  RANDOM_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode since 
....................    // we won't be needing it anymore 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................  
....................    return (DMAChecksum.Val == BISTChecksum.Val); 
.................... }//end TestMemory 
.................... #endif 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetDuplex(DUPLEX DuplexState) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Member of DUPLEX enum: 
....................  *                  FULL: Set full duplex mode 
....................  *                  HALF: Set half duplex mode 
....................  *                  USE_PHY: Set the MAC to match the PHYDPLXMODE bit in 
....................  *                         PHYCON.  This is controlled by LEDB on RESET. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Changes bank bits to Bank 2. 
....................  * 
....................  * Overview:        Disables RX, TX logic, sets MAC up for full duplex 
....................  *               operation, sets PHY up for full duplex operation, and 
....................  *               reenables RX logic.  The back-to-back inter-packet gap 
....................  *               register (MACBBIPG) is updated to maintain a 9.6us gap. 
....................  * 
....................  * Note:            If a packet is being transmitted or received while this 
....................  *               function is called, it will be aborted. 
....................  *****************************************************************************/ 
.................... void MACSetDuplex(DUPLEX DuplexState) 
.................... { 
....................    REG Register; 
....................    PHYREG PhyReg; 
....................  
....................    // Disable receive logic and abort any packets currently being transmitted 
....................    BFCReg(ECON1, ECON1_TXRTS | ECON1_RXEN); 
*
0358:  MOVLW  1F
035A:  MOVLB  2
035C:  MOVWF  xB2
035E:  MOVLW  0C
0360:  MOVWF  xB3
0362:  MOVLB  0
0364:  RCALL  01C8
....................  
....................    // Set the PHY to the proper duplex mode 
....................    PhyReg = ReadPHYReg(PHCON1); 
0366:  MOVLB  2
0368:  CLRF   xAD
036A:  MOVLB  0
036C:  RCALL  02CE
036E:  MOVFF  02,2AC
0372:  MOVFF  01,2AB
....................    if(DuplexState == USE_PHY) 
0376:  MOVLB  2
0378:  MOVF   xA9,W
037A:  SUBLW  02
037C:  BNZ   0386
....................    { 
....................       DuplexState = PhyReg.PHCON1bits.PDPXMD; 
037E:  CLRF   xA9
0380:  BTFSC  xAC.0
0382:  INCF   xA9,F
....................    } 
....................    else 
0384:  BRA    039C
....................    { 
....................       PhyReg.PHCON1bits.PDPXMD = DuplexState; 
0386:  BCF    xAC.0
0388:  BTFSC  xA9.0
038A:  BSF    xAC.0
....................       WritePHYReg(PHCON1, PhyReg.Val); 
038C:  CLRF   xAD
038E:  MOVFF  2AC,2AF
0392:  MOVFF  2AB,2AE
0396:  MOVLB  0
0398:  RCALL  0260
039A:  MOVLB  2
....................    } 
....................  
....................    // Set the MAC to the proper duplex mode 
....................    BankSel(MACON3); 
039C:  MOVLW  02
039E:  MOVWF  xB1
03A0:  MOVWF  xB0
03A2:  MOVLB  0
03A4:  RCALL  0204
....................    Register = ReadMACReg(MACON3); 
03A6:  MOVLW  02
03A8:  MOVLB  2
03AA:  MOVWF  xB0
03AC:  MOVLB  0
03AE:  RCALL  022E
03B0:  MOVFF  01,2AA
....................    Register.MACON3bits.FULDPX = DuplexState; 
03B4:  MOVLB  2
03B6:  BCF    xAA.0
03B8:  BTFSC  xA9.0
03BA:  BSF    xAA.0
....................    WriteReg(MACON3, Register.Val); 
03BC:  MOVLW  02
03BE:  MOVWF  xB3
03C0:  MOVFF  2AA,2B4
03C4:  MOVLB  0
03C6:  RCALL  01AA
....................  
....................    // Set the back-to-back inter-packet gap time to IEEE specified 
....................    // requirements.  The meaning of the MABBIPG value changes with the duplex 
....................    // state, so it must be updated in this function. 
....................    // In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex 
....................    WriteReg(MABBIPG, DuplexState ? 0x15 : 0x12); 
03C8:  MOVLB  2
03CA:  MOVF   xA9,F
03CC:  BZ    03D2
03CE:  MOVLW  15
03D0:  BRA    03D4
03D2:  MOVLW  12
03D4:  MOVWF  xAD
03D6:  MOVLW  04
03D8:  MOVWF  xB3
03DA:  MOVFF  2AD,2B4
03DE:  MOVLB  0
03E0:  RCALL  01AA
....................  
....................    // Reenable receive logic 
....................    BFSReg(ECON1, ECON1_RXEN); 
03E2:  MOVLW  1F
03E4:  MOVLB  2
03E6:  MOVWF  xB5
03E8:  MOVLW  04
03EA:  MOVWF  xB6
03EC:  MOVLB  0
03EE:  RCALL  01E6
.................... }//end MACSetDuplex 
03F0:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerDown(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In 
....................  *               sleep mode, no packets can be transmitted or received. 
....................  *               All MAC and PHY registers should not be accessed. 
....................  * 
....................  * Note:            If a packet is being transmitted while this function is 
....................  *                called, this function will block until it is it complete. 
....................  *               If anything is being received, it will be completed. 
....................  *****************************************************************************/ 
.................... void MACPowerDown(void) 
.................... { 
....................    // Disable packet reception 
....................    BFCReg(ECON1, ECON1_RXEN); 
....................  
....................    // Make sure any last packet which was in-progress when RXEN was cleared 
....................    // is completed 
....................    while(ReadETHReg(ESTAT).ESTATbits.RXBUSY); 
....................  
....................    // If a packet is being transmitted, wait for it to finish 
....................    while(ReadETHReg(ECON1).ECON1bits.TXRTS); 
....................  
....................    // Enter sleep mode 
....................    BFSReg(ECON2, ECON2_PWRSV); 
.................... }//end MACPowerDown 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerUp(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation 
....................  *               after a previous call to MACPowerDown().  Calling this 
....................  *               function when already powered up will have no effect. 
....................  * 
....................  * Note:            The first packet transmitted may get lost at the RX end if 
....................  *               you don't wait for the link to go up first.  MACIsLinked() 
....................  *               can be called to determine if a link is established. 
....................  *****************************************************************************/ 
.................... void MACPowerUp(void) 
.................... { 
....................    // Leave power down mode 
....................    BFCReg(ECON2, ECON2_PWRSV); 
....................  
....................    // Wait for the 300us Oscillator Startup Timer (OST) to time out.  This 
....................    // delay is required for the PHY module to return to an operational state. 
....................    while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY); 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
.................... }//end MACPowerUp 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetCLKOUT(BYTE NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low) 
....................  *                        0x01: Divide by 1 (25 MHz) 
....................  *                        0x02: Divide by 2 (12.5 MHz) 
....................  *                        0x03: Divide by 3 (8.333333 MHz) 
....................  *                        0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                        0x05: Divide by 8 (3.125 MHz) 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the ECOCON register. 
....................  *               The CLKOUT pin will beginning outputting the new frequency 
....................  *               immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... void SetCLKOUT(BYTE NewConfig) 
.................... { 
....................    BankSel(ECOCON); 
....................    WriteReg(ECOCON, NewConfig); 
.................... }//end SetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE GetCLKOUT(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low) 
....................  *                     0x01: Divide by 1 (25 MHz) 
....................  *                     0x02: Divide by 2 (12.5 MHz) 
....................  *                     0x03: Divide by 3 (8.333333 MHz) 
....................  *                     0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                     0x05: Divide by 8 (3.125 MHz) 
....................  *                     0x06: Reserved 
....................  *                     0x07: Reserved 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the ECOCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE GetCLKOUT(void) 
.................... { 
....................    BankSel(ECOCON); 
....................    return ReadETHReg(ECOCON).Val; 
.................... }//end GetCLKOUT 
....................  
.................... #else 
.................... #include "tcpip/rtl8019AS.c" 
.................... #endif 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
.................... #include "tcpip/modem.c" 
.................... #include "tcpip/ppp.c" 
.................... #include "tcpip/pppwrap.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SLIP 
.................... #include "tcpip/slip.c" 
.................... #ENDIF 
....................  
.................... #if STACK_USE_UDP 
.................... #include "tcpip/udp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #include "tcpip/dhcp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
.................... #include "tcpip/smtp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
.................... #include "tcpip/http.h" 
.................... #endif 
....................  
.................... #if STACK_USE_FAT 
.................... #include "fat/fat_pic.c" 
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
.................... #include "mpfs/mpfs.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
.................... #include "tcpip/http2.h" 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
.................... #include "tcpip/ftp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
.................... #include "tcpip/tftp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
.................... #include "tcpip/dns.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
.................... #include "tcpip/snmp.h" 
.................... #endif 
....................  
.................... /* 
....................  #if STACK_USE_MPFS 
....................  #include "tcpip/mpfs.h" 
....................  #endif 
....................  */ 
....................  
.................... #include "tcpip/ip.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC IP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.C 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail) 
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... // This is left shifted by 4.  Actual value is 0x04. 
.................... #define IPv4                (0x40u) 
.................... #define IP_VERSION          IPv4 
....................  
.................... #define debug_ip 
.................... //#define debug_ip  debug_printf 
....................  
.................... // IHL (Internet Header Length) is # of DWORDs in a header. 
.................... // Since, we do not support options, our IP header length will be 
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5. 
.................... #define IP_IHL              (0x05) 
....................  
.................... #define IP_SERVICE_NW_CTRL  (0x07) 
.................... #define IP_SERVICE_IN_CTRL  (0x06) 
.................... #define IP_SERVICE_ECP      (0x05) 
.................... #define IP_SERVICE_OVR      (0x04) 
.................... #define IP_SERVICE_FLASH    (0x03) 
.................... #define IP_SERVICE_IMM      (0x02) 
.................... #define IP_SERVICE_PRIOR    (0x01) 
.................... #define IP_SERVICE_ROUTINE  (0x00) 
....................  
.................... #define IP_SERVICE_N_DELAY  (0x00) 
.................... #define IP_SERCICE_L_DELAY  (0x08) 
.................... #define IP_SERVICE_N_THRPT  (0x00) 
.................... #define IP_SERVICE_H_THRPT  (0x10) 
.................... #define IP_SERVICE_N_RELIB  (0x00) 
.................... #define IP_SERVICE_H_RELIB  (0x20) 
....................  
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY) 
....................  
.................... #define MY_IP_TTL           (100)   // Time-To-Live in Seconds 
....................  
....................  
....................  
....................  
.................... static WORD _Identifier = 0; 
.................... static BYTE IPHeaderLen; 
....................  
.................... static void SwapIPHeader(IP_HEADER* h); 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len) 
.................... { 
....................     WORD_VAL    CalcChecksum; 
....................     IP_HEADER   header; 
....................  
.................... #if !defined(MCHP_MAC) 
....................     WORD_VAL    ReceivedChecksum; 
....................     WORD        checksums[2]; 
....................     BYTE        optionsLen; 
.................... #define MAX_OPTIONS_LEN     (40)            // As per RFC 791. 
....................     BYTE        options[MAX_OPTIONS_LEN]; 
.................... #endif 
....................  
....................     // Read IP header. 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
*
1FB2:  MOVLW  01
1FB4:  MOVLB  2
1FB6:  MOVWF  x13
1FB8:  MOVLW  FE
1FBA:  MOVFF  213,289
1FBE:  MOVWF  x88
1FC0:  CLRF   x8B
1FC2:  MOVLW  14
1FC4:  MOVWF  x8A
1FC6:  MOVLB  0
1FC8:  CALL   1110
....................  
....................     // Make sure that this is an IPv4 packet. 
....................     if ( (header.VersionIHL & 0xf0) != IP_VERSION ) 
1FCC:  MOVLB  1
1FCE:  MOVF   xFE,W
1FD0:  ANDLW  F0
1FD2:  SUBLW  40
1FD4:  BZ    1FDC
....................     	return FALSE; 
1FD6:  MOVLW  00
1FD8:  MOVWF  01
1FDA:  BRA    2098
....................  
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2; 
1FDC:  MOVF   xFE,W
1FDE:  ANDLW  0F
1FE0:  MOVWF  00
1FE2:  RLCF   00,W
1FE4:  MOVLB  0
1FE6:  MOVWF  x87
1FE8:  RLCF   x87,F
1FEA:  MOVLW  FC
1FEC:  ANDWF  x87,F
....................  
.................... #if defined(MCHP_MAC) 
.................... 	// Validate the IP header.  If it is correct, the checksum 
.................... 	// will come out to 0x0000 (because the header contains a 
.................... 	// precomputed checksum).  A corrupt header will have a 
.................... 	// nonzero checksum. 
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen); 
1FEE:  MOVLB  2
1FF0:  CLRF   x4E
1FF2:  CLRF   x4D
1FF4:  CLRF   x50
1FF6:  MOVFF  87,24F
1FFA:  MOVLB  0
1FFC:  RCALL  1CAE
1FFE:  MOVFF  02,1FD
2002:  MOVFF  01,1FC
....................  
.................... 	// Seek to the end of the IP header 
.................... 	MACSetRxBuffer(IPHeaderLen); 
2006:  MOVLB  2
2008:  CLRF   x26
200A:  MOVFF  87,225
200E:  MOVLB  0
2010:  RCALL  1E16
....................  
....................     if(CalcChecksum.Val) 
2012:  MOVLB  1
2014:  MOVF   xFC,W
2016:  IORWF  xFD,W
2018:  BZ    2020
.................... #else 
....................  
....................     // Calculate options length in this header, if there is any. 
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual 
....................     // length is 4 times IHL. 
....................     optionsLen = ((header.VersionIHL & 0x0f) << 2) - sizeof(header); 
....................  
....................     // If there is any option(s), read it so that we can include them 
....................     // in checksum calculation. 
....................     if ( optionsLen > MAX_OPTIONS_LEN ) 
....................         return FALSE; 
....................  
....................     if ( optionsLen > 0 ) 
....................         MACGetArray(options, optionsLen); 
....................  
....................     // Save header checksum; clear it and recalculate it ourselves. 
....................     ReceivedChecksum.Val = header.HeaderChecksum; 
....................     header.HeaderChecksum = 0; 
....................  
....................     // Calculate checksum of header including options bytes. 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header)); 
....................  
....................     // Calculate Options checksum too, if they are present. 
....................     if ( optionsLen > 0 ) 
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen); 
....................     else 
....................         checksums[1] = 0; 
....................  
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums, 
....................                                             2 * sizeof(WORD)); 
....................  
....................     // Make sure that checksum is correct 
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val ) 
.................... #endif 
....................     { 
....................         // Bad packet. The function caller will be notified by means of the FALSE 
....................         // return value and it should discard the packet. 
....................         return FALSE; 
201A:  MOVLW  00
201C:  MOVWF  01
201E:  BRA    2098
....................     } 
....................  
....................     // Network to host conversion. 
....................     SwapIPHeader(&header); 
2020:  MOVLW  01
2022:  MOVLB  2
2024:  MOVWF  x94
2026:  MOVLW  FE
2028:  MOVWF  x93
202A:  MOVLB  0
202C:  RCALL  1ED2
....................  
....................     // If caller is intrested, return destination IP address 
....................     // as seen in this IP header. 
....................     if ( localIP ) 
202E:  MOVLB  1
2030:  MOVF   xF4,W
2032:  IORWF  xF5,W
2034:  BZ    204E
....................         localIP->Val    = header.DestAddress.Val; 
2036:  MOVFF  1F4,FE9
203A:  MOVFF  1F5,FEA
203E:  MOVFF  20E,FEF
2042:  MOVFF  20F,FEC
2046:  MOVFF  210,FEC
204A:  MOVFF  211,FEC
....................  
....................     remote->IPAddr.Val  = header.SourceAddress.Val; 
204E:  MOVLW  06
2050:  ADDWF  xF6,W
2052:  MOVWF  FE9
2054:  MOVLW  00
2056:  ADDWFC xF7,W
2058:  MOVWF  FEA
205A:  MOVFF  20A,FEF
205E:  MOVFF  20B,FEC
2062:  MOVFF  20C,FEC
2066:  MOVFF  20D,FEC
....................     *protocol           = header.Protocol; 
206A:  MOVFF  1F8,FE9
206E:  MOVFF  1F9,FEA
2072:  MOVFF  207,FEF
.................... #if defined(MCHP_MAC) 
....................     *len 				= header.TotalLength - IPHeaderLen; 
2076:  MOVFF  1FA,FE9
207A:  MOVFF  1FB,FEA
207E:  MOVLB  0
2080:  MOVF   x87,W
2082:  MOVLB  2
2084:  SUBWF  x00,W
2086:  MOVWF  00
2088:  MOVLW  00
208A:  SUBWFB x01,W
208C:  MOVFF  00,FEF
2090:  MOVWF  FEC
.................... #else 
....................     *len                = header.TotalLength - optionsLen - 
....................                             sizeof(header); 
.................... #endif 
....................  
....................     return TRUE; 
2092:  MOVLW  01
2094:  MOVWF  01
2096:  MOVLB  1
.................... } 
2098:  MOVLB  0
209A:  GOTO   4450 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function: WORD IPPutHeader(NODE_INFO *remote, 
....................  *           				  BYTE protocol, 
....................  *                			  WORD len) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           *remote     - Destination node address 
....................  *                  protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          (WORD)0 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  ********************************************************************/ 
.................... WORD IPPutHeader(NODE_INFO *remote, 
....................                 BYTE protocol, 
....................                 WORD    len) 
.................... { 
....................     IP_HEADER   header; 
....................  
....................     IPHeaderLen = sizeof(IP_HEADER); 
*
2BEC:  MOVLW  14
2BEE:  MOVWF  x87
....................  
....................     header.VersionIHL       = IP_VERSION | IP_IHL; 
2BF0:  MOVLW  45
2BF2:  MOVLB  2
2BF4:  MOVWF  x7F
....................     header.TypeOfService    = IP_SERVICE; 
2BF6:  CLRF   x80
....................     header.TotalLength      = sizeof(header) + len; 
2BF8:  MOVLW  14
2BFA:  ADDWF  x7D,W
2BFC:  MOVWF  x81
2BFE:  MOVLW  00
2C00:  ADDWFC x7E,W
2C02:  MOVWF  x82
....................     header.Identification   = ++_Identifier; 
2C04:  MOVLB  0
2C06:  INCF   x85,F
2C08:  BTFSC  FD8.2
2C0A:  INCF   x86,F
2C0C:  MOVFF  86,284
2C10:  MOVFF  85,283
....................     header.FragmentInfo     = 0; 
2C14:  MOVLB  2
2C16:  CLRF   x86
2C18:  CLRF   x85
....................     header.TimeToLive       = MY_IP_TTL; 
2C1A:  MOVLW  64
2C1C:  MOVWF  x87
....................     header.Protocol         = protocol; 
2C1E:  MOVFF  27C,288
....................     header.HeaderChecksum   = 0; 
2C22:  CLRF   x8A
2C24:  CLRF   x89
.................... 	header.SourceAddress = AppConfig.MyIPAddr; 
2C26:  MOVFF  46,28E
2C2A:  MOVFF  45,28D
2C2E:  MOVFF  44,28C
2C32:  MOVFF  43,28B
....................  
....................     header.DestAddress.Val = remote->IPAddr.Val; 
2C36:  MOVLW  06
2C38:  ADDWF  x7A,W
2C3A:  MOVWF  FE9
2C3C:  MOVLW  00
2C3E:  ADDWFC x7B,W
2C40:  MOVWF  FEA
2C42:  MOVFF  FEF,00
2C46:  MOVFF  FEC,01
2C4A:  MOVFF  FEC,02
2C4E:  MOVFF  FEC,03
2C52:  MOVFF  03,292
2C56:  MOVFF  02,291
2C5A:  MOVFF  01,290
2C5E:  MOVFF  00,28F
....................  
....................     SwapIPHeader(&header); 
2C62:  MOVLW  02
2C64:  MOVWF  x94
2C66:  MOVLW  7F
2C68:  MOVWF  x93
2C6A:  MOVLB  0
2C6C:  CALL   1ED2
....................  
.................... #if !defined(MCHP_MAC) 
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, 
....................                                                 sizeof(header)); 
.................... #endif 
....................  
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len)); 
2C70:  MOVLB  2
2C72:  MOVFF  27A,01
2C76:  MOVFF  27B,03
2C7A:  MOVFF  27A,293
2C7E:  MOVFF  27B,294
2C82:  MOVLW  14
2C84:  ADDWF  x7D,W
2C86:  MOVWF  x95
2C88:  MOVLW  00
2C8A:  ADDWFC x7E,W
2C8C:  MOVWF  x96
2C8E:  MOVFF  27B,298
2C92:  MOVFF  27A,297
2C96:  CLRF   x99
2C98:  MOVWF  x9B
2C9A:  MOVFF  295,29A
2C9E:  MOVLB  0
2CA0:  CALL   165E
....................     MACPutArray((BYTE*)&header, sizeof(header)); 
2CA4:  MOVLW  02
2CA6:  MOVLB  2
2CA8:  MOVWF  x94
2CAA:  MOVLW  7F
2CAC:  MOVFF  294,29F
2CB0:  MOVWF  x9E
2CB2:  CLRF   xA1
2CB4:  MOVLW  14
2CB6:  MOVWF  xA0
2CB8:  MOVLB  0
2CBA:  CALL   15F8
....................  
.................... #if defined(MCHP_MAC) 
.................... 	header.HeaderChecksum = MACCalcTxChecksum(0, sizeof(header)); 
2CBE:  MOVLB  2
2CC0:  CLRF   x94
2CC2:  CLRF   x93
2CC4:  CLRF   x96
2CC6:  MOVLW  14
2CC8:  MOVWF  x95
2CCA:  MOVLB  0
2CCC:  RCALL  2AB8
2CCE:  MOVFF  02,28A
2CD2:  MOVFF  01,289
.................... 	MACSetTxBuffer(CurrentTxBuffer, 10);	// 10 is the offset in header to the HeaderChecksum member 
2CD6:  MOVFF  7A,293
2CDA:  MOVLB  2
2CDC:  CLRF   x95
2CDE:  MOVLW  0A
2CE0:  MOVWF  x94
2CE2:  MOVLB  0
2CE4:  CALL   14FC
.................... 	MACPutArray((BYTE*)&header.HeaderChecksum, 2); 
2CE8:  MOVLW  02
2CEA:  MOVLB  2
2CEC:  MOVWF  x94
2CEE:  MOVLW  89
2CF0:  MOVFF  294,29F
2CF4:  MOVWF  x9E
2CF6:  CLRF   xA1
2CF8:  MOVLW  02
2CFA:  MOVWF  xA0
2CFC:  MOVLB  0
2CFE:  CALL   15F8
.................... 	MACSetTxBuffer(CurrentTxBuffer, sizeof(header));	// Seek back to the end of the packet 
2D02:  MOVFF  7A,293
2D06:  MOVLB  2
2D08:  CLRF   x95
2D0A:  MOVLW  14
2D0C:  MOVWF  x94
2D0E:  MOVLB  0
2D10:  CALL   14FC
.................... #endif 
....................  
....................     return 0x0; 
2D14:  MOVLW  00
2D16:  MOVWF  01
2D18:  MOVWF  02
.................... } 
2D1A:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset) 
.................... { 
.................... 	MACSetRxBuffer(Offset+IPHeaderLen); 
*
23A4:  MOVF   x87,W
23A6:  MOVLB  2
23A8:  ADDWF  x21,W
23AA:  MOVWF  x23
23AC:  MOVLW  00
23AE:  ADDWFC x22,W
23B0:  MOVWF  x24
23B2:  MOVWF  x26
23B4:  MOVFF  223,225
23B8:  MOVLB  0
23BA:  RCALL  1E16
.................... } 
23BC:  RETLW  00
....................  
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h) 
.................... { 
....................     h->TotalLength      = swaps(h->TotalLength); 
*
1ED2:  MOVLW  02
1ED4:  MOVLB  2
1ED6:  ADDWF  x93,W
1ED8:  MOVWF  01
1EDA:  MOVLW  00
1EDC:  ADDWFC x94,W
1EDE:  MOVWF  03
1EE0:  MOVFF  01,295
1EE4:  MOVWF  x96
1EE6:  MOVLW  02
1EE8:  ADDWF  x93,W
1EEA:  MOVWF  FE9
1EEC:  MOVLW  00
1EEE:  ADDWFC x94,W
1EF0:  MOVWF  FEA
1EF2:  MOVFF  FEC,298
1EF6:  MOVF   FED,F
1EF8:  MOVFF  FEF,297
1EFC:  MOVFF  298,29A
1F00:  MOVFF  297,299
1F04:  MOVLB  0
1F06:  CALL   118C
1F0A:  MOVFF  296,FEA
1F0E:  MOVFF  295,FE9
1F12:  MOVFF  02,FEC
1F16:  MOVF   FED,F
1F18:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification); 
1F1C:  MOVLW  04
1F1E:  MOVLB  2
1F20:  ADDWF  x93,W
1F22:  MOVWF  01
1F24:  MOVLW  00
1F26:  ADDWFC x94,W
1F28:  MOVWF  03
1F2A:  MOVFF  01,295
1F2E:  MOVWF  x96
1F30:  MOVLW  04
1F32:  ADDWF  x93,W
1F34:  MOVWF  FE9
1F36:  MOVLW  00
1F38:  ADDWFC x94,W
1F3A:  MOVWF  FEA
1F3C:  MOVFF  FEC,298
1F40:  MOVF   FED,F
1F42:  MOVFF  FEF,297
1F46:  MOVFF  298,29A
1F4A:  MOVFF  297,299
1F4E:  MOVLB  0
1F50:  CALL   118C
1F54:  MOVFF  296,FEA
1F58:  MOVFF  295,FE9
1F5C:  MOVFF  02,FEC
1F60:  MOVF   FED,F
1F62:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum); 
1F66:  MOVLW  0A
1F68:  MOVLB  2
1F6A:  ADDWF  x93,W
1F6C:  MOVWF  01
1F6E:  MOVLW  00
1F70:  ADDWFC x94,W
1F72:  MOVWF  03
1F74:  MOVFF  01,295
1F78:  MOVWF  x96
1F7A:  MOVLW  0A
1F7C:  ADDWF  x93,W
1F7E:  MOVWF  FE9
1F80:  MOVLW  00
1F82:  ADDWFC x94,W
1F84:  MOVWF  FEA
1F86:  MOVFF  FEC,298
1F8A:  MOVF   FED,F
1F8C:  MOVFF  FEF,297
1F90:  MOVFF  298,29A
1F94:  MOVFF  297,299
1F98:  MOVLB  0
1F9A:  CALL   118C
1F9E:  MOVFF  296,FEA
1FA2:  MOVFF  295,FE9
1FA6:  MOVFF  02,FEC
1FAA:  MOVF   FED,F
1FAC:  MOVFF  01,FEF
.................... } 
1FB0:  RETLW  00
....................  
....................  
.................... #if STACK_USE_TCP 
.................... #include "tcpip/tcp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module for Microchip TCP/IP Stack 
....................  *               Based on RFC 793 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.C 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  *                  ARP.h 
....................  *                  Tick.h 
....................  *                  TCP.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        CCS PCH 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     11/1/02 Fixed TCPTick() SYN Retry bug. 
....................  * Darren Rook (CCS)    06/28/04  Applied 2.20 fix (above) 
....................  * Darren Rook (CCS)    06/30/04 TCPTick() will not time out an establisehd socket if that socket is in server mode. 
....................  * Darren Rook (CCS)    07/02/04 A bug fix for change made on 06/28/04 
....................  * Darren Rook (CCS)    07/12/04 TCPConnect() will set StartTick to fix a bug with timeout 
....................  * Darren Rook (CCS)    07/12/04 TCPInit() attempts to make _NextPort a random number 
....................  * Darren Rook (CCS)    07/12/06 startTick spelled wrong (case) 
....................  * Nilesh Rajbharti     12/5/02   Modified TCPProcess() 
....................  *                              to include localIP as third param. 
....................  *                              This was done to allow this function 
....................  *                              to calculate checksum correctly. 
....................  * Roy Schofield      10/1/04   TCPConnect() startTick bug fix. 
....................  * Howard Schlunder      1/3/05   Fixed HandleTCPSeg() unexpected 
....................  *                         discard problem identified by Richard 
....................  *                         Shelquist. 
....................  * Howard Schlunder      1/16/06   Fixed an imporbable RX checksum bug 
....................  *                        when using a Microchip Ethernet controller) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    09/18/06 Added TCPPutAvailable() 
....................  * Howard Schlunder      5/10/06   Revised TCP state machine, add TCP_FIN_2 
....................  * Howard Schlunder      8/01/06 Adjusted response to ACK only in TCP_SYN_SENT state 
....................  * Howard Schlunder      8/03/06 Fixed checksum comparison check 
....................  *                        reported by DouglasPunch on Microchip Forum. 
....................  * Howard Schlunder      8/11/06 Fixed a resource leak causing MAC TX 
....................  *                        Buffers to be obtained but not 
....................  *                        released when many web requests were 
....................  *                        received concurrently. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.75 stack 
....................  * Darren Rook (CCS)   01/03/07 Fixed a bug in TCPPutArray() 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               12 // 10 original value (MiE) 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tcp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        CCS PCH 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip")  
....................  * and is supplied to you for use exclusively as described in the  
....................  * associated software agreement.  This software is protected by  
....................  * software and other intellectual property laws.  Any use in  
....................  * violation of the software license may subject the user to criminal  
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL  
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED  
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND  
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,  
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     12/5/03 Modified TCPProcess() prototype. 
....................  *                              See TCP.c for more information. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef TCP_H 
.................... #define TCP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               12 // 10 original value (MiE) 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... typedef BYTE TCP_SOCKET; 
.................... typedef WORD TCP_PORT; 
....................  
.................... #ifndef TCP_NO_WAIT_FOR_ACK 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * Maximum number of times a connection be retried before 
....................  * closing it down. 
....................  */ 
.................... #define MAX_RETRY_COUNTS    (3) 
....................  
.................... #define INVALID_SOCKET      (0xfe) 
.................... #define UNKNOWN_SOCKET      (0xff) 
....................  
.................... #define REMOTE_HOST(s)      (TCB[s].remote) 
....................  
.................... /* 
....................  * TCP States as defined by rfc793 
....................  */ 
.................... typedef enum _TCP_STATE 
.................... { 
....................     TCP_LISTEN = 0, 
....................     TCP_SYN_SENT, 
....................     TCP_SYN_RECEIVED, 
....................     TCP_ESTABLISHED, 
....................     TCP_FIN_WAIT_1, 
....................     TCP_FIN_WAIT_2, 
....................     TCP_CLOSING, 
....................     TCP_TIME_WAIT, 
....................    TCP_CLOSE_WAIT, 
....................     TCP_LAST_ACK, 
....................     TCP_CLOSED, 
.................... } TCP_STATE; 
....................  
.................... /* 
....................  * Socket info. 
....................  * Union is used to create anonymous structure members. 
....................  */ 
.................... typedef struct _SOCKET_INFO 
.................... { 
....................     TCP_STATE smState; 
....................  
....................     NODE_INFO remote; 
....................     TCP_PORT localPort; 
....................     TCP_PORT remotePort; 
....................  
....................     BUFFER TxBuffer; 
....................     WORD TxCount; 
....................     WORD RxCount; 
....................    WORD RemoteWindow; 
....................     
....................     DWORD SND_SEQ; 
....................     DWORD SND_ACK; 
....................  
....................     BYTE RetryCount; 
....................     TICKTYPE startTick; 
....................     TICKTYPE TimeOut; 
....................  
....................     struct 
....................     { 
....................         int1 bServer        : 1; 
....................         int1 bIsPutReady    : 1; 
....................         int1 bFirstRead     : 1; 
....................         int1 bIsGetReady    : 1; 
....................         int1 bIsTxInProgress : 1; 
....................         int1 bACKValid : 1; 
....................     } Flags; 
....................  
.................... } SOCKET_INFO; 
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TCP is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initialize all socket info. 
....................  * 
....................  * Note:            This function is called only one during lifetime 
....................  *                  of the application. 
....................  ********************************************************************/ 
.................... void        TCPInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           port    - A TCP port to be opened. 
....................  * 
....................  * Output:          Given port is opened and returned on success 
....................  *                  INVALID_SOCKET if no more sockets left. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TCP_SOCKET  TCPListen(TCP_PORT port); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
....................  *                                      TCP_PORT remotePort) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           remote      - Remote node address info 
....................  *                  remotePort  - remote port to be connected. 
....................  * 
....................  * Output:          A new socket is created, connection request is 
....................  *                  sent and socket handle is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT port); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsConnected(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPDisconnect(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsPutReady(s) == TRUE 
....................  * 
....................  * Input:           s       - Socket to be disconnected. 
....................  * 
....................  * Output:          A disconnect request is sent for given socket. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPDisconnect(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsPutReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s       - socket to use 
....................  *                  byte    - a data byte to send 
....................  * 
....................  * Output:          TRUE if given byte was put in transmit buffer 
....................  *                  FALSE if transmit buffer is full. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPPut(TCP_SOCKET socket, BYTE data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPFlush(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket whose data is to be transmitted. 
....................  * 
....................  * Output:          All and any data associated with this socket 
....................  *                  is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPFlush(TCP_SOCKET socket); 
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPIsGetReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPGet(TCP_SOCKET socket, int8 *data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD        TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPDiscard(TCP_SOCKET socket); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPProcess(NODE_INFO* remote, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  len         - Total length of TCP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPProcess(NODE_INFO *remote, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPTick(void) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Each socket FSM is executed for any timeout 
....................  *                  situation. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPTick(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define debug_tcp(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
.................... //#define debug_tcp debug_printf 
....................  
.................... // Max TCP data length is MAC_TX_BUFFER_SIZE - sizeof(TCP_HEADER) - 
.................... // sizeof(IP_HEADER) - sizeof(ETHER_HEADER) 
.................... #define MAX_TCP_DATA_LEN    (MAC_TX_BUFFER_SIZE - 54) 
....................  
.................... // TCP Timeout value to begin with. 
.................... #define TCP_START_TIMEOUT_VAL   (TICKS_PER_SECOND * (TICKTYPE)3) 
....................  
.................... // TCP Flags defined in RFC 
.................... #define FIN     (0x01) 
.................... #define SYN     (0x02) 
.................... #define RST     (0x04) 
.................... #define PSH     (0x08) 
.................... #define ACK     (0x10) 
.................... #define URG     (0x20) 
....................  
.................... // TCP Header 
.................... typedef struct _TCP_HEADER { 
....................    WORD SourcePort; 
....................    WORD DestPort; 
....................    DWORD SeqNumber; 
....................    DWORD AckNumber; 
....................  
....................    struct { 
....................       BYTE Reserved3 :4; 
....................       BYTE Val :4; 
....................    } DataOffset; 
....................  
....................    union { 
....................       struct { 
....................          int1 flagFIN :1; 
....................          int1 flagSYN :1; 
....................          int1 flagRST :1; 
....................          int1 flagPSH :1; 
....................          int1 flagACK :1; 
....................          int1 flagURG :1; 
....................          int1 Reserved2 :2; 
....................       } bits; 
....................       BYTE b; 
....................    } Flags; 
....................  
....................    WORD Window; 
....................    WORD Checksum; 
....................    WORD UrgentPointer; 
.................... } TCP_HEADER; 
....................  
.................... // TCP Options as defined by RFC 
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00) 
.................... #define TCP_OPTIONS_NO_OP           (0x01) 
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02) 
.................... typedef struct _TCP_OPTIONS { 
....................    BYTE Kind; 
....................    BYTE Length; 
....................    WORD_VAL MaxSegSize; 
.................... } TCP_OPTIONS; 
....................  
.................... #define SwapPseudoTCPHeader(h)  (h.TCPLength = swaps(h.TCPLength)) 
....................  
.................... // IP pseudo header as defined by RFC 793 
.................... typedef struct _PSEUDO_HEADER { 
....................    IP_ADDR SourceAddress; 
....................    IP_ADDR DestAddress; 
....................    BYTE Zero; 
....................    BYTE Protocol; 
....................    WORD TCPLength; 
.................... } PSEUDO_HEADER; 
....................  
.................... #define LOCAL_PORT_START_NUMBER (1024) 
.................... #define LOCAL_PORT_END_NUMBER   (5000) 
....................  
.................... // Local temp port numbers. 
.................... static WORD _NextPort = LOCAL_PORT_START_NUMBER; 
....................  
.................... // The TCB array is very large.  With the C18 compiler, one must 
.................... // modify the linker script to make an array that spans more than 
.................... // one memory bank.  To do this, make the necessary changes to your 
.................... // processor's linker script (.lkr).  Here is an example showing 
.................... // gpr11 and 128 bytes of gpr12 being combined into one 384 byte 
.................... // block used exclusively by the TCB_MEM data section: 
.................... // ... 
.................... // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF 
.................... // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF 
.................... // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED 
.................... // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF 
.................... // ... 
.................... // SECTION    NAME=TCB_MEM    RAM=gpr11b 
.................... // ... 
.................... //#pragma udata TCB_MEM   //not needed in ccs 
.................... SOCKET_INFO TCB[MAX_SOCKETS]; 
.................... //   #pragma udata bla   // Return to any other RAM section   //not needed in ccs 
....................  
.................... static void HandleTCPSeg(TCP_SOCKET s, NODE_INFO *remote, TCP_HEADER *h, 
....................       WORD len); 
....................  
.................... static void TransmitTCP(NODE_INFO *remote, TCP_PORT localPort, 
....................       TCP_PORT remotePort, DWORD tseq, DWORD tack, BYTE flags, BUFFER buff, 
....................       WORD len); 
....................  
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, NODE_INFO *remote); 
.................... static void SwapTCPHeader(TCP_HEADER* header); 
.................... static void CloseSocket(SOCKET_INFO* ps); 
....................  
.................... #define SendTCP(remote, localPort, remotePort, seq, ack, flags)     \ 
....................         TransmitTCP(remote, localPort, remotePort, seq, ack, flags, \ 
....................                     INVALID_BUFFER, 0) 
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TCP is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initialize all socket states 
....................  * 
....................  * Note:            This function is called only once during lifetime 
....................  *                  of the application. 
....................  ********************************************************************/ 
.................... int16 TCPInit_RandSeed; 
.................... void TCPInit(void) { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................  
....................    // Initialize all sockets. 
....................    for (s = 0; s < MAX_SOCKETS; s++) { 
*
0712:  MOVLB  2
0714:  CLRF   xA8
0716:  MOVF   xA8,W
0718:  SUBLW  04
071A:  BNC   07EC
....................       ps = &TCB[s]; 
071C:  MOVF   xA8,W
071E:  MULLW  24
0720:  MOVF   FF3,W
0722:  CLRF   03
0724:  ADDLW  8A
0726:  MOVWF  01
0728:  MOVLW  00
072A:  ADDWFC 03,F
072C:  MOVFF  01,2A9
0730:  MOVFF  03,2AA
....................  
....................       ps->smState = TCP_CLOSED; 
0734:  MOVFF  2A9,FE9
0738:  MOVFF  2AA,FEA
073C:  MOVLW  0A
073E:  MOVWF  FEF
....................       ps->Flags.bServer = FALSE; 
0740:  MOVLW  23
0742:  ADDWF  xA9,W
0744:  MOVWF  FE9
0746:  MOVLW  00
0748:  ADDWFC xAA,W
074A:  MOVWF  FEA
074C:  BCF    FEF.0
....................       ps->Flags.bIsPutReady = TRUE; 
074E:  MOVLW  23
0750:  ADDWF  xA9,W
0752:  MOVWF  FE9
0754:  MOVLW  00
0756:  ADDWFC xAA,W
0758:  MOVWF  FEA
075A:  BSF    FEF.1
....................       ps->Flags.bFirstRead = TRUE; 
075C:  MOVLW  23
075E:  ADDWF  xA9,W
0760:  MOVWF  FE9
0762:  MOVLW  00
0764:  ADDWFC xAA,W
0766:  MOVWF  FEA
0768:  BSF    FEF.2
....................       ps->Flags.bIsTxInProgress = FALSE; 
076A:  MOVLW  23
076C:  ADDWF  xA9,W
076E:  MOVWF  FE9
0770:  MOVLW  00
0772:  ADDWFC xAA,W
0774:  MOVWF  FEA
0776:  BCF    FEF.4
....................       ps->Flags.bIsGetReady = FALSE; 
0778:  MOVLW  23
077A:  ADDWF  xA9,W
077C:  MOVWF  FE9
077E:  MOVLW  00
0780:  ADDWFC xAA,W
0782:  MOVWF  FEA
0784:  BCF    FEF.3
....................       if (ps->TxBuffer != INVALID_BUFFER) { 
0786:  MOVLW  0F
0788:  ADDWF  xA9,W
078A:  MOVWF  FE9
078C:  MOVLW  00
078E:  ADDWFC xAA,W
0790:  MOVWF  FEA
0792:  INCFSZ FEF,W
0794:  BRA    0798
0796:  BRA    07C2
....................          MACDiscardTx(ps->TxBuffer); 
0798:  MOVLW  0F
079A:  ADDWF  xA9,W
079C:  MOVWF  FE9
079E:  MOVLW  00
07A0:  ADDWFC xAA,W
07A2:  MOVWF  FEA
07A4:  MOVFF  FEF,2AB
07A8:  MOVFF  2AB,2AC
07AC:  MOVLB  0
07AE:  RCALL  0004
....................          ps->TxBuffer = INVALID_BUFFER; 
07B0:  MOVLW  0F
07B2:  MOVLB  2
07B4:  ADDWF  xA9,W
07B6:  MOVWF  FE9
07B8:  MOVLW  00
07BA:  ADDWFC xAA,W
07BC:  MOVWF  FEA
07BE:  MOVLW  FF
07C0:  MOVWF  FEF
....................       } 
....................       ps->TimeOut = TCP_START_TIMEOUT_VAL; 
07C2:  MOVLW  21
07C4:  ADDWF  xA9,W
07C6:  MOVWF  FE9
07C8:  MOVLW  00
07CA:  ADDWFC xAA,W
07CC:  MOVWF  FEA
07CE:  CLRF   FEC
07D0:  MOVF   FED,F
07D2:  MOVLW  24
07D4:  MOVWF  FEF
....................       ps->TxCount = 0; 
07D6:  MOVLW  10
07D8:  ADDWF  xA9,W
07DA:  MOVWF  FE9
07DC:  MOVLW  00
07DE:  ADDWFC xAA,W
07E0:  MOVWF  FEA
07E2:  CLRF   FEC
07E4:  MOVF   FED,F
07E6:  CLRF   FEF
....................    } 
....................  
....................    //_NextPort = LOCAL_PORT_START_NUMBER; 
.................... #if getenv("TIMER0") 
07E8:  INCF   xA8,F
07EA:  BRA    0716
....................    TCPInit_RandSeed+=get_timer0(); 
07EC:  MOVF   FD6,W
07EE:  MOVLB  1
07F0:  ADDWF  x3E,F
07F2:  MOVF   FD7,W
07F4:  ADDWFC x3F,F
.................... #endif 
.................... #if getenv("TIMER1") 
....................    TCPInit_RandSeed+=get_timer1(); 
07F6:  MOVF   FCE,W
07F8:  ADDWF  x3E,F
07FA:  MOVF   FCF,W
07FC:  ADDWFC x3F,F
.................... #endif 
.................... #if getenv("TIMER2") 
....................    TCPInit_RandSeed+=get_timer2(); 
07FE:  MOVF   FCC,W
0800:  ADDWF  x3E,F
0802:  MOVLW  00
0804:  ADDWFC x3F,F
.................... #endif 
.................... #if getenv("TIMER3") 
....................    TCPInit_RandSeed+=get_timer3(); 
0806:  MOVF   FB2,W
0808:  ADDWF  x3E,F
080A:  MOVF   FB3,W
080C:  ADDWFC x3F,F
.................... #endif 
.................... #if getenv("TIMER4") 
....................    TCPInit_RandSeed+=get_timer4(); 
.................... #endif 
.................... #if getenv("TIMER5") 
....................    TCPInit_RandSeed+=get_timer5(); 
.................... #endif 
....................    srand(TCPInit_RandSeed); 
080E:  MOVLB  2
0810:  CLRF   xAE
0812:  CLRF   xAD
0814:  MOVFF  13F,2AC
0818:  MOVFF  13E,2AB
081C:  MOVLB  0
081E:  RCALL  05DC
....................    _NextPort = rand(); 
0820:  RCALL  0690
0822:  MOVFF  02,89
0826:  MOVFF  01,88
....................    _NextPort += LOCAL_PORT_START_NUMBER; 
082A:  MOVLW  04
082C:  ADDWF  x89,F
....................    while (_NextPort >= LOCAL_PORT_END_NUMBER) { 
082E:  MOVF   x89,W
0830:  SUBLW  12
0832:  BC    0848
0834:  XORLW  FF
0836:  BNZ   083E
0838:  MOVF   x88,W
083A:  SUBLW  87
083C:  BC    0848
....................       _NextPort -= LOCAL_PORT_END_NUMBER; 
083E:  MOVLW  88
0840:  SUBWF  x88,F
0842:  MOVLW  13
0844:  SUBWFB x89,F
....................    } 
0846:  BRA    082E
....................    if (_NextPort < LOCAL_PORT_START_NUMBER) { 
0848:  MOVF   x89,W
084A:  SUBLW  03
084C:  BNC   0852
....................       _NextPort += LOCAL_PORT_START_NUMBER; 
084E:  MOVLW  04
0850:  ADDWF  x89,F
....................    } 
.................... } 
0852:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           port    - A TCP port to be opened. 
....................  * 
....................  * Output:          Given port is opened and returned on success 
....................  *                  INVALID_SOCKET if no more sockets left. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TCP_SOCKET TCPListen(TCP_PORT port) { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................  
....................    //debug_tcp("\r\nTCP LISTEN PORT=%LU -> ", port); 
....................  
....................    for (s = 0; s < MAX_SOCKETS; s++) { 
....................       ps = &TCB[s]; 
....................  
....................       if (ps->smState == TCP_CLOSED) { 
....................          // We have a CLOSED socket. 
....................          // Initialize it with LISTENing state info. 
....................          ps->smState = TCP_LISTEN; 
....................          ps->localPort = port; 
....................          ps->remotePort = 0; 
....................  
....................          // There is no remote node IP address info yet. 
....................          ps->remote.IPAddr.Val = 0x00; 
....................  
....................          // If a socket is listened on, it is a SERVER. 
....................          ps->Flags.bServer = TRUE; 
....................  
....................          ps->Flags.bIsGetReady = FALSE; 
....................          if (ps->TxBuffer != INVALID_BUFFER) { 
....................             MACDiscardTx(ps->TxBuffer); 
....................             ps->TxBuffer = INVALID_BUFFER; 
....................          } 
....................          ps->Flags.bIsPutReady = TRUE; 
....................  
....................          //debug_tcp("SOCK=%U", s); 
....................  
....................          return s; 
....................       } 
....................    } 
....................  
....................    //debug_tcp("FAIL"); 
....................  
....................    return INVALID_SOCKET; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
....................  *                                      TCP_PORT remotePort) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           remote      - Remote node address info 
....................  *                  remotePort  - remote port to be connected. 
....................  * 
....................  * Output:          A new socket is created, connection request is 
....................  *                  sent and socket handle is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT remotePort) { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................    BOOL lbFound; 
....................  
....................    lbFound = FALSE; 
*
4C40:  MOVLB  2
4C42:  BCF    x12.0
....................  
....................    //debug_tcp("\r\nTCP CONNECT PORT=%LU -> ", remotePort); 
....................  
....................    // Find an available socket 
....................    for (s = 0; s < MAX_SOCKETS; s++) { 
4C44:  CLRF   x0F
4C46:  MOVF   x0F,W
4C48:  SUBLW  04
4C4A:  BNC   4C7A
....................       ps = &TCB[s]; 
4C4C:  MOVF   x0F,W
4C4E:  MULLW  24
4C50:  MOVF   FF3,W
4C52:  CLRF   03
4C54:  ADDLW  8A
4C56:  MOVWF  01
4C58:  MOVLW  00
4C5A:  ADDWFC 03,F
4C5C:  MOVFF  01,210
4C60:  MOVFF  03,211
....................       if (ps->smState == TCP_CLOSED) { 
4C64:  MOVFF  210,FE9
4C68:  MOVFF  211,FEA
4C6C:  MOVF   FEF,W
4C6E:  SUBLW  0A
4C70:  BNZ   4C76
....................          lbFound = TRUE; 
4C72:  BSF    x12.0
....................          break; 
4C74:  BRA    4C7A
....................       } 
....................    } 
4C76:  INCF   x0F,F
4C78:  BRA    4C46
....................  
....................    // If there is no socket available, return error. 
....................    if (!lbFound) 
4C7A:  BTFSC  x12.0
4C7C:  BRA    4C84
....................       return INVALID_SOCKET; 
4C7E:  MOVLW  FE
4C80:  MOVWF  01
4C82:  BRA    4E58
....................  
....................    // Each new socket that is opened by this node, gets 
....................    // next sequential port number. 
....................    ps->localPort = ++_NextPort; 
4C84:  MOVLW  0B
4C86:  ADDWF  x10,W
4C88:  MOVWF  FE9
4C8A:  MOVLW  00
4C8C:  ADDWFC x11,W
4C8E:  MOVWF  FEA
4C90:  MOVLB  0
4C92:  INCF   x88,F
4C94:  BTFSC  FD8.2
4C96:  INCF   x89,F
4C98:  MOVFF  89,FEC
4C9C:  MOVF   FED,F
4C9E:  MOVFF  88,FEF
....................    if (_NextPort >= LOCAL_PORT_END_NUMBER) 
4CA2:  MOVF   x89,W
4CA4:  SUBLW  12
4CA6:  BC    4CBA
4CA8:  XORLW  FF
4CAA:  BNZ   4CB2
4CAC:  MOVF   x88,W
4CAE:  SUBLW  87
4CB0:  BC    4CBA
....................       _NextPort = LOCAL_PORT_START_NUMBER - 1; 
4CB2:  MOVLW  03
4CB4:  MOVWF  x89
4CB6:  MOVLW  FF
4CB8:  MOVWF  x88
....................  
....................    // This is a client socket. 
....................    ps->Flags.bServer = FALSE; 
4CBA:  MOVLW  23
4CBC:  MOVLB  2
4CBE:  ADDWF  x10,W
4CC0:  MOVWF  FE9
4CC2:  MOVLW  00
4CC4:  ADDWFC x11,W
4CC6:  MOVWF  FEA
4CC8:  BCF    FEF.0
....................  
....................    // This is the port, we are trying to connect to. 
....................    ps->remotePort = remotePort; 
4CCA:  MOVLW  0D
4CCC:  ADDWF  x10,W
4CCE:  MOVWF  FE9
4CD0:  MOVLW  00
4CD2:  ADDWFC x11,W
4CD4:  MOVWF  FEA
4CD6:  MOVFF  20E,FEC
4CDA:  MOVF   FED,F
4CDC:  MOVFF  20D,FEF
....................  
....................    // Each new socket that is opened by this node, will 
....................    // start with next the next seqeuence number (essentially random) 
....................    ps->SND_SEQ++; 
4CE0:  MOVLW  16
4CE2:  ADDWF  x10,W
4CE4:  MOVWF  FE9
4CE6:  MOVLW  00
4CE8:  ADDWFC x11,W
4CEA:  MOVWF  FEA
4CEC:  MOVLW  01
4CEE:  ADDWF  FEE,F
4CF0:  MOVLW  00
4CF2:  ADDWFC FEE,F
4CF4:  ADDWFC FEE,F
4CF6:  ADDWFC FED,F
....................    ps->SND_ACK = 0; 
4CF8:  MOVLW  1A
4CFA:  ADDWF  x10,W
4CFC:  MOVWF  FE9
4CFE:  MOVLW  00
4D00:  ADDWFC x11,W
4D02:  MOVWF  FEA
4D04:  MOVF   FEE,F
4D06:  MOVF   FEE,F
4D08:  CLRF   FEC
4D0A:  MOVF   FED,F
4D0C:  CLRF   FEF
4D0E:  MOVF   FED,F
4D10:  CLRF   FEF
4D12:  MOVF   FED,F
4D14:  CLRF   FEF
....................  
....................    memcpy((BYTE*) &ps->remote, (void*) remote, sizeof(ps->remote)); 
4D16:  MOVLW  01
4D18:  ADDWF  x10,W
4D1A:  MOVWF  01
4D1C:  MOVLW  00
4D1E:  ADDWFC x11,W
4D20:  MOVWF  03
4D22:  MOVFF  01,213
4D26:  MOVWF  x14
4D28:  MOVWF  FEA
4D2A:  MOVFF  01,FE9
4D2E:  MOVFF  20C,FE2
4D32:  MOVFF  20B,FE1
4D36:  MOVLW  0A
4D38:  MOVWF  01
4D3A:  MOVFF  FE6,FEE
4D3E:  DECFSZ 01,F
4D40:  BRA    4D3A
....................  
....................    // Send SYN message. 
....................    SendTCP(&ps->remote, ps->localPort, ps->remotePort, ps->SND_SEQ, 
....................          ps->SND_ACK, SYN); 
4D42:  MOVLW  01
4D44:  ADDWF  x10,W
4D46:  MOVWF  01
4D48:  MOVLW  00
4D4A:  ADDWFC x11,W
4D4C:  MOVWF  03
4D4E:  MOVFF  01,213
4D52:  MOVWF  x14
4D54:  MOVLW  0B
4D56:  ADDWF  x10,W
4D58:  MOVWF  FE9
4D5A:  MOVLW  00
4D5C:  ADDWFC x11,W
4D5E:  MOVWF  FEA
4D60:  MOVFF  FEC,216
4D64:  MOVF   FED,F
4D66:  MOVFF  FEF,215
4D6A:  MOVLW  0D
4D6C:  ADDWF  x10,W
4D6E:  MOVWF  FE9
4D70:  MOVLW  00
4D72:  ADDWFC x11,W
4D74:  MOVWF  FEA
4D76:  MOVFF  FEC,218
4D7A:  MOVF   FED,F
4D7C:  MOVFF  FEF,217
4D80:  MOVLW  16
4D82:  ADDWF  x10,W
4D84:  MOVWF  FE9
4D86:  MOVLW  00
4D88:  ADDWFC x11,W
4D8A:  MOVWF  FEA
4D8C:  MOVFF  FEF,219
4D90:  MOVFF  FEC,21A
4D94:  MOVFF  FEC,21B
4D98:  MOVFF  FEC,21C
4D9C:  MOVLW  1A
4D9E:  ADDWF  x10,W
4DA0:  MOVWF  FE9
4DA2:  MOVLW  00
4DA4:  ADDWFC x11,W
4DA6:  MOVWF  FEA
4DA8:  MOVFF  FEF,21D
4DAC:  MOVFF  FEC,21E
4DB0:  MOVFF  FEC,21F
4DB4:  MOVFF  FEC,220
4DB8:  MOVFF  03,243
4DBC:  MOVFF  01,242
4DC0:  MOVFF  216,245
4DC4:  MOVFF  215,244
4DC8:  MOVFF  218,247
4DCC:  MOVFF  217,246
4DD0:  MOVFF  21C,24B
4DD4:  MOVFF  21B,24A
4DD8:  MOVFF  21A,249
4DDC:  MOVFF  219,248
4DE0:  MOVFF  220,24F
4DE4:  MOVFF  21F,24E
4DE8:  MOVFF  21E,24D
4DEC:  MOVFF  21D,24C
4DF0:  MOVLW  02
4DF2:  MOVWF  x50
4DF4:  MOVLW  FF
4DF6:  MOVWF  x51
4DF8:  CLRF   x53
4DFA:  CLRF   x52
4DFC:  MOVLB  0
4DFE:  CALL   2D1C
....................  
....................    ps->smState = TCP_SYN_SENT; 
4E02:  MOVLB  2
4E04:  MOVFF  210,FE9
4E08:  MOVFF  211,FEA
4E0C:  MOVLW  01
4E0E:  MOVWF  FEF
....................    ps->SND_SEQ++; 
4E10:  MOVLW  16
4E12:  ADDWF  x10,W
4E14:  MOVWF  FE9
4E16:  MOVLW  00
4E18:  ADDWFC x11,W
4E1A:  MOVWF  FEA
4E1C:  MOVLW  01
4E1E:  ADDWF  FEE,F
4E20:  MOVLW  00
4E22:  ADDWFC FEE,F
4E24:  ADDWFC FEE,F
4E26:  ADDWFC FED,F
....................  
....................    // Allow TCPTick() to operate properly 
....................    ps->startTick = TickGet(); 
4E28:  MOVLW  1F
4E2A:  ADDWF  x10,W
4E2C:  MOVWF  01
4E2E:  MOVLW  00
4E30:  ADDWFC x11,W
4E32:  MOVWF  03
4E34:  MOVFF  01,213
4E38:  MOVWF  x14
4E3A:  MOVLB  0
4E3C:  CALL   0FE8
4E40:  MOVFF  214,FEA
4E44:  MOVFF  213,FE9
4E48:  MOVFF  02,FEC
4E4C:  MOVF   FED,F
4E4E:  MOVFF  01,FEF
....................  
....................    //debug_tcp("SOCK=%U", s); 
....................  
....................    return s; 
4E52:  MOVLB  2
4E54:  MOVFF  20F,01
.................... } 
4E58:  MOVLB  0
4E5A:  GOTO   6160 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL TCPIsConnected(TCP_SOCKET s) { 
....................    return (TCB[s].smState == TCP_ESTABLISHED); 
4E5E:  MOVLB  2
4E60:  MOVF   x0B,W
4E62:  MULLW  24
4E64:  MOVF   FF3,W
4E66:  CLRF   x0D
4E68:  MOVWF  x0C
4E6A:  MOVLW  8A
4E6C:  ADDWF  x0C,W
4E6E:  MOVWF  FE9
4E70:  MOVLW  00
4E72:  ADDWFC x0D,W
4E74:  MOVWF  FEA
4E76:  MOVF   FEF,W
4E78:  SUBLW  03
4E7A:  BZ    4E80
4E7C:  MOVLW  00
4E7E:  BRA    4E82
4E80:  MOVLW  01
4E82:  MOVWF  01
.................... } 
4E84:  MOVLB  0
4E86:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPDisconnect(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsPutReady(s) == TRUE 
....................  * 
....................  * Input:           s       - Socket to be disconnected. 
....................  * 
....................  * Output:          A disconnect request is sent for given socket. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TCPDisconnect(TCP_SOCKET s) { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
5F48:  MOVLB  2
5F4A:  MOVF   x0B,W
5F4C:  MULLW  24
5F4E:  MOVF   FF3,W
5F50:  CLRF   03
5F52:  ADDLW  8A
5F54:  MOVWF  01
5F56:  MOVLW  00
5F58:  ADDWFC 03,F
5F5A:  MOVFF  01,20C
5F5E:  MOVFF  03,20D
....................  
....................    // If socket is not connected, may be it is already closed 
....................    // or in the process of closing.  Since we have called this 
....................    // explicitly, close it forcefully. 
....................    if (ps->smState != TCP_ESTABLISHED && ps->smState != TCP_SYN_RECEIVED) { 
5F62:  MOVFF  20C,FE9
5F66:  MOVFF  20D,FEA
5F6A:  MOVF   FEF,W
5F6C:  SUBLW  03
5F6E:  BZ    5F8E
5F70:  MOVFF  20C,FE9
5F74:  MOVFF  20D,FEA
5F78:  MOVF   FEF,W
5F7A:  SUBLW  02
5F7C:  BZ    5F8E
....................       CloseSocket(ps); 
5F7E:  MOVFF  20D,23F
5F82:  MOVFF  20C,23E
5F86:  MOVLB  0
5F88:  CALL   27F6
....................       return; 
5F8C:  BRA    607E
....................    } 
....................  
....................    // Discard any outstanding data that is to be read. 
....................    TCPDiscard(s); 
5F8E:  MOVFF  20B,20E
5F92:  MOVLB  0
5F94:  BRA    5EF8
....................  
....................    // Send FIN message. 
....................    SendTCP(&ps->remote, ps->localPort, ps->remotePort, ps->SND_SEQ, 
....................          ps->SND_ACK, FIN | ACK); 
5F96:  MOVLW  01
5F98:  MOVLB  2
5F9A:  ADDWF  x0C,W
5F9C:  MOVWF  01
5F9E:  MOVLW  00
5FA0:  ADDWFC x0D,W
5FA2:  MOVWF  03
5FA4:  MOVFF  01,20E
5FA8:  MOVWF  x0F
5FAA:  MOVLW  0B
5FAC:  ADDWF  x0C,W
5FAE:  MOVWF  FE9
5FB0:  MOVLW  00
5FB2:  ADDWFC x0D,W
5FB4:  MOVWF  FEA
5FB6:  MOVFF  FEC,211
5FBA:  MOVF   FED,F
5FBC:  MOVFF  FEF,210
5FC0:  MOVLW  0D
5FC2:  ADDWF  x0C,W
5FC4:  MOVWF  FE9
5FC6:  MOVLW  00
5FC8:  ADDWFC x0D,W
5FCA:  MOVWF  FEA
5FCC:  MOVFF  FEC,213
5FD0:  MOVF   FED,F
5FD2:  MOVFF  FEF,212
5FD6:  MOVLW  16
5FD8:  ADDWF  x0C,W
5FDA:  MOVWF  FE9
5FDC:  MOVLW  00
5FDE:  ADDWFC x0D,W
5FE0:  MOVWF  FEA
5FE2:  MOVFF  FEF,214
5FE6:  MOVFF  FEC,215
5FEA:  MOVFF  FEC,216
5FEE:  MOVFF  FEC,217
5FF2:  MOVLW  1A
5FF4:  ADDWF  x0C,W
5FF6:  MOVWF  FE9
5FF8:  MOVLW  00
5FFA:  ADDWFC x0D,W
5FFC:  MOVWF  FEA
5FFE:  MOVFF  FEF,218
6002:  MOVFF  FEC,219
6006:  MOVFF  FEC,21A
600A:  MOVFF  FEC,21B
600E:  MOVFF  03,243
6012:  MOVFF  01,242
6016:  MOVFF  211,245
601A:  MOVFF  210,244
601E:  MOVFF  213,247
6022:  MOVFF  212,246
6026:  MOVFF  217,24B
602A:  MOVFF  216,24A
602E:  MOVFF  215,249
6032:  MOVFF  214,248
6036:  MOVFF  21B,24F
603A:  MOVFF  21A,24E
603E:  MOVFF  219,24D
6042:  MOVFF  218,24C
6046:  MOVLW  11
6048:  MOVWF  x50
604A:  MOVLW  FF
604C:  MOVWF  x51
604E:  CLRF   x53
6050:  CLRF   x52
6052:  MOVLB  0
6054:  CALL   2D1C
....................    //DebugPrint("."); 
....................  
....................    ps->SND_SEQ++; 
6058:  MOVLW  16
605A:  MOVLB  2
605C:  ADDWF  x0C,W
605E:  MOVWF  FE9
6060:  MOVLW  00
6062:  ADDWFC x0D,W
6064:  MOVWF  FEA
6066:  MOVLW  01
6068:  ADDWF  FEE,F
606A:  MOVLW  00
606C:  ADDWFC FEE,F
606E:  ADDWFC FEE,F
6070:  ADDWFC FED,F
....................  
....................    ps->smState = TCP_FIN_WAIT_1; 
6072:  MOVFF  20C,FE9
6076:  MOVFF  20D,FEA
607A:  MOVLW  04
607C:  MOVWF  FEF
607E:  MOVLB  0
....................  
....................    return; 
.................... } 
6080:  GOTO   6A00 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPFlush(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket whose data is to be transmitted. 
....................  * 
....................  * Output:          All and any data associated with this socket 
....................  *                  is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPFlush(TCP_SOCKET s) { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
505A:  MOVLB  2
505C:  MOVF   x14,W
505E:  MULLW  24
5060:  MOVF   FF3,W
5062:  CLRF   03
5064:  ADDLW  8A
5066:  MOVWF  01
5068:  MOVLW  00
506A:  ADDWFC 03,F
506C:  MOVFF  01,215
5070:  MOVFF  03,216
....................  
....................    // Make sure that there is TxBuffer assigned to this socket. 
....................    if (ps->TxBuffer == INVALID_BUFFER) 
5074:  MOVLW  0F
5076:  ADDWF  x15,W
5078:  MOVWF  FE9
507A:  MOVLW  00
507C:  ADDWFC x16,W
507E:  MOVWF  FEA
5080:  INCFSZ FEF,W
5082:  BRA    508A
....................       return FALSE; 
5084:  MOVLW  00
5086:  MOVWF  01
5088:  BRA    5220
....................  
....................    if (ps->Flags.bIsPutReady == FALSE) 
508A:  MOVLW  23
508C:  ADDWF  x15,W
508E:  MOVWF  FE9
5090:  MOVLW  00
5092:  ADDWFC x16,W
5094:  MOVWF  FEA
5096:  MOVLW  00
5098:  BTFSC  FEF.1
509A:  MOVLW  01
509C:  XORLW  00
509E:  BNZ   50A6
....................       return FALSE; 
50A0:  MOVLW  00
50A2:  MOVWF  01
50A4:  BRA    5220
....................  
....................    TransmitTCP(&ps->remote, ps->localPort, ps->remotePort, ps->SND_SEQ, 
....................          ps->SND_ACK, 
....................          ACK + PSH, // Use PSH to make sure the end application receives the data right away 
....................          ps->TxBuffer, ps->TxCount); 
50A6:  MOVLW  01
50A8:  ADDWF  x15,W
50AA:  MOVWF  01
50AC:  MOVLW  00
50AE:  ADDWFC x16,W
50B0:  MOVWF  03
50B2:  MOVFF  01,217
50B6:  MOVWF  x18
50B8:  MOVLW  0B
50BA:  ADDWF  x15,W
50BC:  MOVWF  FE9
50BE:  MOVLW  00
50C0:  ADDWFC x16,W
50C2:  MOVWF  FEA
50C4:  MOVFF  FEC,21A
50C8:  MOVF   FED,F
50CA:  MOVFF  FEF,219
50CE:  MOVLW  0D
50D0:  ADDWF  x15,W
50D2:  MOVWF  FE9
50D4:  MOVLW  00
50D6:  ADDWFC x16,W
50D8:  MOVWF  FEA
50DA:  MOVFF  FEC,21C
50DE:  MOVF   FED,F
50E0:  MOVFF  FEF,21B
50E4:  MOVLW  16
50E6:  ADDWF  x15,W
50E8:  MOVWF  FE9
50EA:  MOVLW  00
50EC:  ADDWFC x16,W
50EE:  MOVWF  FEA
50F0:  MOVFF  FEF,21D
50F4:  MOVFF  FEC,21E
50F8:  MOVFF  FEC,21F
50FC:  MOVFF  FEC,220
5100:  MOVLW  1A
5102:  ADDWF  x15,W
5104:  MOVWF  FE9
5106:  MOVLW  00
5108:  ADDWFC x16,W
510A:  MOVWF  FEA
510C:  MOVFF  FEF,221
5110:  MOVFF  FEC,222
5114:  MOVFF  FEC,223
5118:  MOVFF  FEC,224
511C:  MOVLW  0F
511E:  ADDWF  x15,W
5120:  MOVWF  FE9
5122:  MOVLW  00
5124:  ADDWFC x16,W
5126:  MOVWF  FEA
5128:  MOVFF  FEF,225
512C:  MOVLW  10
512E:  ADDWF  x15,W
5130:  MOVWF  FE9
5132:  MOVLW  00
5134:  ADDWFC x16,W
5136:  MOVWF  FEA
5138:  MOVFF  FEC,227
513C:  MOVF   FED,F
513E:  MOVFF  FEF,226
5142:  MOVFF  03,243
5146:  MOVFF  01,242
514A:  MOVFF  21A,245
514E:  MOVFF  219,244
5152:  MOVFF  21C,247
5156:  MOVFF  21B,246
515A:  MOVFF  220,24B
515E:  MOVFF  21F,24A
5162:  MOVFF  21E,249
5166:  MOVFF  21D,248
516A:  MOVFF  224,24F
516E:  MOVFF  223,24E
5172:  MOVFF  222,24D
5176:  MOVFF  221,24C
517A:  MOVLW  18
517C:  MOVWF  x50
517E:  MOVFF  225,251
5182:  MOVFF  227,253
5186:  MOVFF  226,252
518A:  MOVLB  0
518C:  CALL   2D1C
....................  
....................    ps->SND_SEQ += (DWORD) ps->TxCount; 
5190:  MOVLW  16
5192:  MOVLB  2
5194:  ADDWF  x15,W
5196:  MOVWF  01
5198:  MOVLW  00
519A:  ADDWFC x16,W
519C:  MOVWF  03
519E:  MOVFF  01,217
51A2:  MOVWF  x18
51A4:  MOVWF  FEA
51A6:  MOVFF  01,FE9
51AA:  MOVFF  FEF,219
51AE:  MOVFF  FEC,21A
51B2:  MOVFF  FEC,21B
51B6:  MOVFF  FEC,21C
51BA:  MOVLW  10
51BC:  ADDWF  x15,W
51BE:  MOVWF  FE9
51C0:  MOVLW  00
51C2:  ADDWFC x16,W
51C4:  MOVWF  FEA
51C6:  MOVFF  FEC,03
51CA:  MOVF   FED,F
51CC:  MOVFF  FEF,00
51D0:  MOVFF  03,01
51D4:  CLRF   02
51D6:  CLRF   03
51D8:  MOVF   x19,W
51DA:  ADDWF  00,F
51DC:  MOVF   x1A,W
51DE:  ADDWFC 01,F
51E0:  MOVF   x1B,W
51E2:  ADDWFC 02,F
51E4:  MOVF   x1C,W
51E6:  ADDWFC 03,F
51E8:  MOVFF  218,FEA
51EC:  MOVFF  217,FE9
51F0:  MOVFF  00,FEF
51F4:  MOVFF  01,FEC
51F8:  MOVFF  02,FEC
51FC:  MOVFF  03,FEC
....................    ps->Flags.bIsPutReady = FALSE; 
5200:  MOVLW  23
5202:  ADDWF  x15,W
5204:  MOVWF  FE9
5206:  MOVLW  00
5208:  ADDWFC x16,W
520A:  MOVWF  FEA
520C:  BCF    FEF.1
....................    ps->Flags.bIsTxInProgress = FALSE; 
520E:  MOVLW  23
5210:  ADDWF  x15,W
5212:  MOVWF  FE9
5214:  MOVLW  00
5216:  ADDWFC x16,W
5218:  MOVWF  FEA
521A:  BCF    FEF.4
....................  
.................... #if TCP_NO_WAIT_FOR_ACK 
....................    if(ps->TxBuffer != INVALID_BUFFER) 
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
....................       ps->TxBuffer = INVALID_BUFFER; 
....................    } 
....................    ps->Flags.bIsPutReady = TRUE; 
.................... #endif 
....................  
....................    return TRUE; 
521C:  MOVLW  01
521E:  MOVWF  01
.................... } 
5220:  MOVLB  0
5222:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL TCPIsPutReady(TCP_SOCKET s) { 
....................    if (TCB[s].RemoteWindow == 0) 
*
4E8E:  MOVLB  2
4E90:  MOVF   x0B,W
4E92:  MULLW  24
4E94:  MOVF   FF3,W
4E96:  CLRF   x0D
4E98:  MOVWF  x0C
4E9A:  MOVLW  14
4E9C:  ADDWF  x0C,W
4E9E:  MOVWF  01
4EA0:  MOVLW  00
4EA2:  ADDWFC x0D,W
4EA4:  MOVWF  03
4EA6:  MOVF   01,W
4EA8:  ADDLW  8A
4EAA:  MOVWF  FE9
4EAC:  MOVLW  00
4EAE:  ADDWFC 03,W
4EB0:  MOVWF  FEA
4EB2:  MOVFF  FEC,20D
4EB6:  MOVF   FED,F
4EB8:  MOVFF  FEF,20C
4EBC:  MOVF   x0C,F
4EBE:  BNZ   4ECA
4EC0:  MOVF   x0D,F
4EC2:  BNZ   4ECA
....................       return FALSE; 
4EC4:  MOVLW  00
4EC6:  MOVWF  01
4EC8:  BRA    4F28
....................  
....................    if (TCB[s].TxBuffer == INVALID_BUFFER) 
4ECA:  MOVF   x0B,W
4ECC:  MULLW  24
4ECE:  MOVF   FF3,W
4ED0:  CLRF   x0D
4ED2:  MOVWF  x0C
4ED4:  MOVLW  0F
4ED6:  ADDWF  x0C,W
4ED8:  MOVWF  01
4EDA:  MOVLW  00
4EDC:  ADDWFC x0D,W
4EDE:  MOVWF  03
4EE0:  MOVF   01,W
4EE2:  ADDLW  8A
4EE4:  MOVWF  FE9
4EE6:  MOVLW  00
4EE8:  ADDWFC 03,W
4EEA:  MOVWF  FEA
4EEC:  INCFSZ FEF,W
4EEE:  BRA    4F00
....................       return IPIsTxReady(FALSE); 
4EF0:  CLRF   x7A
4EF2:  MOVLB  0
4EF4:  CALL   2906
4EF8:  MOVF   01,W
4EFA:  MOVLB  2
4EFC:  BRA    4F28
....................    else 
4EFE:  BRA    4F28
....................       return TCB[s].Flags.bIsPutReady; 
4F00:  MOVF   x0B,W
4F02:  MULLW  24
4F04:  MOVF   FF3,W
4F06:  CLRF   x0D
4F08:  MOVWF  x0C
4F0A:  MOVLW  23
4F0C:  ADDWF  x0C,F
4F0E:  MOVLW  00
4F10:  ADDWFC x0D,F
4F12:  MOVLW  8A
4F14:  ADDWF  x0C,W
4F16:  MOVWF  FE9
4F18:  MOVLW  00
4F1A:  ADDWFC x0D,W
4F1C:  MOVWF  FEA
4F1E:  MOVLW  00
4F20:  BTFSC  FEF.1
4F22:  MOVLW  01
4F24:  MOVWF  01
4F26:  BRA    4F28
.................... } 
4F28:  MOVLB  0
4F2A:  GOTO   6206 (RETURN)
....................  
.................... int16 TCPPutAvailable(TCP_SOCKET s) { 
....................    int16 txCount, txAvail; 
....................  
....................    if (!TCPIsPutReady(s)) 
....................       return (0); 
....................  
....................    if (TCB[s].TxBuffer == INVALID_BUFFER) 
....................       txCount = 0; 
....................    else 
....................       txCount = TCB[s].TxCount; 
....................  
....................    txAvail = MAX_TCP_DATA_LEN - txCount; 
....................  
....................    txAvail = txAvail > TCB[s].RemoteWindow ? TCB[s].RemoteWindow : txAvail; 
....................  
....................    return (txAvail); 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer -OR- we ran out of space in the remote node's 
....................  *                  window.  In either case you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) { 
....................    SOCKET_INFO* ps; 
....................    WORD n; 
....................  
....................    ps = &TCB[s]; 
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if (ps->RemoteWindow == 0) 
....................       return 0; 
....................  
....................    if (ps->TxBuffer == INVALID_BUFFER) { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if (ps->TxBuffer == INVALID_BUFFER) 
....................          return 0; 
....................  
....................       ps->TxCount = 0; 
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
....................    } 
....................  
....................    n = TCPPutAvailable(s); 
....................  
....................    len = n < len ? n : len; 
....................    n = len; 
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................    while (n--) { 
....................       MACPut(*ptr++); 
....................       ps->RemoteWindow -= 1; 
....................       ps->TxCount += 1; 
....................    } 
....................  
....................    if (ps->TxCount >= MAX_TCP_DATA_LEN) 
....................       TCPFlush(s); 
....................  
....................    return (len); 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer and you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPPut(TCP_SOCKET s, BYTE byte) { 
....................    SOCKET_INFO* ps; 
....................    WORD tempCount; 
....................  
....................    ps = &TCB[s]; 
*
5224:  MOVLB  2
5226:  MOVF   x0E,W
5228:  MULLW  24
522A:  MOVF   FF3,W
522C:  CLRF   03
522E:  ADDLW  8A
5230:  MOVWF  01
5232:  MOVLW  00
5234:  ADDWFC 03,F
5236:  MOVFF  01,210
523A:  MOVFF  03,211
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if (ps->RemoteWindow == 0) 
523E:  MOVLW  14
5240:  ADDWF  x10,W
5242:  MOVWF  FE9
5244:  MOVLW  00
5246:  ADDWFC x11,W
5248:  MOVWF  FEA
524A:  MOVFF  FEC,215
524E:  MOVF   FED,F
5250:  MOVFF  FEF,214
5254:  MOVF   x14,F
5256:  BNZ   5262
5258:  MOVF   x15,F
525A:  BNZ   5262
....................       return FALSE; 
525C:  MOVLW  00
525E:  MOVWF  01
5260:  BRA    5368
....................  
....................    if (ps->TxBuffer == INVALID_BUFFER) { 
5262:  MOVLW  0F
5264:  ADDWF  x10,W
5266:  MOVWF  FE9
5268:  MOVLW  00
526A:  ADDWFC x11,W
526C:  MOVWF  FEA
526E:  INCFSZ FEF,W
5270:  BRA    52E4
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
5272:  MOVLW  0F
5274:  ADDWF  x10,W
5276:  MOVWF  01
5278:  MOVLW  00
527A:  ADDWFC x11,W
527C:  MOVWF  03
527E:  MOVFF  01,214
5282:  MOVWF  x15
5284:  CLRF   x7A
5286:  MOVLB  0
5288:  CALL   14D4
528C:  MOVFF  215,FEA
5290:  MOVFF  214,FE9
5294:  MOVFF  01,FEF
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if (ps->TxBuffer == INVALID_BUFFER) 
5298:  MOVLW  0F
529A:  MOVLB  2
529C:  ADDWF  x10,W
529E:  MOVWF  FE9
52A0:  MOVLW  00
52A2:  ADDWFC x11,W
52A4:  MOVWF  FEA
52A6:  INCFSZ FEF,W
52A8:  BRA    52B0
....................          return FALSE; 
52AA:  MOVLW  00
52AC:  MOVWF  01
52AE:  BRA    5368
....................  
....................       ps->TxCount = 0; 
52B0:  MOVLW  10
52B2:  ADDWF  x10,W
52B4:  MOVWF  FE9
52B6:  MOVLW  00
52B8:  ADDWFC x11,W
52BA:  MOVWF  FEA
52BC:  CLRF   FEC
52BE:  MOVF   FED,F
52C0:  CLRF   FEF
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
52C2:  MOVLW  0F
52C4:  ADDWF  x10,W
52C6:  MOVWF  FE9
52C8:  MOVLW  00
52CA:  ADDWFC x11,W
52CC:  MOVWF  FEA
52CE:  MOVFF  FEF,214
52D2:  MOVFF  214,293
52D6:  CLRF   x95
52D8:  MOVLW  28
52DA:  MOVWF  x94
52DC:  MOVLB  0
52DE:  CALL   14FC
52E2:  MOVLB  2
....................    } 
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
52E4:  MOVLW  23
52E6:  ADDWF  x10,W
52E8:  MOVWF  FE9
52EA:  MOVLW  00
52EC:  ADDWFC x11,W
52EE:  MOVWF  FEA
52F0:  BSF    FEF.4
....................  
....................    MACPut(byte); 
52F2:  MOVFF  20F,29D
52F6:  MOVLB  0
52F8:  CALL   15C2
....................    ps->RemoteWindow--; 
52FC:  MOVLW  14
52FE:  MOVLB  2
5300:  ADDWF  x10,W
5302:  MOVWF  FE9
5304:  MOVLW  00
5306:  ADDWFC x11,W
5308:  MOVWF  FEA
530A:  MOVLW  FF
530C:  ADDWF  FEF,F
530E:  BC    5314
5310:  MOVF   FEE,F
5312:  DECF   FED,F
....................  
....................    tempCount = ps->TxCount; 
5314:  MOVLW  10
5316:  ADDWF  x10,W
5318:  MOVWF  FE9
531A:  MOVLW  00
531C:  ADDWFC x11,W
531E:  MOVWF  FEA
5320:  MOVFF  FEC,03
5324:  MOVF   FED,F
5326:  MOVFF  FEF,212
532A:  MOVFF  03,213
....................    tempCount++; 
532E:  INCF   x12,F
5330:  BTFSC  FD8.2
5332:  INCF   x13,F
....................    ps->TxCount = tempCount; 
5334:  MOVLW  10
5336:  ADDWF  x10,W
5338:  MOVWF  FE9
533A:  MOVLW  00
533C:  ADDWFC x11,W
533E:  MOVWF  FEA
5340:  MOVFF  213,FEC
5344:  MOVF   FED,F
5346:  MOVFF  212,FEF
....................    if (tempCount >= MAX_TCP_DATA_LEN) 
534A:  MOVF   x13,W
534C:  SUBLW  02
534E:  BC    5364
5350:  XORLW  FF
5352:  BNZ   535A
5354:  MOVF   x12,W
5356:  SUBLW  C9
5358:  BC    5364
....................       TCPFlush(s); 
535A:  MOVFF  20E,214
535E:  MOVLB  0
5360:  RCALL  505A
5362:  MOVLB  2
....................  
....................    return TRUE; 
5364:  MOVLW  01
5366:  MOVWF  01
.................... } 
5368:  MOVLB  0
536A:  GOTO   5378 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPDiscard(TCP_SOCKET s) { 
....................    SOCKET_INFO* ps; 
....................  
....................    ps = &TCB[s]; 
*
5EF8:  MOVLB  2
5EFA:  MOVF   x0E,W
5EFC:  MULLW  24
5EFE:  MOVF   FF3,W
5F00:  CLRF   03
5F02:  ADDLW  8A
5F04:  MOVWF  01
5F06:  MOVLW  00
5F08:  ADDWFC 03,F
5F0A:  MOVFF  01,20F
5F0E:  MOVFF  03,210
....................  
....................    // This socket must contain data for it to be discarded. 
....................    if (!ps->Flags.bIsGetReady) 
5F12:  MOVLW  23
5F14:  ADDWF  x0F,W
5F16:  MOVWF  FE9
5F18:  MOVLW  00
5F1A:  ADDWFC x10,W
5F1C:  MOVWF  FEA
5F1E:  BTFSC  FEF.3
5F20:  BRA    5F28
....................       return FALSE; 
5F22:  MOVLW  00
5F24:  MOVWF  01
5F26:  BRA    5F42
....................  
....................    MACDiscardRx(); 
5F28:  MOVLB  0
5F2A:  CALL   1070
....................    ps->Flags.bIsGetReady = FALSE; 
5F2E:  MOVLW  23
5F30:  MOVLB  2
5F32:  ADDWF  x0F,W
5F34:  MOVWF  FE9
5F36:  MOVLW  00
5F38:  ADDWFC x10,W
5F3A:  MOVWF  FEA
5F3C:  BCF    FEF.3
....................  
....................    return TRUE; 
5F3E:  MOVLW  01
5F40:  MOVWF  01
.................... } 
5F42:  MOVLB  0
5F44:  GOTO   5F96 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count) { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
....................  
....................    if (ps->Flags.bIsGetReady) { 
....................       if (ps->Flags.bFirstRead) { 
....................          // Position read pointer to begining of TCP data 
....................          IPSetRxBuffer(sizeof(TCP_HEADER)); 
....................  
....................          ps->Flags.bFirstRead = FALSE; 
....................       } 
....................  
....................       ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................       return MACGetArray(buff, count); 
....................    } 
....................    else 
....................       return 0; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPGet(TCP_SOCKET s, BYTE *data) { 
....................    SOCKET_INFO* ps; 
....................  
....................    ps = &TCB[s]; 
*
5434:  MOVLB  2
5436:  MOVF   x0B,W
5438:  MULLW  24
543A:  MOVF   FF3,W
543C:  CLRF   03
543E:  ADDLW  8A
5440:  MOVWF  01
5442:  MOVLW  00
5444:  ADDWFC 03,F
5446:  MOVFF  01,20E
544A:  MOVFF  03,20F
....................  
....................    if (ps->Flags.bIsGetReady) { 
544E:  MOVLW  23
5450:  ADDWF  x0E,W
5452:  MOVWF  FE9
5454:  MOVLW  00
5456:  ADDWFC x0F,W
5458:  MOVWF  FEA
545A:  BTFSS  FEF.3
545C:  BRA    5500
....................       if (ps->Flags.bFirstRead) { 
545E:  MOVLW  23
5460:  ADDWF  x0E,W
5462:  MOVWF  FE9
5464:  MOVLW  00
5466:  ADDWFC x0F,W
5468:  MOVWF  FEA
546A:  BTFSS  FEF.2
546C:  BRA    548A
....................          // Position read pointer to begining of correct 
....................          // buffer. 
....................          IPSetRxBuffer(sizeof(TCP_HEADER)); 
546E:  CLRF   x22
5470:  MOVLW  14
5472:  MOVWF  x21
5474:  MOVLB  0
5476:  CALL   23A4
....................  
....................          ps->Flags.bFirstRead = FALSE; 
547A:  MOVLW  23
547C:  MOVLB  2
547E:  ADDWF  x0E,W
5480:  MOVWF  FE9
5482:  MOVLW  00
5484:  ADDWFC x0F,W
5486:  MOVWF  FEA
5488:  BCF    FEF.2
....................       } 
....................  
....................       if (ps->RxCount == 0) { 
548A:  MOVLW  12
548C:  ADDWF  x0E,W
548E:  MOVWF  FE9
5490:  MOVLW  00
5492:  ADDWFC x0F,W
5494:  MOVWF  FEA
5496:  MOVFF  FEC,211
549A:  MOVF   FED,F
549C:  MOVFF  FEF,210
54A0:  MOVF   x10,F
54A2:  BNZ   54C4
54A4:  MOVF   x11,F
54A6:  BNZ   54C4
....................          MACDiscardRx(); 
54A8:  MOVLB  0
54AA:  CALL   1070
....................          ps->Flags.bIsGetReady = FALSE; 
54AE:  MOVLW  23
54B0:  MOVLB  2
54B2:  ADDWF  x0E,W
54B4:  MOVWF  FE9
54B6:  MOVLW  00
54B8:  ADDWFC x0F,W
54BA:  MOVWF  FEA
54BC:  BCF    FEF.3
....................          return FALSE; 
54BE:  MOVLW  00
54C0:  MOVWF  01
54C2:  BRA    5504
....................       } 
....................  
....................       ps->RxCount--; 
54C4:  MOVLW  12
54C6:  ADDWF  x0E,W
54C8:  MOVWF  FE9
54CA:  MOVLW  00
54CC:  ADDWFC x0F,W
54CE:  MOVWF  FEA
54D0:  MOVLW  FF
54D2:  ADDWF  FEF,F
54D4:  BC    54DA
54D6:  MOVF   FEE,F
54D8:  DECF   FED,F
....................       *data = MACGet(); 
54DA:  MOVFF  20D,03
54DE:  MOVFF  20C,210
54E2:  MOVFF  20D,211
54E6:  MOVLB  0
54E8:  CALL   2194
54EC:  MOVFF  211,FEA
54F0:  MOVFF  210,FE9
54F4:  MOVFF  01,FEF
....................       return TRUE; 
54F8:  MOVLW  01
54FA:  MOVWF  01
54FC:  MOVLB  2
54FE:  BRA    5504
....................    } 
....................    return FALSE; 
5500:  MOVLW  00
5502:  MOVWF  01
.................... } 
5504:  MOVLB  0
5506:  GOTO   696E (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPIsGetReady(TCP_SOCKET s) { 
....................    /* 
....................     * A socket is said to be "Get" ready when it has already 
....................     * received some data.  Sometime, a socket may be closed, 
....................     * but it still may contain data.  Thus in order to ensure 
....................     * reuse of a socket, caller must make sure that it reads 
....................     * a socket, if is ready. 
....................     */ 
....................    return (TCB[s].Flags.bIsGetReady); 
*
5406:  MOVLB  2
5408:  MOVF   x0B,W
540A:  MULLW  24
540C:  MOVF   FF3,W
540E:  CLRF   x0D
5410:  MOVWF  x0C
5412:  MOVLW  23
5414:  ADDWF  x0C,F
5416:  MOVLW  00
5418:  ADDWFC x0D,F
541A:  MOVLW  8A
541C:  ADDWF  x0C,W
541E:  MOVWF  FE9
5420:  MOVLW  00
5422:  ADDWFC x0D,W
5424:  MOVWF  FEA
5426:  MOVLW  00
5428:  BTFSC  FEF.3
542A:  MOVLW  01
542C:  MOVWF  01
.................... } 
542E:  MOVLB  0
5430:  GOTO   6908 (RETURN)
....................  
.................... //// internal functions ///// 
....................  
.................... void DebugTCPDisplayState(TCP_STATE st) { 
....................    switch (st) { 
....................    case TCP_LISTEN: 
....................       debug_tcp("LISTEN"); 
....................       break; 
....................    case TCP_SYN_SENT: 
....................       debug_tcp("SYN_SENT"); 
....................       break; 
....................    case TCP_SYN_RECEIVED: 
....................       debug_tcp("SYN_RECVD"); 
....................       break; 
....................    case TCP_ESTABLISHED: 
....................       debug_tcp("ESTABLISHED"); 
....................       break; 
....................    case TCP_FIN_WAIT_1: 
....................       debug_tcp("FIN_WAIT_1"); 
....................       break; 
....................    case TCP_FIN_WAIT_2: 
....................       debug_tcp("FIN_WAIT_2"); 
....................       break; 
....................    case TCP_CLOSING: 
....................       debug_tcp("CLOSING"); 
....................       break; 
....................    case TCP_TIME_WAIT: 
....................       debug_tcp("TIME_WAIT"); 
....................       break; 
....................    case TCP_CLOSE_WAIT: 
....................       debug_tcp("CLOSE_WAIT"); 
....................       break; 
....................    case TCP_LAST_ACK: 
....................       debug_tcp("LAST_ACK"); 
....................       break; 
....................    case TCP_CLOSED: 
....................       debug_tcp("CLOSED"); 
....................       break; 
....................    default: 
....................       debug_tcp("UNKNOWN %U",st); 
....................       break; 
....................    } 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPTick(void) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Each socket FSM is executed for any timeout 
....................  *                  situation. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TCPTick(void) { 
....................    TCP_SOCKET s; 
....................    TICKTYPE diffTicks; 
....................    TICKTYPE tick; 
....................    SOCKET_INFO* ps; 
....................    DWORD seq; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................  
....................    flags = 0x00; 
*
3ED2:  MOVLB  1
3ED4:  CLRF   xFF
....................    // Periodically all "not closed" sockets must perform timed operations 
....................    for (s = 0; s < MAX_SOCKETS; s++) { 
3ED6:  CLRF   xF4
3ED8:  MOVF   xF4,W
3EDA:  SUBLW  04
3EDC:  BTFSS  FD8.0
3EDE:  BRA    438C
....................       ps = &TCB[s]; 
3EE0:  MOVF   xF4,W
3EE2:  MULLW  24
3EE4:  MOVF   FF3,W
3EE6:  CLRF   03
3EE8:  ADDLW  8A
3EEA:  MOVWF  01
3EEC:  MOVLW  00
3EEE:  ADDWFC 03,F
3EF0:  MOVFF  01,1F9
3EF4:  MOVFF  03,1FA
....................  
....................       //debugLastState = TCB[s].smState; 
....................  
....................       if (ps->Flags.bIsGetReady || ps->Flags.bIsTxInProgress) 
3EF8:  MOVLW  23
3EFA:  ADDWF  xF9,W
3EFC:  MOVWF  FE9
3EFE:  MOVLW  00
3F00:  ADDWFC xFA,W
3F02:  MOVWF  FEA
3F04:  BTFSC  FEF.3
3F06:  BRA    3F18
3F08:  MOVLW  23
3F0A:  ADDWF  xF9,W
3F0C:  MOVWF  FE9
3F0E:  MOVLW  00
3F10:  ADDWFC xFA,W
3F12:  MOVWF  FEA
3F14:  BTFSS  FEF.4
3F16:  BRA    3F1A
....................          continue; 
3F18:  BRA    4388
....................  
....................       // Closed or Passively Listening socket do not care 
....................       // about timeout conditions. 
....................       if ((ps->smState == TCP_CLOSED) 
....................             || (ps->smState == TCP_LISTEN && ps->Flags.bServer == TRUE)) 
3F1A:  MOVFF  1F9,FE9
3F1E:  MOVFF  1FA,FEA
3F22:  MOVF   FEF,W
3F24:  SUBLW  0A
3F26:  BZ    3F4A
3F28:  MOVFF  1F9,FE9
3F2C:  MOVFF  1FA,FEA
3F30:  MOVF   FEF,F
3F32:  BNZ   3F4C
3F34:  MOVLW  23
3F36:  ADDWF  xF9,W
3F38:  MOVWF  FE9
3F3A:  MOVLW  00
3F3C:  ADDWFC xFA,W
3F3E:  MOVWF  FEA
3F40:  MOVLW  00
3F42:  BTFSC  FEF.0
3F44:  MOVLW  01
3F46:  SUBLW  01
3F48:  BNZ   3F4C
....................          continue; 
3F4A:  BRA    4388
....................  
....................       //TODO: review this 
....................       //DSR ADD 063004 
....................       //i do this because if i am a server, i don't want to timeout. 
....................       if ((ps->smState == TCP_ESTABLISHED) && (ps->Flags.bServer == TRUE)) 
3F4C:  MOVFF  1F9,FE9
3F50:  MOVFF  1FA,FEA
3F54:  MOVF   FEF,W
3F56:  SUBLW  03
3F58:  BNZ   3F72
3F5A:  MOVLW  23
3F5C:  ADDWF  xF9,W
3F5E:  MOVWF  FE9
3F60:  MOVLW  00
3F62:  ADDWFC xFA,W
3F64:  MOVWF  FEA
3F66:  MOVLW  00
3F68:  BTFSC  FEF.0
3F6A:  MOVLW  01
3F6C:  SUBLW  01
3F6E:  BNZ   3F72
....................          continue; 
3F70:  BRA    4388
....................  
....................       tick = TickGet(); 
3F72:  MOVLB  0
3F74:  CALL   0FE8
3F78:  MOVFF  02,1F8
3F7C:  MOVFF  01,1F7
....................  
....................       // Calculate timeout value for this socket. 
....................       diffTicks = TickGetDiff(tick, ps->startTick); 
3F80:  MOVLW  1F
3F82:  MOVLB  1
3F84:  ADDWF  xF9,W
3F86:  MOVWF  FE9
3F88:  MOVLW  00
3F8A:  ADDWFC xFA,W
3F8C:  MOVWF  FEA
3F8E:  MOVFF  FEC,03
3F92:  MOVF   FED,F
3F94:  MOVFF  FEF,01
3F98:  MOVF   xF8,W
3F9A:  SUBWF  03,W
3F9C:  BNC   3FA6
3F9E:  BNZ   3FAA
3FA0:  MOVF   01,W
3FA2:  SUBWF  xF7,W
3FA4:  BNC   3FAA
3FA6:  MOVLW  00
3FA8:  BRA    3FAC
3FAA:  MOVLW  01
3FAC:  CLRF   03
3FAE:  IORWF  03,W
3FB0:  BZ    3FF4
3FB2:  MOVLW  1F
3FB4:  ADDWF  xF9,W
3FB6:  MOVWF  FE9
3FB8:  MOVLW  00
3FBA:  ADDWFC xFA,W
3FBC:  MOVWF  FEA
3FBE:  MOVFF  FEC,03
3FC2:  MOVF   FED,F
3FC4:  MOVF   FEF,W
3FC6:  SUBLW  FF
3FC8:  MOVLB  2
3FCA:  MOVWF  x00
3FCC:  MOVLW  FF
3FCE:  SUBFWB 03,W
3FD0:  MOVWF  x01
3FD2:  MOVLB  1
3FD4:  MOVF   xF7,W
3FD6:  MOVLB  2
3FD8:  ADDWF  x00,F
3FDA:  MOVLB  1
3FDC:  MOVF   xF8,W
3FDE:  MOVLB  2
3FE0:  ADDWFC x01,F
3FE2:  MOVLW  01
3FE4:  ADDWF  x00,W
3FE6:  MOVWF  01
3FE8:  MOVLW  00
3FEA:  ADDWFC x01,W
3FEC:  MOVWF  03
3FEE:  MOVF   01,W
3FF0:  BRA    4014
3FF2:  MOVLB  1
3FF4:  MOVLW  1F
3FF6:  ADDWF  xF9,W
3FF8:  MOVWF  FE9
3FFA:  MOVLW  00
3FFC:  ADDWFC xFA,W
3FFE:  MOVWF  FEA
4000:  MOVFF  FEC,03
4004:  MOVF   FED,F
4006:  MOVF   FEF,W
4008:  SUBWF  xF7,W
400A:  MOVWF  00
400C:  MOVF   03,W
400E:  SUBWFB xF8,W
4010:  MOVWF  03
4012:  MOVF   00,W
4014:  MOVLB  1
4016:  MOVWF  xF5
4018:  MOVFF  03,1F6
....................  
....................       // If timeout has not occured, do not do anything. 
....................       if (diffTicks <= ps->TimeOut) 
401C:  MOVLW  21
401E:  ADDWF  xF9,W
4020:  MOVWF  FE9
4022:  MOVLW  00
4024:  ADDWFC xFA,W
4026:  MOVWF  FEA
4028:  MOVFF  FEC,03
402C:  MOVF   FED,F
402E:  MOVFF  FEF,01
4032:  MOVF   xF6,W
4034:  SUBWF  03,W
4036:  BNC   4042
4038:  BNZ   4040
403A:  MOVF   xF5,W
403C:  SUBWF  01,W
403E:  BNC   4042
....................          continue; 
4040:  BRA    4388
....................  
....................       // Most states require retransmission, so check for transmitter 
....................       // availability right here - common for all. 
....................       if (!IPIsTxReady(TRUE)) 
4042:  MOVLW  01
4044:  MOVLB  2
4046:  MOVWF  x7A
4048:  MOVLB  0
404A:  CALL   2906
404E:  MOVF   01,F
4050:  BNZ   4054
....................          return; 
4052:  BRA    438C
....................  
....................       // Restart timeout reference. 
....................       ps->startTick = TickGet(); 
4054:  MOVLW  1F
4056:  MOVLB  1
4058:  ADDWF  xF9,W
405A:  MOVWF  01
405C:  MOVLW  00
405E:  ADDWFC xFA,W
4060:  MOVWF  03
4062:  MOVFF  01,200
4066:  MOVLB  2
4068:  MOVWF  x01
406A:  MOVLB  0
406C:  CALL   0FE8
4070:  MOVFF  201,FEA
4074:  MOVFF  200,FE9
4078:  MOVFF  02,FEC
407C:  MOVF   FED,F
407E:  MOVFF  01,FEF
....................  
....................       // Update timeout value if there is need to wait longer. 
....................       ps->TimeOut <<= 1; 
4082:  MOVLW  21
4084:  MOVLB  1
4086:  ADDWF  xF9,W
4088:  MOVWF  FE9
408A:  MOVLW  00
408C:  ADDWFC xFA,W
408E:  MOVWF  FEA
4090:  BCF    FD8.0
4092:  RLCF   FEF,W
4094:  MOVWF  02
4096:  RLCF   FEC,W
4098:  MOVWF  03
409A:  MOVF   02,W
409C:  MOVF   FED,F
409E:  MOVWF  FEF
40A0:  MOVFF  03,FEC
....................  
....................       // This will be one more attempt. 
....................       ps->RetryCount++; 
40A4:  MOVLW  1E
40A6:  ADDWF  xF9,W
40A8:  MOVWF  FE9
40AA:  MOVLW  00
40AC:  ADDWFC xFA,W
40AE:  MOVWF  FEA
40B0:  INCF   FEF,F
....................  
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch (ps->smState) { 
40B2:  MOVFF  1F9,FE9
40B6:  MOVFF  1FA,FEA
40BA:  MOVLW  01
40BC:  SUBWF  FEF,W
40BE:  ADDLW  F7
40C0:  BTFSC  FD8.0
40C2:  BRA    4260
40C4:  ADDLW  09
40C6:  MOVLB  0
40C8:  GOTO   4392
....................       case TCP_SYN_SENT: 
....................          // Keep sending SYN until we hear from remote node. 
....................          // This may be for infinite time, in that case 
....................          // caller must detect it and do something. 
....................          // Bug Fix: 11/1/02 
....................          flags = SYN; 
40CC:  MOVLW  02
40CE:  MOVLB  1
40D0:  MOVWF  xFF
....................          break; 
40D2:  BRA    4260
....................  
....................       case TCP_SYN_RECEIVED: 
....................          // We must receive ACK before timeout expires. 
....................          // If not, resend SYN+ACK. 
....................          // Abort, if maximum attempts counts are reached. 
....................          if (ps->RetryCount <= MAX_RETRY_COUNTS) { 
40D4:  MOVLW  1E
40D6:  MOVLB  1
40D8:  ADDWF  xF9,W
40DA:  MOVWF  FE9
40DC:  MOVLW  00
40DE:  ADDWFC xFA,W
40E0:  MOVWF  FEA
40E2:  MOVF   FEF,W
40E4:  SUBLW  03
40E6:  BNC   40EE
....................             flags = SYN | ACK; 
40E8:  MOVLW  12
40EA:  MOVWF  xFF
....................          } 
....................          else { 
40EC:  BRA    411A
....................             if (ps->Flags.bServer) { 
40EE:  MOVLW  23
40F0:  ADDWF  xF9,W
40F2:  MOVWF  FE9
40F4:  MOVLW  00
40F6:  ADDWFC xFA,W
40F8:  MOVWF  FEA
40FA:  BTFSS  FEF.0
40FC:  BRA    410A
....................                ps->smState = TCP_LISTEN; 
40FE:  MOVFF  1F9,FE9
4102:  MOVFF  1FA,FEA
4106:  CLRF   FEF
....................             } 
....................             else { 
4108:  BRA    411A
....................                flags = SYN; 
410A:  MOVLW  02
410C:  MOVWF  xFF
....................                ps->smState = TCP_SYN_SENT; 
410E:  MOVFF  1F9,FE9
4112:  MOVFF  1FA,FEA
4116:  MOVLW  01
4118:  MOVWF  FEF
....................             } 
....................          } 
....................          break; 
411A:  BRA    4260
....................  
....................       case TCP_ESTABLISHED: 
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          // Don't let this connection idle for very long time. 
....................          // If we did not receive or send any message before timeout 
....................          // expires, close this connection. 
....................          if (ps->RetryCount <= MAX_RETRY_COUNTS) { 
411C:  MOVLW  1E
411E:  MOVLB  1
4120:  ADDWF  xF9,W
4122:  MOVWF  FE9
4124:  MOVLW  00
4126:  ADDWFC xFA,W
4128:  MOVWF  FEA
412A:  MOVF   FEF,W
412C:  SUBLW  03
412E:  BNC   4174
....................             if (ps->TxBuffer != INVALID_BUFFER) { 
4130:  MOVLW  0F
4132:  ADDWF  xF9,W
4134:  MOVWF  FE9
4136:  MOVLW  00
4138:  ADDWFC xFA,W
413A:  MOVWF  FEA
413C:  INCFSZ FEF,W
413E:  BRA    4142
4140:  BRA    416A
....................                MACSetTxBuffer(ps->TxBuffer, 0); 
4142:  MOVLW  0F
4144:  ADDWF  xF9,W
4146:  MOVWF  FE9
4148:  MOVLW  00
414A:  ADDWFC xFA,W
414C:  MOVWF  FEA
414E:  MOVFF  FEF,200
4152:  MOVFF  200,293
4156:  MOVLB  2
4158:  CLRF   x95
415A:  CLRF   x94
415C:  MOVLB  0
415E:  CALL   14FC
....................                MACFlush(); 
4162:  CALL   1758
....................             } 
....................             else 
4166:  BRA    4170
4168:  MOVLB  1
....................                flags = ACK; 
416A:  MOVLW  10
416C:  MOVWF  xFF
416E:  MOVLB  0
....................          } 
....................          else { 
4170:  BRA    41CE
4172:  MOVLB  1
....................             // Forget about previous transmission. 
....................             if (ps->TxBuffer != INVALID_BUFFER) { 
4174:  MOVLW  0F
4176:  ADDWF  xF9,W
4178:  MOVWF  FE9
417A:  MOVLW  00
417C:  ADDWFC xFA,W
417E:  MOVWF  FEA
4180:  INCFSZ FEF,W
4182:  BRA    4186
4184:  BRA    41BE
....................                MACDiscardTx(ps->TxBuffer); 
4186:  MOVLW  0F
4188:  ADDWF  xF9,W
418A:  MOVWF  FE9
418C:  MOVLW  00
418E:  ADDWFC xFA,W
4190:  MOVWF  FEA
4192:  MOVFF  FEF,200
4196:  CLRF   19
4198:  BTFSC  FF2.7
419A:  BSF    19.7
419C:  BCF    FF2.7
419E:  MOVFF  200,2AC
41A2:  MOVLB  0
41A4:  CALL   0004
41A8:  BTFSC  19.7
41AA:  BSF    FF2.7
....................                ps->TxBuffer = INVALID_BUFFER; 
41AC:  MOVLW  0F
41AE:  MOVLB  1
41B0:  ADDWF  xF9,W
41B2:  MOVWF  FE9
41B4:  MOVLW  00
41B6:  ADDWFC xFA,W
41B8:  MOVWF  FEA
41BA:  MOVLW  FF
41BC:  MOVWF  FEF
....................             } 
....................  
.................... #endif 
....................             // Request closure. 
....................             flags = FIN | ACK; 
41BE:  MOVLW  11
41C0:  MOVWF  xFF
....................             //DebugPrint("!"); 
....................  
....................             ps->smState = TCP_FIN_WAIT_1; 
41C2:  MOVFF  1F9,FE9
41C6:  MOVFF  1FA,FEA
41CA:  MOVLW  04
41CC:  MOVWF  FEF
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          } 
.................... #endif 
....................          break; 
41CE:  MOVLB  1
41D0:  BRA    4260
....................  
....................       case TCP_FIN_WAIT_1: 
....................          if (ps->RetryCount <= MAX_RETRY_COUNTS) { 
41D2:  MOVLW  1E
41D4:  MOVLB  1
41D6:  ADDWF  xF9,W
41D8:  MOVWF  FE9
41DA:  MOVLW  00
41DC:  ADDWFC xFA,W
41DE:  MOVWF  FEA
41E0:  MOVF   FEF,W
41E2:  SUBLW  03
41E4:  BNC   41EC
....................             // Send another FIN 
....................             flags = FIN; 
41E6:  MOVLW  01
41E8:  MOVWF  xFF
....................          } 
....................          else { 
41EA:  BRA    41FC
....................             // Close on our own, we can't seem to communicate 
....................             // with the remote node anymore 
....................             CloseSocket(ps); 
41EC:  MOVFF  1FA,23F
41F0:  MOVFF  1F9,23E
41F4:  MOVLB  0
41F6:  CALL   27F6
41FA:  MOVLB  1
....................          } 
....................          break; 
41FC:  BRA    4260
....................  
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_CLOSING: 
....................          // Close on our own, we can't seem to communicate 
....................          // with the remote node anymore 
....................          CloseSocket(ps); 
41FE:  MOVFF  1FA,23F
4202:  MOVFF  1F9,23E
4206:  CALL   27F6
....................          break; 
420A:  MOVLB  1
420C:  BRA    4260
....................  
....................       case TCP_TIME_WAIT: 
....................          // Wait around for a while (2MSL) and then goto closed state 
....................          CloseSocket(ps); 
420E:  MOVFF  1FA,23F
4212:  MOVFF  1F9,23E
4216:  CALL   27F6
....................          break; 
421A:  MOVLB  1
421C:  BRA    4260
....................  
....................       case TCP_CLOSE_WAIT: 
....................          flags = FIN; 
421E:  MOVLW  01
4220:  MOVLB  1
4222:  MOVWF  xFF
....................          ps->smState = TCP_LAST_ACK; 
4224:  MOVFF  1F9,FE9
4228:  MOVFF  1FA,FEA
422C:  MOVLW  09
422E:  MOVWF  FEF
....................          break; 
4230:  BRA    4260
....................  
....................       case TCP_LAST_ACK: 
....................          // Send some more FINs or close anyway 
....................          if (ps->RetryCount <= MAX_RETRY_COUNTS) 
4232:  MOVLW  1E
4234:  MOVLB  1
4236:  ADDWF  xF9,W
4238:  MOVWF  FE9
423A:  MOVLW  00
423C:  ADDWFC xFA,W
423E:  MOVWF  FEA
4240:  MOVF   FEF,W
4242:  SUBLW  03
4244:  BNC   424C
....................             flags = FIN; 
4246:  MOVLW  01
4248:  MOVWF  xFF
....................          else 
424A:  BRA    425C
....................             CloseSocket(ps); 
424C:  MOVFF  1FA,23F
4250:  MOVFF  1F9,23E
4254:  MOVLB  0
4256:  CALL   27F6
425A:  MOVLB  1
....................          break; 
425C:  BRA    4260
425E:  MOVLB  1
....................       } 
....................  
....................       if (flags) { 
4260:  MOVF   xFF,F
4262:  BTFSC  FD8.2
4264:  BRA    4388
....................          if (flags & ACK) 
4266:  BTFSS  xFF.4
4268:  BRA    4298
....................             seq = ps->SND_SEQ; 
426A:  MOVLW  16
426C:  ADDWF  xF9,W
426E:  MOVWF  FE9
4270:  MOVLW  00
4272:  ADDWFC xFA,W
4274:  MOVWF  FEA
4276:  MOVFF  FEF,00
427A:  MOVFF  FEC,01
427E:  MOVFF  FEC,02
4282:  MOVFF  FEC,03
4286:  MOVFF  03,1FE
428A:  MOVFF  02,1FD
428E:  MOVFF  01,1FC
4292:  MOVFF  00,1FB
....................          else { 
4296:  BRA    42DC
....................             //seq = ps->SND_SEQ++;  //currently buggy in CCS 
....................             seq = ps->SND_SEQ; 
4298:  MOVLW  16
429A:  ADDWF  xF9,W
429C:  MOVWF  FE9
429E:  MOVLW  00
42A0:  ADDWFC xFA,W
42A2:  MOVWF  FEA
42A4:  MOVFF  FEF,00
42A8:  MOVFF  FEC,01
42AC:  MOVFF  FEC,02
42B0:  MOVFF  FEC,03
42B4:  MOVFF  03,1FE
42B8:  MOVFF  02,1FD
42BC:  MOVFF  01,1FC
42C0:  MOVFF  00,1FB
....................             ps->SND_SEQ++; 
42C4:  MOVLW  16
42C6:  ADDWF  xF9,W
42C8:  MOVWF  FE9
42CA:  MOVLW  00
42CC:  ADDWFC xFA,W
42CE:  MOVWF  FEA
42D0:  MOVLW  01
42D2:  ADDWF  FEE,F
42D4:  MOVLW  00
42D6:  ADDWFC FEE,F
42D8:  ADDWFC FEE,F
42DA:  ADDWFC FED,F
....................          } 
....................  
....................          SendTCP(&ps->remote, ps->localPort, ps->remotePort, seq, 
....................                ps->SND_ACK, flags); 
42DC:  MOVLW  01
42DE:  ADDWF  xF9,W
42E0:  MOVWF  01
42E2:  MOVLW  00
42E4:  ADDWFC xFA,W
42E6:  MOVWF  03
42E8:  MOVFF  01,200
42EC:  MOVLB  2
42EE:  MOVWF  x01
42F0:  MOVLW  0B
42F2:  MOVLB  1
42F4:  ADDWF  xF9,W
42F6:  MOVWF  FE9
42F8:  MOVLW  00
42FA:  ADDWFC xFA,W
42FC:  MOVWF  FEA
42FE:  MOVFF  FEC,203
4302:  MOVF   FED,F
4304:  MOVFF  FEF,202
4308:  MOVLW  0D
430A:  ADDWF  xF9,W
430C:  MOVWF  FE9
430E:  MOVLW  00
4310:  ADDWFC xFA,W
4312:  MOVWF  FEA
4314:  MOVFF  FEC,205
4318:  MOVF   FED,F
431A:  MOVFF  FEF,204
431E:  MOVLW  1A
4320:  ADDWF  xF9,W
4322:  MOVWF  FE9
4324:  MOVLW  00
4326:  ADDWFC xFA,W
4328:  MOVWF  FEA
432A:  MOVFF  FEF,206
432E:  MOVFF  FEC,207
4332:  MOVFF  FEC,208
4336:  MOVFF  FEC,209
433A:  MOVFF  03,243
433E:  MOVFF  01,242
4342:  MOVFF  203,245
4346:  MOVFF  202,244
434A:  MOVFF  205,247
434E:  MOVFF  204,246
4352:  MOVFF  1FE,24B
4356:  MOVFF  1FD,24A
435A:  MOVFF  1FC,249
435E:  MOVFF  1FB,248
4362:  MOVFF  209,24F
4366:  MOVFF  208,24E
436A:  MOVFF  207,24D
436E:  MOVFF  206,24C
4372:  MOVFF  1FF,250
4376:  MOVLW  FF
4378:  MOVLB  2
437A:  MOVWF  x51
437C:  CLRF   x53
437E:  CLRF   x52
4380:  MOVLB  0
4382:  CALL   2D1C
4386:  MOVLB  1
....................       } 
....................  
....................       /*if (debugLastState != ps->smState) 
....................        { 
....................        debug_tcp("\r\nTCP TICK %u - ", s); 
....................        DebugTCPDisplayState(debugLastState); 
....................        debug_tcp(" -> "); 
....................        DebugTCPDisplayState(ps->smState); 
....................        }*/ 
....................    } 
4388:  INCF   xF4,F
438A:  BRA    3ED8
438C:  MOVLB  0
.................... } 
438E:  GOTO   4562 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPProcess(NODE_INFO* remote, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  len         - Total length of TCP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPProcess(NODE_INFO *remote, IP_ADDR *localIP, WORD len) { 
....................    TCP_HEADER TCPHeader; 
....................    PSEUDO_HEADER pseudoHeader; 
....................    TCP_SOCKET socket; 
....................    WORD_VAL checksum1; 
....................    WORD_VAL checksum2; 
....................    BYTE optionsSize; 
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress = remote->IPAddr; 
*
3A3C:  MOVLW  06
3A3E:  MOVLB  1
3A40:  ADDWF  xF4,W
3A42:  MOVWF  FE9
3A44:  MOVLW  00
3A46:  ADDWFC xF5,W
3A48:  MOVWF  FEA
3A4A:  MOVFF  FEF,00
3A4E:  MOVFF  FEC,01
3A52:  MOVFF  FEC,02
3A56:  MOVFF  FEC,03
3A5A:  MOVFF  03,211
3A5E:  MOVFF  02,210
3A62:  MOVFF  01,20F
3A66:  MOVFF  00,20E
....................    pseudoHeader.DestAddress = *localIP; 
3A6A:  MOVFF  1F6,FE9
3A6E:  MOVFF  1F7,FEA
3A72:  MOVFF  FEF,00
3A76:  MOVFF  FEC,01
3A7A:  MOVFF  FEC,02
3A7E:  MOVFF  FEC,03
3A82:  MOVFF  03,215
3A86:  MOVFF  02,214
3A8A:  MOVFF  01,213
3A8E:  MOVFF  00,212
....................    pseudoHeader.Zero = 0x0; 
3A92:  MOVLB  2
3A94:  CLRF   x16
....................    pseudoHeader.Protocol = IP_PROT_TCP; 
3A96:  MOVLW  06
3A98:  MOVWF  x17
....................    pseudoHeader.TCPLength = len; 
3A9A:  MOVFF  1F9,219
3A9E:  MOVFF  1F8,218
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
3AA2:  MOVFF  219,29A
3AA6:  MOVFF  218,299
3AAA:  MOVLB  0
3AAC:  CALL   118C
3AB0:  MOVFF  02,219
3AB4:  MOVFF  01,218
....................  
....................    checksum1.Val = ~CalcIPChecksum((BYTE*) &pseudoHeader, 
....................          sizeof(pseudoHeader)); 
3AB8:  MOVLW  02
3ABA:  MOVLB  2
3ABC:  MOVWF  x21
3ABE:  MOVLW  0E
3AC0:  MOVFF  221,27D
3AC4:  MOVWF  x7C
3AC6:  CLRF   x7F
3AC8:  MOVLW  0C
3ACA:  MOVWF  x7E
3ACC:  MOVLB  0
3ACE:  CALL   209E
3AD2:  MOVFF  01,21B
3AD6:  MOVLB  2
3AD8:  COMF   x1B,F
3ADA:  MOVFF  02,21C
3ADE:  COMF   x1C,F
....................  
....................    // Now calculate TCP packet checksum in NIC RAM - should match 
....................    // pesudo header checksum 
....................    checksum2.Val = CalcIPBufferChecksum(len); 
3AE0:  MOVFF  1F9,27B
3AE4:  MOVFF  1F8,27A
3AE8:  MOVLB  0
3AEA:  CALL   21D8
3AEE:  MOVFF  02,21E
3AF2:  MOVFF  01,21D
....................  
....................    // Compare checksums.  Note that the endianness is different. 
....................    if (checksum1.v[0] != checksum2.v[1] || checksum1.v[1] != checksum2.v[0]) { 
3AF6:  MOVLB  2
3AF8:  MOVF   x1E,W
3AFA:  SUBWF  x1B,W
3AFC:  BNZ   3B04
3AFE:  MOVF   x1D,W
3B00:  SUBWF  x1C,W
3B02:  BZ    3B12
....................       MACDiscardRx(); 
3B04:  MOVLB  0
3B06:  CALL   1070
....................       return TRUE; 
3B0A:  MOVLW  01
3B0C:  MOVWF  01
3B0E:  BRA    3BF6
3B10:  MOVLB  2
....................    } 
....................  
....................    // Retrieve TCP header. 
....................    IPSetRxBuffer(0); 
3B12:  CLRF   x22
3B14:  CLRF   x21
3B16:  MOVLB  0
3B18:  CALL   23A4
....................    MACGetArray((BYTE*) &TCPHeader, sizeof(TCPHeader)); 
3B1C:  MOVLW  01
3B1E:  MOVLB  2
3B20:  MOVWF  x21
3B22:  MOVLW  FA
3B24:  MOVFF  221,289
3B28:  MOVWF  x88
3B2A:  CLRF   x8B
3B2C:  MOVLW  14
3B2E:  MOVWF  x8A
3B30:  MOVLB  0
3B32:  CALL   1110
....................    SwapTCPHeader(&TCPHeader); 
3B36:  MOVLW  01
3B38:  MOVLB  2
3B3A:  MOVWF  x7B
3B3C:  MOVLW  FA
3B3E:  MOVWF  x7A
3B40:  MOVLB  0
3B42:  CALL   23E0
....................  
....................    // Skip over options and retrieve all data bytes. 
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2) - sizeof(TCPHeader)); 
3B46:  MOVLB  2
3B48:  SWAPF  x06,W
3B4A:  ANDLW  0F
3B4C:  MOVWF  00
3B4E:  RLCF   00,W
3B50:  MOVWF  x20
3B52:  RLCF   x20,F
3B54:  MOVLW  FC
3B56:  ANDWF  x20,F
3B58:  MOVLW  14
3B5A:  SUBWF  x20,W
3B5C:  MOVWF  x1F
....................    len = len - optionsSize - sizeof(TCPHeader); 
3B5E:  MOVF   x1F,W
3B60:  MOVLB  1
3B62:  SUBWF  xF8,W
3B64:  MOVLB  2
3B66:  MOVWF  x20
3B68:  MOVLW  00
3B6A:  MOVLB  1
3B6C:  SUBWFB xF9,W
3B6E:  MOVLB  2
3B70:  MOVWF  x21
3B72:  MOVLW  14
3B74:  SUBWF  x20,W
3B76:  MOVLB  1
3B78:  MOVWF  xF8
3B7A:  MOVLW  00
3B7C:  MOVLB  2
3B7E:  SUBWFB x21,W
3B80:  MOVLB  1
3B82:  MOVWF  xF9
....................  
....................    // Position packet read pointer to start of data area. 
....................    IPSetRxBuffer((TCPHeader.DataOffset.Val << 2)); 
3B84:  MOVLB  2
3B86:  SWAPF  x06,W
3B88:  ANDLW  0F
3B8A:  MOVWF  00
3B8C:  RLCF   00,W
3B8E:  MOVWF  x20
3B90:  RLCF   x20,F
3B92:  MOVLW  FC
3B94:  ANDWF  x20,F
3B96:  CLRF   x22
3B98:  MOVFF  220,221
3B9C:  MOVLB  0
3B9E:  CALL   23A4
....................  
....................    // Find matching socket. 
....................    socket = FindMatching_TCP_Socket(&TCPHeader, remote); 
3BA2:  MOVLW  01
3BA4:  MOVLB  2
3BA6:  MOVWF  x21
3BA8:  MOVLW  FA
3BAA:  MOVWF  x20
3BAC:  MOVFF  1F5,223
3BB0:  MOVFF  1F4,222
3BB4:  MOVLB  0
3BB6:  GOTO   2606
3BBA:  MOVFF  01,21A
....................    if (socket != INVALID_SOCKET) { 
3BBE:  MOVLB  2
3BC0:  MOVF   x1A,W
3BC2:  SUBLW  FE
3BC4:  BZ    3BEC
....................       HandleTCPSeg(socket, remote, &TCPHeader, len); 
3BC6:  MOVFF  21A,220
3BCA:  MOVFF  1F5,222
3BCE:  MOVFF  1F4,221
3BD2:  MOVLW  01
3BD4:  MOVWF  x24
3BD6:  MOVLW  FA
3BD8:  MOVWF  x23
3BDA:  MOVFF  1F9,226
3BDE:  MOVFF  1F8,225
3BE2:  MOVLB  0
3BE4:  GOTO   2F4A
....................    } 
....................    else { 
3BE8:  BRA    3BF2
3BEA:  MOVLB  2
....................       // If this is an unknown socket, or we don't have any 
....................       // listening sockets available, discard it we can't 
....................       // process it right now 
....................       MACDiscardRx(); 
3BEC:  MOVLB  0
3BEE:  CALL   1070
....................  
.................... //      // Send a RESET to the remote node is it knows that we 
.................... //      // are not available 
.................... //      TCPHeader.AckNumber += len; 
.................... //      if( TCPHeader.Flags.bits.flagSYN || 
.................... //         TCPHeader.Flags.bits.flagFIN ) 
.................... //         TCPHeader.AckNumber++; 
.................... // 
.................... //      SendTCP(remote, 
.................... //         TCPHeader.DestPort, 
.................... //         TCPHeader.SourcePort, 
.................... //         TCPHeader.AckNumber, 
.................... //         TCPHeader.SeqNumber, 
.................... //         RST); 
....................    } 
....................  
....................    return TRUE; 
3BF2:  MOVLW  01
3BF4:  MOVWF  01
.................... } 
3BF6:  GOTO   44A8 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        static void TransmitTCP(NODE_INFO* remote 
....................  *                                          TCP_PORT localPort, 
....................  *                                          TCP_PORT remotePort, 
....................  *                                          DWORD seq, 
....................  *                                          DWORD ack, 
....................  *                                          BYTE flags, 
....................  *                                          BUFFER buffer, 
....................  *                                          WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  localPort   - Source port number 
....................  *                  remotePort  - Destination port number 
....................  *                  seq         - Segment sequence number 
....................  *                  ack         - Segment acknowledge number 
....................  *                  flags       - Segment flags 
....................  *                  buffer      - Buffer to which this segment 
....................  *                                is to be transmitted 
....................  *                  len         - Total data length for this segment. 
....................  * 
....................  * Output:          A TCP segment is assembled and put to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void TransmitTCP(NODE_INFO *remote, TCP_PORT localPort, 
....................       TCP_PORT remotePort, DWORD tseq, DWORD tack, BYTE flags, BUFFER buff, 
....................       WORD len) { 
....................    WORD_VAL checkSum; 
....................    TCP_HEADER header; 
....................    TCP_OPTIONS options; 
....................    PSEUDO_HEADER pseudoHeader; 
....................  
....................    /* 
....................    debug_tcp("\r\n\nTCP OUT => LP:%LX RP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X", 
....................          localPort, 
....................          remotePort, 
....................          tseq, 
....................          tack, 
....................          len, 
....................          flags 
....................    ); 
....................    */ 
....................  
....................    //  Make sure that this Tx buffer isn't currently being transmitted 
....................    while (!IPIsTxReady(TRUE)) 
....................       ;   //TODO: This may need to be conditionally false 
*
2D1C:  MOVLW  01
2D1E:  MOVLB  2
2D20:  MOVWF  x7A
2D22:  MOVLB  0
2D24:  RCALL  2906
2D26:  MOVF   01,F
2D28:  BZ    2D1C
....................  
....................    // Obtain an AutoFree buffer if this packet is a control packet 
....................    // only (contains no application data in an already allocated 
....................    // buffer) 
....................    if (buff == INVALID_BUFFER) 
2D2A:  MOVLB  2
2D2C:  INCFSZ x51,W
2D2E:  BRA    2D40
....................       buff = MACGetTxBuffer(TRUE); 
2D30:  MOVLW  01
2D32:  MOVWF  x7A
2D34:  MOVLB  0
2D36:  CALL   14D4
2D3A:  MOVFF  01,251
2D3E:  MOVLB  2
....................  
....................    if (buff == INVALID_BUFFER) 
2D40:  INCFSZ x51,W
2D42:  BRA    2D46
....................       return; 
2D44:  BRA    2F46
....................  
....................    IPSetTxBuffer(buff, 0); 
2D46:  MOVFF  251,293
2D4A:  CLRF   x95
2D4C:  MOVLW  14
2D4E:  MOVWF  x94
2D50:  MOVLB  0
2D52:  CALL   14FC
....................  
....................    header.SourcePort = localPort; 
2D56:  MOVFF  245,257
2D5A:  MOVFF  244,256
....................    header.DestPort = remotePort; 
2D5E:  MOVFF  247,259
2D62:  MOVFF  246,258
....................    header.SeqNumber = tseq; 
2D66:  MOVFF  24B,25D
2D6A:  MOVFF  24A,25C
2D6E:  MOVFF  249,25B
2D72:  MOVFF  248,25A
....................    header.AckNumber = tack; 
2D76:  MOVFF  24F,261
2D7A:  MOVFF  24E,260
2D7E:  MOVFF  24D,25F
2D82:  MOVFF  24C,25E
....................    header.Flags.bits.Reserved2 = 0; 
2D86:  MOVLW  3F
2D88:  MOVLB  2
2D8A:  ANDWF  x63,W
2D8C:  MOVWF  x63
....................    header.DataOffset.Reserved3 = 0; 
2D8E:  MOVLW  F0
2D90:  ANDWF  x62,W
2D92:  MOVWF  x62
....................    header.Flags.b = flags; 
2D94:  MOVFF  250,263
....................    // Receive window = MAC Free buffer size - TCP header (20) - IP header (20) 
....................    //                  - ETHERNET header (14 if using NIC) . 
....................    header.Window = MACGetFreeRxSize(); 
2D98:  MOVLB  0
2D9A:  BRA    292A
2D9C:  MOVFF  02,265
2DA0:  MOVFF  01,264
.................... #if STACK_USE_SLIP 
....................    /* 
....................     * Limit one segment at a time from remote host. 
....................     * This limit increases overall throughput as remote host does not 
....................     * flood us with packets and later retry with significant delay. 
....................     */ 
....................    if ( header.Window >= MAC_RX_BUFFER_SIZE ) 
....................    header.Window = MAC_RX_BUFFER_SIZE; 
....................  
....................    else if ( header.Window > 54 ) 
....................    { 
....................       header.Window -= 54; 
....................    } 
....................    else 
....................    header.Window = 0; 
.................... #else 
....................    if (header.Window > 40) { 
2DA4:  MOVLB  2
2DA6:  MOVF   x65,F
2DA8:  BNZ   2DB0
2DAA:  MOVF   x64,W
2DAC:  SUBLW  28
2DAE:  BC    2DBA
....................       header.Window -= 40; 
2DB0:  MOVLW  28
2DB2:  SUBWF  x64,F
2DB4:  MOVLW  00
2DB6:  SUBWFB x65,F
....................    } 
....................    else 
2DB8:  BRA    2DBE
....................       header.Window = 0; 
2DBA:  CLRF   x65
2DBC:  CLRF   x64
.................... #endif 
....................  
....................    header.Checksum = 0; 
2DBE:  CLRF   x67
2DC0:  CLRF   x66
....................    header.UrgentPointer = 0; 
2DC2:  CLRF   x69
2DC4:  CLRF   x68
....................  
....................    SwapTCPHeader(&header); 
2DC6:  MOVLW  02
2DC8:  MOVWF  x7B
2DCA:  MOVLW  56
2DCC:  MOVWF  x7A
2DCE:  MOVLB  0
2DD0:  CALL   23E0
....................  
....................    len += sizeof(header); 
2DD4:  MOVLW  14
2DD6:  MOVLB  2
2DD8:  ADDWF  x52,F
2DDA:  MOVLW  00
2DDC:  ADDWFC x53,F
....................  
....................    if (flags & SYN) { 
2DDE:  BTFSS  x50.1
2DE0:  BRA    2E00
....................       len += sizeof(options); 
2DE2:  MOVLW  04
2DE4:  ADDWF  x52,F
2DE6:  MOVLW  00
2DE8:  ADDWFC x53,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE; 
2DEA:  MOVLW  02
2DEC:  MOVWF  x6A
....................       options.Length = 0x04; 
2DEE:  MOVLW  04
2DF0:  MOVWF  x6B
....................  
....................       // Load MSS in already swapped order. 
....................       options.MaxSegSize.v[0] = (MAC_RX_BUFFER_SIZE >> 8); // 0x05; 
2DF2:  MOVWF  x6C
....................       options.MaxSegSize.v[1] = (MAC_RX_BUFFER_SIZE & 0xff); // 0xb4; 
2DF4:  CLRF   x6D
....................  
....................       header.DataOffset.Val = (sizeof(header) + sizeof(options)) >> 2; 
2DF6:  MOVLW  0F
2DF8:  ANDWF  x62,W
2DFA:  IORLW  60
2DFC:  MOVWF  x62
....................    } 
....................    else 
2DFE:  BRA    2E08
....................       header.DataOffset.Val = sizeof(header) >> 2; 
2E00:  MOVLW  0F
2E02:  ANDWF  x62,W
2E04:  IORLW  50
2E06:  MOVWF  x62
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress = AppConfig.MyIPAddr; 
2E08:  MOVFF  46,271
2E0C:  MOVFF  45,270
2E10:  MOVFF  44,26F
2E14:  MOVFF  43,26E
....................    pseudoHeader.DestAddress = remote->IPAddr; 
2E18:  MOVLW  06
2E1A:  ADDWF  x42,W
2E1C:  MOVWF  FE9
2E1E:  MOVLW  00
2E20:  ADDWFC x43,W
2E22:  MOVWF  FEA
2E24:  MOVFF  FEF,00
2E28:  MOVFF  FEC,01
2E2C:  MOVFF  FEC,02
2E30:  MOVFF  FEC,03
2E34:  MOVFF  03,275
2E38:  MOVFF  02,274
2E3C:  MOVFF  01,273
2E40:  MOVFF  00,272
....................    pseudoHeader.Zero = 0x0; 
2E44:  CLRF   x76
....................    pseudoHeader.Protocol = IP_PROT_TCP; 
2E46:  MOVLW  06
2E48:  MOVWF  x77
....................    pseudoHeader.TCPLength = len; 
2E4A:  MOVFF  253,279
2E4E:  MOVFF  252,278
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
2E52:  MOVFF  279,29A
2E56:  MOVFF  278,299
2E5A:  MOVLB  0
2E5C:  CALL   118C
2E60:  MOVFF  02,279
2E64:  MOVFF  01,278
....................  
....................    header.Checksum = ~CalcIPChecksum((BYTE*) &pseudoHeader, 
....................          sizeof(pseudoHeader)); 
2E68:  MOVLW  02
2E6A:  MOVLB  2
2E6C:  MOVWF  x7B
2E6E:  MOVLW  6E
2E70:  MOVFF  27B,27D
2E74:  MOVWF  x7C
2E76:  CLRF   x7F
2E78:  MOVLW  0C
2E7A:  MOVWF  x7E
2E7C:  MOVLB  0
2E7E:  CALL   209E
2E82:  MOVFF  01,266
2E86:  MOVLB  2
2E88:  COMF   x66,F
2E8A:  MOVFF  02,267
2E8E:  COMF   x67,F
....................    checkSum.Val = header.Checksum; 
2E90:  MOVFF  267,255
2E94:  MOVFF  266,254
....................  
....................    // Write IP header. 
....................    IPPutHeader(remote, IP_PROT_TCP, len); 
2E98:  MOVFF  243,27B
2E9C:  MOVFF  242,27A
2EA0:  MOVLW  06
2EA2:  MOVWF  x7C
2EA4:  MOVFF  253,27E
2EA8:  MOVFF  252,27D
2EAC:  MOVLB  0
2EAE:  RCALL  2BEC
....................    IPPutArray((BYTE* )&header, sizeof(header)); 
2EB0:  MOVLW  02
2EB2:  MOVLB  2
2EB4:  MOVWF  x7B
2EB6:  MOVLW  56
2EB8:  MOVFF  27B,29F
2EBC:  MOVWF  x9E
2EBE:  CLRF   xA1
2EC0:  MOVLW  14
2EC2:  MOVWF  xA0
2EC4:  MOVLB  0
2EC6:  CALL   15F8
....................  
....................    if (flags & SYN) 
2ECA:  MOVLB  2
2ECC:  BTFSS  x50.1
2ECE:  BRA    2EEA
....................       IPPutArray((BYTE* )&options, sizeof(options)); 
2ED0:  MOVLW  02
2ED2:  MOVWF  x7B
2ED4:  MOVLW  6A
2ED6:  MOVFF  27B,29F
2EDA:  MOVWF  x9E
2EDC:  CLRF   xA1
2EDE:  MOVLW  04
2EE0:  MOVWF  xA0
2EE2:  MOVLB  0
2EE4:  CALL   15F8
2EE8:  MOVLB  2
....................  
....................    IPSetTxBuffer(buff, 0); 
2EEA:  MOVFF  251,293
2EEE:  CLRF   x95
2EF0:  MOVLW  14
2EF2:  MOVWF  x94
2EF4:  MOVLB  0
2EF6:  CALL   14FC
....................  
....................    checkSum.Val = CalcIPBufferChecksum(len); 
2EFA:  MOVFF  253,27B
2EFE:  MOVFF  252,27A
2F02:  CALL   21D8
2F06:  MOVFF  02,255
2F0A:  MOVFF  01,254
....................  
....................    // Update the checksum. 
....................    IPSetTxBuffer(buff, 16); 
2F0E:  MOVFF  251,293
2F12:  MOVLB  2
2F14:  CLRF   x95
2F16:  MOVLW  24
2F18:  MOVWF  x94
2F1A:  MOVLB  0
2F1C:  CALL   14FC
....................    MACPut(checkSum.v[1]); 
2F20:  MOVFF  255,29D
2F24:  CALL   15C2
....................    MACPut(checkSum.v[0]); 
2F28:  MOVFF  254,29D
2F2C:  CALL   15C2
....................    MACSetTxBuffer(buff, 0); 
2F30:  MOVFF  251,293
2F34:  MOVLB  2
2F36:  CLRF   x95
2F38:  CLRF   x94
2F3A:  MOVLB  0
2F3C:  CALL   14FC
....................  
....................    MACFlush(); 
2F40:  CALL   1758
2F44:  MOVLB  2
....................  
.................... #if !TCP_NO_WAIT_FOR_ACK /*&& !defined(DEBUG)*/ 
....................    // If we send the packet again, the remote node might think that we timed 
....................    // out and retransmitted.  It could thus immediately send back an ACK and 
....................    // dramatically improve throuput. 
....................    //while(!IPIsTxReady(TRUE)); 
....................    //MACFlush(); 
.................... #endif 
.................... } 
2F46:  MOVLB  0
2F48:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................  *                                      NODE_INFO* remote) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           h           - TCP Header to be matched against. 
....................  *                  remote      - Node who sent this header. 
....................  * 
....................  * Output:          A socket that matches with given header and remote 
....................  *                  node is searched. 
....................  *                  If such socket is found, its index is returned 
....................  *                  else INVALID_SOCKET is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, NODE_INFO *remote) { 
....................    SOCKET_INFO *ps; 
....................    TCP_SOCKET s; 
....................    TCP_SOCKET partialMatch; 
....................  
....................    partialMatch = INVALID_SOCKET; 
*
2606:  MOVLW  FE
2608:  MOVLB  2
260A:  MOVWF  x27
....................  
....................    for (s = 0; s < MAX_SOCKETS; s++) { 
260C:  CLRF   x26
260E:  MOVF   x26,W
2610:  SUBLW  04
2612:  BTFSS  FD8.0
2614:  BRA    270A
....................       ps = &TCB[s]; 
2616:  MOVF   x26,W
2618:  MULLW  24
261A:  MOVF   FF3,W
261C:  CLRF   03
261E:  ADDLW  8A
2620:  MOVWF  01
2622:  MOVLW  00
2624:  ADDWFC 03,F
2626:  MOVFF  01,224
262A:  MOVFF  03,225
....................  
....................       if (ps->smState != TCP_CLOSED) { 
262E:  MOVFF  224,FE9
2632:  MOVFF  225,FEA
2636:  MOVF   FEF,W
2638:  SUBLW  0A
263A:  BZ    2706
....................          if (ps->localPort == h->DestPort) { 
263C:  MOVLW  0B
263E:  ADDWF  x24,W
2640:  MOVWF  FE9
2642:  MOVLW  00
2644:  ADDWFC x25,W
2646:  MOVWF  FEA
2648:  MOVFF  FEC,229
264C:  MOVF   FED,F
264E:  MOVFF  FEF,228
2652:  MOVLW  02
2654:  ADDWF  x20,W
2656:  MOVWF  FE9
2658:  MOVLW  00
265A:  ADDWFC x21,W
265C:  MOVWF  FEA
265E:  MOVFF  FEC,03
2662:  MOVF   FED,F
2664:  MOVF   FEF,W
2666:  SUBWF  x28,W
2668:  BNZ   2706
266A:  MOVF   03,W
266C:  SUBWF  x29,W
266E:  BNZ   2706
....................             if (ps->smState == TCP_LISTEN) 
2670:  MOVFF  224,FE9
2674:  MOVFF  225,FEA
2678:  MOVF   FEF,F
267A:  BNZ   2680
....................                partialMatch = s; 
267C:  MOVFF  226,227
....................  
....................             if (ps->remotePort == h->SourcePort 
....................                   && ps->remote.IPAddr.Val == remote->IPAddr.Val) { 
2680:  MOVLW  0D
2682:  ADDWF  x24,W
2684:  MOVWF  FE9
2686:  MOVLW  00
2688:  ADDWFC x25,W
268A:  MOVWF  FEA
268C:  MOVFF  FEC,229
2690:  MOVF   FED,F
2692:  MOVFF  FEF,228
2696:  MOVFF  220,FE9
269A:  MOVFF  221,FEA
269E:  MOVFF  FEC,03
26A2:  MOVF   FED,F
26A4:  MOVF   FEF,W
26A6:  SUBWF  x28,W
26A8:  BNZ   2706
26AA:  MOVF   03,W
26AC:  SUBWF  x29,W
26AE:  BNZ   2706
26B0:  MOVLW  07
26B2:  ADDWF  x24,W
26B4:  MOVWF  FE9
26B6:  MOVLW  00
26B8:  ADDWFC x25,W
26BA:  MOVWF  FEA
26BC:  MOVFF  FEF,228
26C0:  MOVFF  FEC,229
26C4:  MOVFF  FEC,22A
26C8:  MOVFF  FEC,22B
26CC:  MOVLW  06
26CE:  ADDWF  x22,W
26D0:  MOVWF  FE9
26D2:  MOVLW  00
26D4:  ADDWFC x23,W
26D6:  MOVWF  FEA
26D8:  MOVFF  FEF,00
26DC:  MOVFF  FEC,01
26E0:  MOVFF  FEC,02
26E4:  MOVFF  FEC,03
26E8:  MOVF   00,W
26EA:  SUBWF  x28,W
26EC:  BNZ   2706
26EE:  MOVF   01,W
26F0:  SUBWF  x29,W
26F2:  BNZ   2706
26F4:  MOVF   02,W
26F6:  SUBWF  x2A,W
26F8:  BNZ   2706
26FA:  MOVF   03,W
26FC:  SUBWF  x2B,W
26FE:  BNZ   2706
....................                return s; 
2700:  MOVFF  226,01
2704:  BRA    27F0
....................             } 
....................          } 
....................       } 
....................    } 
2706:  INCF   x26,F
2708:  BRA    260E
....................  
....................    // We are not listening on this port 
....................    if (partialMatch == INVALID_SOCKET) 
270A:  MOVF   x27,W
270C:  SUBLW  FE
270E:  BNZ   2716
....................       return INVALID_SOCKET; 
2710:  MOVLW  FE
2712:  MOVWF  01
2714:  BRA    27F0
....................  
....................    // Copy the remote node IP/MAC address and source TCP port 
....................    // number into our TCB and return this socket to the caller 
....................    ps = &TCB[partialMatch]; 
2716:  MOVF   x27,W
2718:  MULLW  24
271A:  MOVF   FF3,W
271C:  CLRF   03
271E:  ADDLW  8A
2720:  MOVWF  01
2722:  MOVLW  00
2724:  ADDWFC 03,F
2726:  MOVFF  01,224
272A:  MOVFF  03,225
....................    memcpy((void*) &ps->remote, (void*) remote, sizeof(*remote)); 
272E:  MOVLW  01
2730:  ADDWF  x24,W
2732:  MOVWF  01
2734:  MOVLW  00
2736:  ADDWFC x25,W
2738:  MOVWF  03
273A:  MOVFF  01,228
273E:  MOVWF  x29
2740:  MOVWF  FEA
2742:  MOVFF  01,FE9
2746:  MOVFF  223,FE2
274A:  MOVFF  222,FE1
274E:  MOVLW  0A
2750:  MOVWF  01
2752:  MOVFF  FE6,FEE
2756:  DECFSZ 01,F
2758:  BRA    2752
....................    ps->remotePort = h->SourcePort; 
275A:  MOVLW  0D
275C:  ADDWF  x24,W
275E:  MOVWF  01
2760:  MOVLW  00
2762:  ADDWFC x25,W
2764:  MOVFF  220,FE9
2768:  MOVFF  221,FEA
276C:  MOVFF  FEC,03
2770:  MOVF   FED,F
2772:  MOVFF  FEF,22A
2776:  MOVWF  FEA
2778:  MOVFF  01,FE9
277C:  MOVFF  03,FEC
2780:  MOVF   FED,F
2782:  MOVFF  22A,FEF
....................    ps->Flags.bIsGetReady = FALSE; 
2786:  MOVLW  23
2788:  ADDWF  x24,W
278A:  MOVWF  FE9
278C:  MOVLW  00
278E:  ADDWFC x25,W
2790:  MOVWF  FEA
2792:  BCF    FEF.3
....................    if (ps->TxBuffer != INVALID_BUFFER) { 
2794:  MOVLW  0F
2796:  ADDWF  x24,W
2798:  MOVWF  FE9
279A:  MOVLW  00
279C:  ADDWFC x25,W
279E:  MOVWF  FEA
27A0:  INCFSZ FEF,W
27A2:  BRA    27A6
27A4:  BRA    27DE
....................       MACDiscardTx(ps->TxBuffer); 
27A6:  MOVLW  0F
27A8:  ADDWF  x24,W
27AA:  MOVWF  FE9
27AC:  MOVLW  00
27AE:  ADDWFC x25,W
27B0:  MOVWF  FEA
27B2:  MOVFF  FEF,228
27B6:  CLRF   19
27B8:  BTFSC  FF2.7
27BA:  BSF    19.7
27BC:  BCF    FF2.7
27BE:  MOVFF  228,2AC
27C2:  MOVLB  0
27C4:  CALL   0004
27C8:  BTFSC  19.7
27CA:  BSF    FF2.7
....................       ps->TxBuffer = INVALID_BUFFER; 
27CC:  MOVLW  0F
27CE:  MOVLB  2
27D0:  ADDWF  x24,W
27D2:  MOVWF  FE9
27D4:  MOVLW  00
27D6:  ADDWFC x25,W
27D8:  MOVWF  FEA
27DA:  MOVLW  FF
27DC:  MOVWF  FEF
....................    } 
....................    ps->Flags.bIsPutReady = TRUE; 
27DE:  MOVLW  23
27E0:  ADDWF  x24,W
27E2:  MOVWF  FE9
27E4:  MOVLW  00
27E6:  ADDWFC x25,W
27E8:  MOVWF  FEA
27EA:  BSF    FEF.1
....................  
....................    return partialMatch; 
27EC:  MOVFF  227,01
.................... } 
27F0:  MOVLB  0
27F2:  GOTO   3BBA (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapTCPHeader(TCP_HEADER* header) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           header      - TCP Header to be swapped. 
....................  * 
....................  * Output:          Given header is swapped. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapTCPHeader(TCP_HEADER* header) { 
....................    header->SourcePort = swaps(header->SourcePort); 
*
23E0:  MOVLB  2
23E2:  MOVFF  27A,01
23E6:  MOVFF  27B,03
23EA:  MOVFF  27A,27C
23EE:  MOVFF  27B,27D
23F2:  MOVFF  27A,FE9
23F6:  MOVFF  27B,FEA
23FA:  MOVFF  FEC,27F
23FE:  MOVF   FED,F
2400:  MOVFF  FEF,27E
2404:  MOVFF  27F,29A
2408:  MOVFF  27E,299
240C:  MOVLB  0
240E:  CALL   118C
2412:  MOVFF  27D,FEA
2416:  MOVFF  27C,FE9
241A:  MOVFF  02,FEC
241E:  MOVF   FED,F
2420:  MOVFF  01,FEF
....................    header->DestPort = swaps(header->DestPort); 
2424:  MOVLW  02
2426:  MOVLB  2
2428:  ADDWF  x7A,W
242A:  MOVWF  01
242C:  MOVLW  00
242E:  ADDWFC x7B,W
2430:  MOVWF  03
2432:  MOVFF  01,27C
2436:  MOVWF  x7D
2438:  MOVLW  02
243A:  ADDWF  x7A,W
243C:  MOVWF  FE9
243E:  MOVLW  00
2440:  ADDWFC x7B,W
2442:  MOVWF  FEA
2444:  MOVFF  FEC,27F
2448:  MOVF   FED,F
244A:  MOVFF  FEF,27E
244E:  MOVFF  27F,29A
2452:  MOVFF  27E,299
2456:  MOVLB  0
2458:  CALL   118C
245C:  MOVFF  27D,FEA
2460:  MOVFF  27C,FE9
2464:  MOVFF  02,FEC
2468:  MOVF   FED,F
246A:  MOVFF  01,FEF
....................    header->SeqNumber = swapl(header->SeqNumber); 
246E:  MOVLW  04
2470:  MOVLB  2
2472:  ADDWF  x7A,W
2474:  MOVWF  01
2476:  MOVLW  00
2478:  ADDWFC x7B,W
247A:  MOVWF  03
247C:  MOVFF  01,27C
2480:  MOVWF  x7D
2482:  MOVLW  04
2484:  ADDWF  x7A,W
2486:  MOVWF  FE9
2488:  MOVLW  00
248A:  ADDWFC x7B,W
248C:  MOVWF  FEA
248E:  MOVFF  FEF,27E
2492:  MOVFF  FEC,27F
2496:  MOVFF  FEC,280
249A:  MOVFF  FEC,281
249E:  MOVFF  281,285
24A2:  MOVFF  280,284
24A6:  MOVFF  27F,283
24AA:  MOVFF  27E,282
24AE:  MOVLB  0
24B0:  RCALL  23BE
24B2:  MOVFF  27D,FEA
24B6:  MOVFF  27C,FE9
24BA:  MOVFF  00,FEF
24BE:  MOVFF  01,FEC
24C2:  MOVFF  02,FEC
24C6:  MOVFF  03,FEC
....................    header->AckNumber = swapl(header->AckNumber); 
24CA:  MOVLW  08
24CC:  MOVLB  2
24CE:  ADDWF  x7A,W
24D0:  MOVWF  01
24D2:  MOVLW  00
24D4:  ADDWFC x7B,W
24D6:  MOVWF  03
24D8:  MOVFF  01,27C
24DC:  MOVWF  x7D
24DE:  MOVLW  08
24E0:  ADDWF  x7A,W
24E2:  MOVWF  FE9
24E4:  MOVLW  00
24E6:  ADDWFC x7B,W
24E8:  MOVWF  FEA
24EA:  MOVFF  FEF,27E
24EE:  MOVFF  FEC,27F
24F2:  MOVFF  FEC,280
24F6:  MOVFF  FEC,281
24FA:  MOVFF  281,285
24FE:  MOVFF  280,284
2502:  MOVFF  27F,283
2506:  MOVFF  27E,282
250A:  MOVLB  0
250C:  RCALL  23BE
250E:  MOVFF  27D,FEA
2512:  MOVFF  27C,FE9
2516:  MOVFF  00,FEF
251A:  MOVFF  01,FEC
251E:  MOVFF  02,FEC
2522:  MOVFF  03,FEC
....................    header->Window = swaps(header->Window); 
2526:  MOVLW  0E
2528:  MOVLB  2
252A:  ADDWF  x7A,W
252C:  MOVWF  01
252E:  MOVLW  00
2530:  ADDWFC x7B,W
2532:  MOVWF  03
2534:  MOVFF  01,27C
2538:  MOVWF  x7D
253A:  MOVLW  0E
253C:  ADDWF  x7A,W
253E:  MOVWF  FE9
2540:  MOVLW  00
2542:  ADDWFC x7B,W
2544:  MOVWF  FEA
2546:  MOVFF  FEC,27F
254A:  MOVF   FED,F
254C:  MOVFF  FEF,27E
2550:  MOVFF  27F,29A
2554:  MOVFF  27E,299
2558:  MOVLB  0
255A:  CALL   118C
255E:  MOVFF  27D,FEA
2562:  MOVFF  27C,FE9
2566:  MOVFF  02,FEC
256A:  MOVF   FED,F
256C:  MOVFF  01,FEF
....................    header->Checksum = swaps(header->Checksum); 
2570:  MOVLW  10
2572:  MOVLB  2
2574:  ADDWF  x7A,W
2576:  MOVWF  01
2578:  MOVLW  00
257A:  ADDWFC x7B,W
257C:  MOVWF  03
257E:  MOVFF  01,27C
2582:  MOVWF  x7D
2584:  MOVLW  10
2586:  ADDWF  x7A,W
2588:  MOVWF  FE9
258A:  MOVLW  00
258C:  ADDWFC x7B,W
258E:  MOVWF  FEA
2590:  MOVFF  FEC,27F
2594:  MOVF   FED,F
2596:  MOVFF  FEF,27E
259A:  MOVFF  27F,29A
259E:  MOVFF  27E,299
25A2:  MOVLB  0
25A4:  CALL   118C
25A8:  MOVFF  27D,FEA
25AC:  MOVFF  27C,FE9
25B0:  MOVFF  02,FEC
25B4:  MOVF   FED,F
25B6:  MOVFF  01,FEF
....................    header->UrgentPointer = swaps(header->UrgentPointer); 
25BA:  MOVLW  12
25BC:  MOVLB  2
25BE:  ADDWF  x7A,W
25C0:  MOVWF  01
25C2:  MOVLW  00
25C4:  ADDWFC x7B,W
25C6:  MOVWF  03
25C8:  MOVFF  01,27C
25CC:  MOVWF  x7D
25CE:  MOVLW  12
25D0:  ADDWF  x7A,W
25D2:  MOVWF  FE9
25D4:  MOVLW  00
25D6:  ADDWFC x7B,W
25D8:  MOVWF  FEA
25DA:  MOVFF  FEC,27F
25DE:  MOVF   FED,F
25E0:  MOVFF  FEF,27E
25E4:  MOVFF  27F,29A
25E8:  MOVFF  27E,299
25EC:  MOVLB  0
25EE:  CALL   118C
25F2:  MOVFF  27D,FEA
25F6:  MOVFF  27C,FE9
25FA:  MOVFF  02,FEC
25FE:  MOVF   FED,F
2600:  MOVFF  01,FEF
.................... } 
2604:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        static void CloseSocket(SOCKET_INFO* ps) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           ps  - Pointer to a socket info that is to be 
....................  *                          closed. 
....................  * 
....................  * Output:          Given socket information is reset and any 
....................  *                  buffer held by this socket is discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void CloseSocket(SOCKET_INFO* ps) { 
.................... 	//debug_tcp("\r\nTCP SOCKET CLOSED"); 
....................  
....................    if (ps->TxBuffer != INVALID_BUFFER) { 
*
27F6:  MOVLW  0F
27F8:  MOVLB  2
27FA:  ADDWF  x3E,W
27FC:  MOVWF  FE9
27FE:  MOVLW  00
2800:  ADDWFC x3F,W
2802:  MOVWF  FEA
2804:  INCFSZ FEF,W
2806:  BRA    280A
2808:  BRA    2850
....................       MACDiscardTx(ps->TxBuffer); 
280A:  MOVLW  0F
280C:  ADDWF  x3E,W
280E:  MOVWF  FE9
2810:  MOVLW  00
2812:  ADDWFC x3F,W
2814:  MOVWF  FEA
2816:  MOVFF  FEF,240
281A:  CLRF   19
281C:  BTFSC  FF2.7
281E:  BSF    19.7
2820:  BCF    FF2.7
2822:  MOVFF  240,2AC
2826:  MOVLB  0
2828:  CALL   0004
282C:  BTFSC  19.7
282E:  BSF    FF2.7
....................       ps->TxBuffer = INVALID_BUFFER; 
2830:  MOVLW  0F
2832:  MOVLB  2
2834:  ADDWF  x3E,W
2836:  MOVWF  FE9
2838:  MOVLW  00
283A:  ADDWFC x3F,W
283C:  MOVWF  FEA
283E:  MOVLW  FF
2840:  MOVWF  FEF
....................       ps->Flags.bIsPutReady = TRUE; 
2842:  MOVLW  23
2844:  ADDWF  x3E,W
2846:  MOVWF  FE9
2848:  MOVLW  00
284A:  ADDWFC x3F,W
284C:  MOVWF  FEA
284E:  BSF    FEF.1
....................    } 
....................  
....................    ps->remote.IPAddr.Val = 0x00; 
2850:  MOVLW  07
2852:  ADDWF  x3E,W
2854:  MOVWF  FE9
2856:  MOVLW  00
2858:  ADDWFC x3F,W
285A:  MOVWF  FEA
285C:  MOVF   FEE,F
285E:  MOVF   FEE,F
2860:  CLRF   FEC
2862:  MOVF   FED,F
2864:  CLRF   FEF
2866:  MOVF   FED,F
2868:  CLRF   FEF
286A:  MOVF   FED,F
286C:  CLRF   FEF
....................    ps->remotePort = 0x00; 
286E:  MOVLW  0D
2870:  ADDWF  x3E,W
2872:  MOVWF  FE9
2874:  MOVLW  00
2876:  ADDWFC x3F,W
2878:  MOVWF  FEA
287A:  CLRF   FEC
287C:  MOVF   FED,F
287E:  CLRF   FEF
....................    if (ps->Flags.bIsGetReady) { 
2880:  MOVLW  23
2882:  ADDWF  x3E,W
2884:  MOVWF  FE9
2886:  MOVLW  00
2888:  ADDWFC x3F,W
288A:  MOVWF  FEA
288C:  BTFSS  FEF.3
288E:  BRA    2898
....................       MACDiscardRx(); 
2890:  MOVLB  0
2892:  CALL   1070
2896:  MOVLB  2
....................    } 
....................    ps->Flags.bIsGetReady = FALSE; 
2898:  MOVLW  23
289A:  ADDWF  x3E,W
289C:  MOVWF  FE9
289E:  MOVLW  00
28A0:  ADDWFC x3F,W
28A2:  MOVWF  FEA
28A4:  BCF    FEF.3
....................    ps->TimeOut = TCP_START_TIMEOUT_VAL; 
28A6:  MOVLW  21
28A8:  ADDWF  x3E,W
28AA:  MOVWF  FE9
28AC:  MOVLW  00
28AE:  ADDWFC x3F,W
28B0:  MOVWF  FEA
28B2:  CLRF   FEC
28B4:  MOVF   FED,F
28B6:  MOVLW  24
28B8:  MOVWF  FEF
....................  
....................    ps->Flags.bIsTxInProgress = FALSE; 
28BA:  MOVLW  23
28BC:  ADDWF  x3E,W
28BE:  MOVWF  FE9
28C0:  MOVLW  00
28C2:  ADDWFC x3F,W
28C4:  MOVWF  FEA
28C6:  BCF    FEF.4
....................  
....................    if (ps->Flags.bServer) { 
28C8:  MOVLW  23
28CA:  ADDWF  x3E,W
28CC:  MOVWF  FE9
28CE:  MOVLW  00
28D0:  ADDWFC x3F,W
28D2:  MOVWF  FEA
28D4:  BTFSS  FEF.0
28D6:  BRA    28E4
....................       ps->smState = TCP_LISTEN; 
28D8:  MOVFF  23E,FE9
28DC:  MOVFF  23F,FEA
28E0:  CLRF   FEF
....................    } 
....................    else { 
28E2:  BRA    28F0
....................       ps->smState = TCP_CLOSED; 
28E4:  MOVFF  23E,FE9
28E8:  MOVFF  23F,FEA
28EC:  MOVLW  0A
28EE:  MOVWF  FEF
....................    } 
....................  
....................    ps->TxCount = 0; 
28F0:  MOVLW  10
28F2:  ADDWF  x3E,W
28F4:  MOVWF  FE9
28F6:  MOVLW  00
28F8:  ADDWFC x3F,W
28FA:  MOVWF  FEA
28FC:  CLRF   FEC
28FE:  MOVF   FED,F
2900:  CLRF   FEF
....................  
....................    return; 
.................... } 
2902:  MOVLB  0
2904:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        static void HandleTCPSeg(TCP_SOCKET s, 
....................  *                                      NODE_INFO *remote, 
....................  *                                      TCP_HEADER* h, 
....................  *                                      WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPProcess() is the caller. 
....................  * 
....................  * Input:           s           - Socket that owns this segment 
....................  *                  remote      - Remote node info 
....................  *                  h           - TCP Header 
....................  *                  len         - Total buffer length. 
....................  * 
....................  * Output:          TCP FSM is executed on given socket with 
....................  *                  given TCP segment. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void HandleTCPSeg(TCP_SOCKET s, NODE_INFO *remote, TCP_HEADER *h, 
....................       WORD len) { 
....................    DWORD ack; 
....................    DWORD seq; 
....................    DWORD prevAck, prevSeq; 
....................    SOCKET_INFO *ps; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................    signed int32 
....................    temp; 
....................  
....................    ps = &TCB[s]; 
*
2F4A:  MOVLB  2
2F4C:  MOVF   x20,W
2F4E:  MULLW  24
2F50:  MOVF   FF3,W
2F52:  CLRF   03
2F54:  ADDLW  8A
2F56:  MOVWF  01
2F58:  MOVLW  00
2F5A:  ADDWFC 03,F
2F5C:  MOVFF  01,237
2F60:  MOVFF  03,238
....................    //debugLastState = TCB[s].smState; 
....................  
....................    flags = 0x00; 
2F64:  CLRF   x39
....................  
....................    // Clear timeout info 
....................    ps->RetryCount = 0; 
2F66:  MOVLW  1E
2F68:  ADDWF  x37,W
2F6A:  MOVWF  FE9
2F6C:  MOVLW  00
2F6E:  ADDWFC x38,W
2F70:  MOVWF  FEA
2F72:  CLRF   FEF
....................    ps->startTick = TickGet(); 
2F74:  MOVLW  1F
2F76:  ADDWF  x37,W
2F78:  MOVWF  01
2F7A:  MOVLW  00
2F7C:  ADDWFC x38,W
2F7E:  MOVWF  03
2F80:  MOVFF  01,23E
2F84:  MOVWF  x3F
2F86:  MOVLB  0
2F88:  CALL   0FE8
2F8C:  MOVFF  23F,FEA
2F90:  MOVFF  23E,FE9
2F94:  MOVFF  02,FEC
2F98:  MOVF   FED,F
2F9A:  MOVFF  01,FEF
....................    ps->TimeOut = TCP_START_TIMEOUT_VAL; 
2F9E:  MOVLW  21
2FA0:  MOVLB  2
2FA2:  ADDWF  x37,W
2FA4:  MOVWF  FE9
2FA6:  MOVLW  00
2FA8:  ADDWFC x38,W
2FAA:  MOVWF  FEA
2FAC:  CLRF   FEC
2FAE:  MOVF   FED,F
2FB0:  MOVLW  24
2FB2:  MOVWF  FEF
....................  
....................    /* 
....................    debug_tcp("\r\nTCP IN <= SP:%LX DP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X\r\n", 
....................          h->SourcePort, 
....................          h->DestPort, 
....................          h->SeqNumber, 
....................          h->AckNumber, 
....................          len, 
....................          h->Flags 
....................    ); 
....................    */ 
....................  
....................    // Reset FSM, if RST is received. 
....................    if (h->Flags.bits.flagRST) { 
2FB4:  MOVLW  0D
2FB6:  ADDWF  x23,W
2FB8:  MOVWF  FE9
2FBA:  MOVLW  00
2FBC:  ADDWFC x24,W
2FBE:  MOVWF  FEA
2FC0:  BTFSS  FEF.2
2FC2:  BRA    3000
....................       MACDiscardRx(); 
2FC4:  MOVLB  0
2FC6:  CALL   1070
....................       ps->smState = ps->Flags.bServer ? TCP_LISTEN : TCP_SYN_SENT; 
2FCA:  MOVLB  2
2FCC:  MOVFF  237,01
2FD0:  MOVFF  238,03
2FD4:  MOVFF  237,23E
2FD8:  MOVFF  238,23F
2FDC:  MOVLW  23
2FDE:  ADDWF  x37,W
2FE0:  MOVWF  FE9
2FE2:  MOVLW  00
2FE4:  ADDWFC x38,W
2FE6:  MOVWF  FEA
2FE8:  BTFSS  FEF.0
2FEA:  BRA    2FF0
2FEC:  MOVLW  00
2FEE:  BRA    2FF2
2FF0:  MOVLW  01
2FF2:  MOVFF  23F,FEA
2FF6:  MOVFF  23E,FE9
2FFA:  MOVWF  FEF
....................       return; 
2FFC:  GOTO   3A36
....................    } 
....................  
....................    seq = ps->SND_SEQ; 
3000:  MOVLW  16
3002:  ADDWF  x37,W
3004:  MOVWF  FE9
3006:  MOVLW  00
3008:  ADDWFC x38,W
300A:  MOVWF  FEA
300C:  MOVFF  FEF,00
3010:  MOVFF  FEC,01
3014:  MOVFF  FEC,02
3018:  MOVFF  FEC,03
301C:  MOVFF  03,22E
3020:  MOVFF  02,22D
3024:  MOVFF  01,22C
3028:  MOVFF  00,22B
....................  
....................    temp = (signed int32)h->Window - ((signed int32)seq - (signed int32)h->AckNumber) - (signed int32)ps->TxCount; 
302C:  MOVLW  0E
302E:  ADDWF  x23,W
3030:  MOVWF  FE9
3032:  MOVLW  00
3034:  ADDWFC x24,W
3036:  MOVWF  FEA
3038:  MOVFF  FEC,03
303C:  MOVF   FED,F
303E:  MOVFF  FEF,23E
3042:  MOVFF  03,23F
3046:  CLRF   x40
3048:  CLRF   x41
304A:  MOVLW  08
304C:  ADDWF  x23,W
304E:  MOVWF  FE9
3050:  MOVLW  00
3052:  ADDWFC x24,W
3054:  MOVWF  FEA
3056:  MOVFF  FEF,00
305A:  MOVFF  FEC,01
305E:  MOVFF  FEC,02
3062:  MOVFF  FEC,03
3066:  MOVF   00,W
3068:  SUBWF  x2B,W
306A:  MOVWF  00
306C:  MOVF   01,W
306E:  SUBWFB x2C,W
3070:  MOVWF  01
3072:  MOVF   02,W
3074:  SUBWFB x2D,W
3076:  MOVWF  02
3078:  MOVF   03,W
307A:  SUBWFB x2E,W
307C:  MOVWF  03
307E:  MOVF   00,W
3080:  SUBWF  x3E,F
3082:  MOVF   01,W
3084:  SUBWFB x3F,F
3086:  MOVF   02,W
3088:  SUBWFB x40,F
308A:  MOVF   03,W
308C:  SUBWFB x41,F
308E:  MOVLW  10
3090:  ADDWF  x37,W
3092:  MOVWF  FE9
3094:  MOVLW  00
3096:  ADDWFC x38,W
3098:  MOVWF  FEA
309A:  MOVFF  FEC,03
309E:  MOVF   FED,F
30A0:  MOVFF  FEF,00
30A4:  MOVFF  03,01
30A8:  CLRF   02
30AA:  CLRF   03
30AC:  MOVF   00,W
30AE:  SUBWF  x3E,W
30B0:  MOVWF  x3A
30B2:  MOVF   01,W
30B4:  SUBWFB x3F,W
30B6:  MOVWF  x3B
30B8:  MOVF   02,W
30BA:  SUBWFB x40,W
30BC:  MOVWF  x3C
30BE:  MOVF   03,W
30C0:  SUBWFB x41,W
30C2:  MOVWF  x3D
....................    if (temp < 0) { 
30C4:  BTFSC  x3D.7
30C6:  BRA    30CA
30C8:  BRA    30DE
....................       ps->RemoteWindow = 0; 
30CA:  MOVLW  14
30CC:  ADDWF  x37,W
30CE:  MOVWF  FE9
30D0:  MOVLW  00
30D2:  ADDWFC x38,W
30D4:  MOVWF  FEA
30D6:  CLRF   FEC
30D8:  MOVF   FED,F
30DA:  CLRF   FEF
....................       /* 
....................       debug_tcp("\r\nRW1 => %LX, res=%LX W=%LX S=%LX A=%LX C=%LX\r\n", 
....................             ps->RemoteWindow, 
....................             temp, 
....................             h->Window, 
....................             seq, 
....................             h->AckNumber, 
....................             ps->TxCount 
....................       ); 
....................       */ 
....................    } 
....................    else { 
30DC:  BRA    30F2
....................       ps->RemoteWindow = ack; 
30DE:  MOVLW  14
30E0:  ADDWF  x37,W
30E2:  MOVWF  FE9
30E4:  MOVLW  00
30E6:  ADDWFC x38,W
30E8:  MOVWF  FEA
30EA:  MOVFF  227,FEF
30EE:  MOVFF  228,FEC
....................       //debug_tcp("\r\nRW2 => %LX\r\n", ps->RemoteWindow); 
....................    } 
....................  
....................    // Handle TCP_SYN_SENT state 
....................    // The TCP_SYN_SENT state occurs when an application 
....................    // calls TCPConnect().  After an initial SYN is sent, 
....................    // we expect a SYN + ACK before establishing the 
....................    // connection. 
....................    if (ps->smState == TCP_SYN_SENT) { 
30F2:  MOVFF  237,FE9
30F6:  MOVFF  238,FEA
30FA:  DECFSZ FEF,W
30FC:  BRA    327A
....................       // Check if this is a SYN packet.  Unsynchronized, we cannot 
....................       // handle any other packet types. 
....................       if (!h->Flags.bits.flagSYN) { 
30FE:  MOVLW  0D
3100:  ADDWF  x23,W
3102:  MOVWF  FE9
3104:  MOVLW  00
3106:  ADDWFC x24,W
3108:  MOVWF  FEA
310A:  BTFSC  FEF.1
310C:  BRA    3132
....................          MACDiscardRx(); 
310E:  MOVLB  0
3110:  CALL   1070
....................  
....................          // Send out a RESET if the remote node thinks a connection is already established 
....................          if (h->Flags.bits.flagACK) { 
3114:  MOVLW  0D
3116:  MOVLB  2
3118:  ADDWF  x23,W
311A:  MOVWF  FE9
311C:  MOVLW  00
311E:  ADDWFC x24,W
3120:  MOVWF  FEA
3122:  BTFSS  FEF.4
3124:  BRA    312E
....................             flags = RST; 
3126:  MOVLW  04
3128:  MOVWF  x39
....................             goto SendTCPControlPacket; 
312A:  GOTO   39BE
....................          } 
....................  
....................          return; 
312E:  GOTO   3A36
....................       } 
....................  
....................       // We now have a sequence number for the remote node 
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
3132:  MOVLW  1A
3134:  ADDWF  x37,W
3136:  MOVWF  01
3138:  MOVLW  00
313A:  ADDWFC x38,W
313C:  MOVFF  01,23E
3140:  MOVWF  x3F
3142:  MOVLW  04
3144:  ADDWF  x23,W
3146:  MOVWF  FE9
3148:  MOVLW  00
314A:  ADDWFC x24,W
314C:  MOVWF  FEA
314E:  MOVFF  FEF,240
3152:  MOVFF  FEC,241
3156:  MOVFF  FEC,242
315A:  MOVFF  FEC,243
315E:  MOVF   x25,W
3160:  ADDWF  x40,F
3162:  MOVF   x26,W
3164:  ADDWFC x41,F
3166:  MOVLW  00
3168:  ADDWFC x42,F
316A:  ADDWFC x43,F
316C:  MOVLW  01
316E:  ADDWF  x40,W
3170:  MOVWF  00
3172:  MOVLW  00
3174:  ADDWFC x41,W
3176:  MOVWF  01
3178:  MOVLW  00
317A:  ADDWFC x42,W
317C:  MOVWF  02
317E:  MOVLW  00
3180:  ADDWFC x43,W
3182:  MOVFF  23F,FEA
3186:  MOVFF  23E,FE9
318A:  MOVFF  00,FEF
318E:  MOVFF  01,FEC
3192:  MOVFF  02,FEC
3196:  MOVWF  FEC
....................       ack = ps->SND_ACK; 
3198:  MOVLW  1A
319A:  ADDWF  x37,W
319C:  MOVWF  FE9
319E:  MOVLW  00
31A0:  ADDWFC x38,W
31A2:  MOVWF  FEA
31A4:  MOVFF  FEF,00
31A8:  MOVFF  FEC,01
31AC:  MOVFF  FEC,02
31B0:  MOVFF  FEC,03
31B4:  MOVFF  03,22A
31B8:  MOVFF  02,229
31BC:  MOVFF  01,228
31C0:  MOVFF  00,227
....................  
....................       // If there is no ACK, we must go to TCP_SYN_RECEIVED.  With an ACK, 
....................       // we can establish the connection now. 
....................       if (!h->Flags.bits.flagACK) { 
31C4:  MOVLW  0D
31C6:  ADDWF  x23,W
31C8:  MOVWF  FE9
31CA:  MOVLW  00
31CC:  ADDWFC x24,W
31CE:  MOVWF  FEA
31D0:  BTFSC  FEF.4
31D2:  BRA    31F0
....................          ps->smState = TCP_SYN_RECEIVED; 
31D4:  MOVFF  237,FE9
31D8:  MOVFF  238,FEA
31DC:  MOVLW  02
31DE:  MOVWF  FEF
....................          MACDiscardRx(); 
31E0:  MOVLB  0
31E2:  CALL   1070
....................          // Send out a SYN+ACK for simultaneous connection open 
....................          flags = SYN | ACK; 
31E6:  MOVLW  12
31E8:  MOVLB  2
31EA:  MOVWF  x39
....................          goto SendTCPControlPacket; 
31EC:  GOTO   39BE
....................       } 
....................  
....................       // We received SYN+ACK, establish the connection now 
....................       ps->smState = TCP_ESTABLISHED; 
31F0:  MOVFF  237,FE9
31F4:  MOVFF  238,FEA
31F8:  MOVLW  03
31FA:  MOVWF  FEF
....................       // Send out an ACK 
....................       flags = ACK; 
31FC:  MOVLW  10
31FE:  MOVWF  x39
....................  
....................       ps->RemoteWindow = h->Window; 
3200:  MOVLW  14
3202:  ADDWF  x37,W
3204:  MOVWF  01
3206:  MOVLW  00
3208:  ADDWFC x38,W
320A:  MOVWF  03
320C:  MOVWF  x3F
320E:  MOVLW  0E
3210:  ADDWF  x23,W
3212:  MOVWF  FE9
3214:  MOVLW  00
3216:  ADDWFC x24,W
3218:  MOVWF  FEA
321A:  MOVFF  FEC,03
321E:  MOVF   FED,F
3220:  MOVFF  FEF,240
3224:  MOVFF  23F,FEA
3228:  MOVFF  01,FE9
322C:  MOVFF  03,FEC
3230:  MOVF   FED,F
3232:  MOVFF  240,FEF
....................       //debug_tcp("\r\nRW3 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // Check for application data and make it 
....................       // available, if present 
....................       if (len) { 
3236:  MOVF   x25,W
3238:  IORWF  x26,W
323A:  BZ    3270
....................          ps->Flags.bIsGetReady = TRUE; 
323C:  MOVLW  23
323E:  ADDWF  x37,W
3240:  MOVWF  FE9
3242:  MOVLW  00
3244:  ADDWFC x38,W
3246:  MOVWF  FEA
3248:  BSF    FEF.3
....................          ps->RxCount = len; 
324A:  MOVLW  12
324C:  ADDWF  x37,W
324E:  MOVWF  FE9
3250:  MOVLW  00
3252:  ADDWFC x38,W
3254:  MOVWF  FEA
3256:  MOVFF  226,FEC
325A:  MOVF   FED,F
325C:  MOVFF  225,FEF
....................          ps->Flags.bFirstRead = TRUE; 
3260:  MOVLW  23
3262:  ADDWF  x37,W
3264:  MOVWF  FE9
3266:  MOVLW  00
3268:  ADDWFC x38,W
326A:  MOVWF  FEA
326C:  BSF    FEF.2
....................       } 
....................       else   // No application data in this packet 
326E:  BRA    3278
....................       { 
....................          MACDiscardRx(); 
3270:  MOVLB  0
3272:  CALL   1070
3276:  MOVLB  2
....................       } 
....................       goto SendTCPControlPacket; 
3278:  BRA    39BE
....................    } 
....................  
....................    // Handle TCP_LISTEN state 
....................    if (ps->smState == TCP_LISTEN) { 
327A:  MOVFF  237,FE9
327E:  MOVFF  238,FEA
3282:  MOVF   FEF,F
3284:  BTFSS  FD8.2
3286:  BRA    341C
....................       MACDiscardRx(); 
3288:  MOVLB  0
328A:  CALL   1070
....................  
....................       // Send a RST if this isn't a SYN packet 
....................       if (!h->Flags.bits.flagSYN) { 
328E:  MOVLW  0D
3290:  MOVLB  2
3292:  ADDWF  x23,W
3294:  MOVWF  FE9
3296:  MOVLW  00
3298:  ADDWFC x24,W
329A:  MOVWF  FEA
329C:  BTFSC  FEF.1
329E:  BRA    32A6
....................          flags = RST; 
32A0:  MOVLW  04
32A2:  MOVWF  x39
....................          goto SendTCPControlPacket; 
32A4:  BRA    39BE
....................       } 
....................  
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
32A6:  MOVLW  1A
32A8:  ADDWF  x37,W
32AA:  MOVWF  01
32AC:  MOVLW  00
32AE:  ADDWFC x38,W
32B0:  MOVFF  01,23E
32B4:  MOVWF  x3F
32B6:  MOVLW  04
32B8:  ADDWF  x23,W
32BA:  MOVWF  FE9
32BC:  MOVLW  00
32BE:  ADDWFC x24,W
32C0:  MOVWF  FEA
32C2:  MOVFF  FEF,240
32C6:  MOVFF  FEC,241
32CA:  MOVFF  FEC,242
32CE:  MOVFF  FEC,243
32D2:  MOVF   x25,W
32D4:  ADDWF  x40,F
32D6:  MOVF   x26,W
32D8:  ADDWFC x41,F
32DA:  MOVLW  00
32DC:  ADDWFC x42,F
32DE:  ADDWFC x43,F
32E0:  MOVLW  01
32E2:  ADDWF  x40,W
32E4:  MOVWF  00
32E6:  MOVLW  00
32E8:  ADDWFC x41,W
32EA:  MOVWF  01
32EC:  MOVLW  00
32EE:  ADDWFC x42,W
32F0:  MOVWF  02
32F2:  MOVLW  00
32F4:  ADDWFC x43,W
32F6:  MOVFF  23F,FEA
32FA:  MOVFF  23E,FE9
32FE:  MOVFF  00,FEF
3302:  MOVFF  01,FEC
3306:  MOVFF  02,FEC
330A:  MOVWF  FEC
....................       ps->RemoteWindow = h->Window; 
330C:  MOVLW  14
330E:  ADDWF  x37,W
3310:  MOVWF  01
3312:  MOVLW  00
3314:  ADDWFC x38,W
3316:  MOVWF  03
3318:  MOVWF  x3F
331A:  MOVLW  0E
331C:  ADDWF  x23,W
331E:  MOVWF  FE9
3320:  MOVLW  00
3322:  ADDWFC x24,W
3324:  MOVWF  FEA
3326:  MOVFF  FEC,03
332A:  MOVF   FED,F
332C:  MOVFF  FEF,240
3330:  MOVFF  23F,FEA
3334:  MOVFF  01,FE9
3338:  MOVFF  03,FEC
333C:  MOVF   FED,F
333E:  MOVFF  240,FEF
....................       //debug_tcp("\r\nRW4 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // This socket has received connection request (SYN). 
....................       // Remember calling node, assign next segment seq. number 
....................       // for this potential connection. 
....................       memcpy((void*) &ps->remote, (void*) remote, sizeof(*remote)); 
3342:  MOVLW  01
3344:  ADDWF  x37,W
3346:  MOVWF  01
3348:  MOVLW  00
334A:  ADDWFC x38,W
334C:  MOVWF  03
334E:  MOVFF  01,23E
3352:  MOVWF  x3F
3354:  MOVWF  FEA
3356:  MOVFF  01,FE9
335A:  MOVFF  222,FE2
335E:  MOVFF  221,FE1
3362:  MOVLW  0A
3364:  MOVWF  01
3366:  MOVFF  FE6,FEE
336A:  DECFSZ 01,F
336C:  BRA    3366
....................       ps->remotePort = h->SourcePort; 
336E:  MOVLW  0D
3370:  ADDWF  x37,W
3372:  MOVWF  01
3374:  MOVLW  00
3376:  ADDWFC x38,W
3378:  MOVFF  223,FE9
337C:  MOVFF  224,FEA
3380:  MOVFF  FEC,03
3384:  MOVF   FED,F
3386:  MOVFF  FEF,240
338A:  MOVWF  FEA
338C:  MOVFF  01,FE9
3390:  MOVFF  03,FEC
3394:  MOVF   FED,F
3396:  MOVFF  240,FEF
....................  
....................       // Grant connection request. 
....................       ps->smState = TCP_SYN_RECEIVED; 
339A:  MOVFF  237,FE9
339E:  MOVFF  238,FEA
33A2:  MOVLW  02
33A4:  MOVWF  FEF
....................       //seq = ps->SND_SEQ++;  //currently buggy in ccs 
....................       seq = ps->SND_SEQ; 
33A6:  MOVLW  16
33A8:  ADDWF  x37,W
33AA:  MOVWF  FE9
33AC:  MOVLW  00
33AE:  ADDWFC x38,W
33B0:  MOVWF  FEA
33B2:  MOVFF  FEF,00
33B6:  MOVFF  FEC,01
33BA:  MOVFF  FEC,02
33BE:  MOVFF  FEC,03
33C2:  MOVFF  03,22E
33C6:  MOVFF  02,22D
33CA:  MOVFF  01,22C
33CE:  MOVFF  00,22B
....................       ps->SND_SEQ++; 
33D2:  MOVLW  16
33D4:  ADDWF  x37,W
33D6:  MOVWF  FE9
33D8:  MOVLW  00
33DA:  ADDWFC x38,W
33DC:  MOVWF  FEA
33DE:  MOVLW  01
33E0:  ADDWF  FEE,F
33E2:  MOVLW  00
33E4:  ADDWFC FEE,F
33E6:  ADDWFC FEE,F
33E8:  ADDWFC FED,F
....................       ack = ps->SND_ACK; 
33EA:  MOVLW  1A
33EC:  ADDWF  x37,W
33EE:  MOVWF  FE9
33F0:  MOVLW  00
33F2:  ADDWFC x38,W
33F4:  MOVWF  FEA
33F6:  MOVFF  FEF,00
33FA:  MOVFF  FEC,01
33FE:  MOVFF  FEC,02
3402:  MOVFF  FEC,03
3406:  MOVFF  03,22A
340A:  MOVFF  02,229
340E:  MOVFF  01,228
3412:  MOVFF  00,227
....................       flags = SYN | ACK; 
3416:  MOVLW  12
3418:  MOVWF  x39
....................       goto SendTCPControlPacket; 
341A:  BRA    39BE
....................    } 
....................  
....................    // Remember current seq and ack for our connection so that if 
....................    // we have to silently discard this packet, we can go back to 
....................    // previous ack and seq numbers. 
....................    prevAck = ps->SND_ACK; 
341C:  MOVLW  1A
341E:  ADDWF  x37,W
3420:  MOVWF  FE9
3422:  MOVLW  00
3424:  ADDWFC x38,W
3426:  MOVWF  FEA
3428:  MOVFF  FEF,00
342C:  MOVFF  FEC,01
3430:  MOVFF  FEC,02
3434:  MOVFF  FEC,03
3438:  MOVFF  03,232
343C:  MOVFF  02,231
3440:  MOVFF  01,230
3444:  MOVFF  00,22F
....................    prevSeq = ps->SND_SEQ; 
3448:  MOVLW  16
344A:  ADDWF  x37,W
344C:  MOVWF  FE9
344E:  MOVLW  00
3450:  ADDWFC x38,W
3452:  MOVWF  FEA
3454:  MOVFF  FEF,00
3458:  MOVFF  FEC,01
345C:  MOVFF  FEC,02
3460:  MOVFF  FEC,03
3464:  MOVFF  03,236
3468:  MOVFF  02,235
346C:  MOVFF  01,234
3470:  MOVFF  00,233
....................  
....................    ack = h->SeqNumber; 
3474:  MOVLW  04
3476:  ADDWF  x23,W
3478:  MOVWF  FE9
347A:  MOVLW  00
347C:  ADDWFC x24,W
347E:  MOVWF  FEA
3480:  MOVFF  FEF,00
3484:  MOVFF  FEC,01
3488:  MOVFF  FEC,02
348C:  MOVFF  FEC,03
3490:  MOVFF  03,22A
3494:  MOVFF  02,229
3498:  MOVFF  01,228
349C:  MOVFF  00,227
....................    ack += (DWORD) len; 
34A0:  CLRF   02
34A2:  CLRF   03
34A4:  MOVF   x25,W
34A6:  ADDWF  x27,F
34A8:  MOVF   x26,W
34AA:  ADDWFC x28,F
34AC:  MOVF   02,W
34AE:  ADDWFC x29,F
34B0:  MOVF   03,W
34B2:  ADDWFC x2A,F
....................    seq = ps->SND_SEQ; 
34B4:  MOVLW  16
34B6:  ADDWF  x37,W
34B8:  MOVWF  FE9
34BA:  MOVLW  00
34BC:  ADDWFC x38,W
34BE:  MOVWF  FEA
34C0:  MOVFF  FEF,00
34C4:  MOVFF  FEC,01
34C8:  MOVFF  FEC,02
34CC:  MOVFF  FEC,03
34D0:  MOVFF  03,22E
34D4:  MOVFF  02,22D
34D8:  MOVFF  01,22C
34DC:  MOVFF  00,22B
....................  
....................    // State is something other than TCP_LISTEN, handle it. 
....................    { 
....................       // Check to see if the incomming sequence number is what 
....................       // we expect (last transmitted ACK value).  Throw this packet 
....................       // away if it is wrong. 
....................       if (h->SeqNumber == prevAck) { 
34E0:  MOVLW  04
34E2:  ADDWF  x23,W
34E4:  MOVWF  FE9
34E6:  MOVLW  00
34E8:  ADDWFC x24,W
34EA:  MOVWF  FEA
34EC:  MOVFF  FEF,23E
34F0:  MOVFF  FEC,23F
34F4:  MOVFF  FEC,240
34F8:  MOVFF  FEC,241
34FC:  MOVF   x2F,W
34FE:  SUBWF  x3E,W
3500:  BTFSS  FD8.2
3502:  BRA    39A2
3504:  MOVF   x30,W
3506:  SUBWF  x3F,W
3508:  BTFSS  FD8.2
350A:  BRA    39A2
350C:  MOVF   x31,W
350E:  SUBWF  x40,W
3510:  BTFSS  FD8.2
3512:  BRA    39A2
3514:  MOVF   x32,W
3516:  SUBWF  x41,W
3518:  BTFSS  FD8.2
351A:  BRA    39A2
....................          // After receiving a SYNchronization request, we expect an 
....................          // ACK to our transmitted SYN 
....................          if (ps->smState == TCP_SYN_RECEIVED) { 
351C:  MOVFF  237,FE9
3520:  MOVFF  238,FEA
3524:  MOVF   FEF,W
3526:  SUBLW  02
3528:  BNZ   35B0
....................             if (h->Flags.bits.flagACK) { 
352A:  MOVLW  0D
352C:  ADDWF  x23,W
352E:  MOVWF  FE9
3530:  MOVLW  00
3532:  ADDWFC x24,W
3534:  MOVWF  FEA
3536:  BTFSS  FEF.4
3538:  BRA    35A6
....................                // ACK received as expected, this connection is 
....................                // now established 
....................                ps->SND_ACK = ack; 
353A:  MOVLW  1A
353C:  ADDWF  x37,W
353E:  MOVWF  FE9
3540:  MOVLW  00
3542:  ADDWFC x38,W
3544:  MOVWF  FEA
3546:  MOVFF  227,FEF
354A:  MOVFF  228,FEC
354E:  MOVFF  229,FEC
3552:  MOVFF  22A,FEC
....................                ps->smState = TCP_ESTABLISHED; 
3556:  MOVFF  237,FE9
355A:  MOVFF  238,FEA
355E:  MOVLW  03
3560:  MOVWF  FEF
....................  
....................                // Check if this first packet has application data 
....................                // in it.  Make it available if so. 
....................                if (len) { 
3562:  MOVF   x25,W
3564:  IORWF  x26,W
3566:  BZ    359C
....................                   ps->Flags.bIsGetReady = TRUE; 
3568:  MOVLW  23
356A:  ADDWF  x37,W
356C:  MOVWF  FE9
356E:  MOVLW  00
3570:  ADDWFC x38,W
3572:  MOVWF  FEA
3574:  BSF    FEF.3
....................                   ps->RxCount = len; 
3576:  MOVLW  12
3578:  ADDWF  x37,W
357A:  MOVWF  FE9
357C:  MOVLW  00
357E:  ADDWFC x38,W
3580:  MOVWF  FEA
3582:  MOVFF  226,FEC
3586:  MOVF   FED,F
3588:  MOVFF  225,FEF
....................                   ps->Flags.bFirstRead = TRUE; 
358C:  MOVLW  23
358E:  ADDWF  x37,W
3590:  MOVWF  FE9
3592:  MOVLW  00
3594:  ADDWFC x38,W
3596:  MOVWF  FEA
3598:  BSF    FEF.2
....................                } 
....................                else 
359A:  BRA    35A4
....................                   MACDiscardRx(); 
359C:  MOVLB  0
359E:  CALL   1070
35A2:  MOVLB  2
....................             } 
....................             else   // No ACK to our SYN 
35A4:  BRA    35AE
....................             { 
....................                MACDiscardRx(); 
35A6:  MOVLB  0
35A8:  CALL   1070
35AC:  MOVLB  2
....................             } 
....................          } 
....................          // Connection is established, closing, or otherwise 
....................          else { 
35AE:  BRA    39A0
....................  
....................             // Save the seq+len value of the packet for our future 
....................             // ACK transmission, and so out of sequence packets 
....................             // can be detected in the future. 
....................             ps->SND_ACK = ack; 
35B0:  MOVLW  1A
35B2:  ADDWF  x37,W
35B4:  MOVWF  FE9
35B6:  MOVLW  00
35B8:  ADDWFC x38,W
35BA:  MOVWF  FEA
35BC:  MOVFF  227,FEF
35C0:  MOVFF  228,FEC
35C4:  MOVFF  229,FEC
35C8:  MOVFF  22A,FEC
....................  
....................             // Handle packets received while connection established. 
....................             if (ps->smState == TCP_ESTABLISHED) { 
35CC:  MOVFF  237,FE9
35D0:  MOVFF  238,FEA
35D4:  MOVF   FEF,W
35D6:  SUBLW  03
35D8:  BTFSS  FD8.2
35DA:  BRA    37B2
....................                // If this packet has the ACK set, mark all 
....................                // previous TX packets as no longer needed for 
....................                // possible retransmission. 
....................                // TODO: Make this more sophisticated so that partial ACKs due to fragmentation are handled correctly.  i.e. Keep a real output stream buffer with slidable window capability. 
....................                if (h->Flags.bits.flagACK && !ps->Flags.bIsPutReady) { 
35DC:  MOVLW  0D
35DE:  ADDWF  x23,W
35E0:  MOVWF  FE9
35E2:  MOVLW  00
35E4:  ADDWFC x24,W
35E6:  MOVWF  FEA
35E8:  BTFSS  FEF.4
35EA:  BRA    3654
35EC:  MOVLW  23
35EE:  ADDWF  x37,W
35F0:  MOVWF  FE9
35F2:  MOVLW  00
35F4:  ADDWFC x38,W
35F6:  MOVWF  FEA
35F8:  BTFSC  FEF.1
35FA:  BRA    3654
....................                   if (ps->TxBuffer != INVALID_BUFFER) { 
35FC:  MOVLW  0F
35FE:  ADDWF  x37,W
3600:  MOVWF  FE9
3602:  MOVLW  00
3604:  ADDWFC x38,W
3606:  MOVWF  FEA
3608:  INCFSZ FEF,W
360A:  BRA    360E
360C:  BRA    3654
....................                      MACDiscardTx(ps->TxBuffer); 
360E:  MOVLW  0F
3610:  ADDWF  x37,W
3612:  MOVWF  FE9
3614:  MOVLW  00
3616:  ADDWFC x38,W
3618:  MOVWF  FEA
361A:  MOVFF  FEF,23E
361E:  CLRF   19
3620:  BTFSC  FF2.7
3622:  BSF    19.7
3624:  BCF    FF2.7
3626:  MOVFF  23E,2AC
362A:  MOVLB  0
362C:  CALL   0004
3630:  BTFSC  19.7
3632:  BSF    FF2.7
....................                      ps->TxBuffer = INVALID_BUFFER; 
3634:  MOVLW  0F
3636:  MOVLB  2
3638:  ADDWF  x37,W
363A:  MOVWF  FE9
363C:  MOVLW  00
363E:  ADDWFC x38,W
3640:  MOVWF  FEA
3642:  MOVLW  FF
3644:  MOVWF  FEF
....................                      ps->Flags.bIsPutReady = TRUE; 
3646:  MOVLW  23
3648:  ADDWF  x37,W
364A:  MOVWF  FE9
364C:  MOVLW  00
364E:  ADDWFC x38,W
3650:  MOVWF  FEA
3652:  BSF    FEF.1
....................                   } 
....................                } 
....................  
....................                // Check if the remote node is closing the connection 
....................                if (h->Flags.bits.flagFIN) { 
3654:  MOVLW  0D
3656:  ADDWF  x23,W
3658:  MOVWF  FE9
365A:  MOVLW  00
365C:  ADDWFC x24,W
365E:  MOVWF  FEA
3660:  BTFSS  FEF.0
3662:  BRA    371A
....................                   //DebugPrint("|"); 
....................                   flags = FIN | ACK; 
3664:  MOVLW  11
3666:  MOVWF  x39
....................                   //seq = ps->SND_SEQ++; //currently buggy in CCS 
....................                   seq = ps->SND_SEQ; 
3668:  MOVLW  16
366A:  ADDWF  x37,W
366C:  MOVWF  FE9
366E:  MOVLW  00
3670:  ADDWFC x38,W
3672:  MOVWF  FEA
3674:  MOVFF  FEF,00
3678:  MOVFF  FEC,01
367C:  MOVFF  FEC,02
3680:  MOVFF  FEC,03
3684:  MOVFF  03,22E
3688:  MOVFF  02,22D
368C:  MOVFF  01,22C
3690:  MOVFF  00,22B
....................                   ps->SND_SEQ++; 
3694:  MOVLW  16
3696:  ADDWF  x37,W
3698:  MOVWF  FE9
369A:  MOVLW  00
369C:  ADDWFC x38,W
369E:  MOVWF  FEA
36A0:  MOVLW  01
36A2:  ADDWF  FEE,F
36A4:  MOVLW  00
36A6:  ADDWFC FEE,F
36A8:  ADDWFC FEE,F
36AA:  ADDWFC FED,F
....................                   //ack = ++ps->SND_ACK;   /////TODO HUGE BUG HERE? 
....................                   ps->SND_ACK += 1; 
36AC:  MOVLW  1A
36AE:  ADDWF  x37,W
36B0:  MOVWF  FE9
36B2:  MOVLW  00
36B4:  ADDWFC x38,W
36B6:  MOVWF  FEA
36B8:  MOVLW  01
36BA:  ADDWF  FEF,W
36BC:  MOVWF  00
36BE:  MOVLW  00
36C0:  ADDWFC FEC,W
36C2:  MOVWF  01
36C4:  MOVLW  00
36C6:  ADDWFC FEC,W
36C8:  MOVWF  02
36CA:  MOVLW  00
36CC:  ADDWFC FEC,W
36CE:  MOVF   FED,F
36D0:  MOVF   FED,F
36D2:  MOVF   FED,F
36D4:  MOVFF  00,FEF
36D8:  MOVFF  01,FEC
36DC:  MOVFF  02,FEC
36E0:  MOVWF  FEC
....................                   ack = ps->SND_ACK; 
36E2:  MOVLW  1A
36E4:  ADDWF  x37,W
36E6:  MOVWF  FE9
36E8:  MOVLW  00
36EA:  ADDWFC x38,W
36EC:  MOVWF  FEA
36EE:  MOVFF  FEF,00
36F2:  MOVFF  FEC,01
36F6:  MOVFF  FEC,02
36FA:  MOVFF  FEC,03
36FE:  MOVFF  03,22A
3702:  MOVFF  02,229
3706:  MOVFF  01,228
370A:  MOVFF  00,227
....................                   ps->smState = TCP_LAST_ACK; 
370E:  MOVFF  237,FE9
3712:  MOVFF  238,FEA
3716:  MOVLW  09
3718:  MOVWF  FEF
....................                } 
....................  
....................                // Check if there is any application data in 
....................                // this packet. 
....................                if (len) { 
371A:  MOVF   x25,W
371C:  IORWF  x26,W
371E:  BZ    37A8
....................                   // There is data.  Make it available if we 
....................                   // don't already have data available. 
....................                   if (!ps->Flags.bIsGetReady) { 
3720:  MOVLW  23
3722:  ADDWF  x37,W
3724:  MOVWF  FE9
3726:  MOVLW  00
3728:  ADDWFC x38,W
372A:  MOVWF  FEA
372C:  BTFSC  FEF.3
372E:  BRA    3766
....................                      ps->Flags.bIsGetReady = TRUE; 
3730:  MOVLW  23
3732:  ADDWF  x37,W
3734:  MOVWF  FE9
3736:  MOVLW  00
3738:  ADDWFC x38,W
373A:  MOVWF  FEA
373C:  BSF    FEF.3
....................                      ps->RxCount = len; 
373E:  MOVLW  12
3740:  ADDWF  x37,W
3742:  MOVWF  FE9
3744:  MOVLW  00
3746:  ADDWFC x38,W
3748:  MOVWF  FEA
374A:  MOVFF  226,FEC
374E:  MOVF   FED,F
3750:  MOVFF  225,FEF
....................                      ps->Flags.bFirstRead = TRUE; 
3754:  MOVLW  23
3756:  ADDWF  x37,W
3758:  MOVWF  FE9
375A:  MOVLW  00
375C:  ADDWFC x38,W
375E:  MOVWF  FEA
3760:  BSF    FEF.2
....................  
....................                      // 4/1/02 
....................                      flags |= ACK; 
3762:  BSF    x39.4
....................                   } 
....................                   // There is data, but we cannot handle it at this time. 
....................                   else { 
3764:  BRA    37A6
....................                      //DebugPrint("D"); 
....................                      // Since we cannot accept this packet, 
....................                      // restore to previous seq and ack. 
....................                      // and do not send anything back. 
....................                      // Host has to resend this packet when 
....................                      // we are ready. 
....................                      ps->SND_SEQ = prevSeq; 
3766:  MOVLW  16
3768:  ADDWF  x37,W
376A:  MOVWF  FE9
376C:  MOVLW  00
376E:  ADDWFC x38,W
3770:  MOVWF  FEA
3772:  MOVFF  233,FEF
3776:  MOVFF  234,FEC
377A:  MOVFF  235,FEC
377E:  MOVFF  236,FEC
....................                      ps->SND_ACK = prevAck; 
3782:  MOVLW  1A
3784:  ADDWF  x37,W
3786:  MOVWF  FE9
3788:  MOVLW  00
378A:  ADDWFC x38,W
378C:  MOVWF  FEA
378E:  MOVFF  22F,FEF
3792:  MOVFF  230,FEC
3796:  MOVFF  231,FEC
379A:  MOVFF  232,FEC
....................  
....................                      MACDiscardRx(); 
379E:  MOVLB  0
37A0:  CALL   1070
37A4:  MOVLB  2
....................                   } 
....................                } 
....................                // There is no data in this packet, and thus it 
....................                // can be thrown away. 
....................                else { 
37A6:  BRA    37B0
....................                   MACDiscardRx(); 
37A8:  MOVLB  0
37AA:  CALL   1070
37AE:  MOVLB  2
....................                } 
....................             } 
....................             // Connection is not established; check if we've sent 
....................             // a FIN and expect our last ACK 
....................             else if (ps->smState == TCP_LAST_ACK) { 
37B0:  BRA    39A0
37B2:  MOVFF  237,FE9
37B6:  MOVFF  238,FEA
37BA:  MOVF   FEF,W
37BC:  SUBLW  09
37BE:  BNZ   37EA
....................                MACDiscardRx(); 
37C0:  MOVLB  0
37C2:  CALL   1070
....................  
....................                if (h->Flags.bits.flagACK) { 
37C6:  MOVLW  0D
37C8:  MOVLB  2
37CA:  ADDWF  x23,W
37CC:  MOVWF  FE9
37CE:  MOVLW  00
37D0:  ADDWFC x24,W
37D2:  MOVWF  FEA
37D4:  BTFSS  FEF.4
37D6:  BRA    37E8
....................                   CloseSocket(ps); 
37D8:  MOVFF  238,23F
37DC:  MOVFF  237,23E
37E0:  MOVLB  0
37E2:  CALL   27F6
37E6:  MOVLB  2
....................                } 
....................             } 
....................             else if (ps->smState == TCP_FIN_WAIT_1) { 
37E8:  BRA    39A0
37EA:  MOVFF  237,FE9
37EE:  MOVFF  238,FEA
37F2:  MOVF   FEF,W
37F4:  SUBLW  04
37F6:  BNZ   38CC
....................                MACDiscardRx(); 
37F8:  MOVLB  0
37FA:  CALL   1070
....................  
....................                if (h->Flags.bits.flagFIN) { 
37FE:  MOVLW  0D
3800:  MOVLB  2
3802:  ADDWF  x23,W
3804:  MOVWF  FE9
3806:  MOVLW  00
3808:  ADDWFC x24,W
380A:  MOVWF  FEA
380C:  BTFSS  FEF.0
380E:  BRA    38AA
....................                   flags = ACK; 
3810:  MOVLW  10
3812:  MOVWF  x39
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................                   ps->SND_ACK += 1; 
3814:  MOVLW  1A
3816:  ADDWF  x37,W
3818:  MOVWF  FE9
381A:  MOVLW  00
381C:  ADDWFC x38,W
381E:  MOVWF  FEA
3820:  MOVLW  01
3822:  ADDWF  FEF,W
3824:  MOVWF  00
3826:  MOVLW  00
3828:  ADDWFC FEC,W
382A:  MOVWF  01
382C:  MOVLW  00
382E:  ADDWFC FEC,W
3830:  MOVWF  02
3832:  MOVLW  00
3834:  ADDWFC FEC,W
3836:  MOVF   FED,F
3838:  MOVF   FED,F
383A:  MOVF   FED,F
383C:  MOVFF  00,FEF
3840:  MOVFF  01,FEC
3844:  MOVFF  02,FEC
3848:  MOVWF  FEC
....................                   ack = ps->SND_ACK; 
384A:  MOVLW  1A
384C:  ADDWF  x37,W
384E:  MOVWF  FE9
3850:  MOVLW  00
3852:  ADDWFC x38,W
3854:  MOVWF  FEA
3856:  MOVFF  FEF,00
385A:  MOVFF  FEC,01
385E:  MOVFF  FEC,02
3862:  MOVFF  FEC,03
3866:  MOVFF  03,22A
386A:  MOVFF  02,229
386E:  MOVFF  01,228
3872:  MOVFF  00,227
....................                   if (h->Flags.bits.flagACK) { 
3876:  MOVLW  0D
3878:  ADDWF  x23,W
387A:  MOVWF  FE9
387C:  MOVLW  00
387E:  ADDWFC x24,W
3880:  MOVWF  FEA
3882:  BTFSS  FEF.4
3884:  BRA    3898
....................                      CloseSocket(ps); 
3886:  MOVFF  238,23F
388A:  MOVFF  237,23E
388E:  MOVLB  0
3890:  CALL   27F6
....................                   } 
....................                   else { 
3894:  BRA    38A6
3896:  MOVLB  2
....................                      ps->smState = TCP_CLOSING; 
3898:  MOVFF  237,FE9
389C:  MOVFF  238,FEA
38A0:  MOVLW  06
38A2:  MOVWF  FEF
38A4:  MOVLB  0
....................                   } 
....................                } 
....................                else if (h->Flags.bits.flagACK) { 
38A6:  BRA    38C8
38A8:  MOVLB  2
38AA:  MOVLW  0D
38AC:  ADDWF  x23,W
38AE:  MOVWF  FE9
38B0:  MOVLW  00
38B2:  ADDWFC x24,W
38B4:  MOVWF  FEA
38B6:  BTFSS  FEF.4
38B8:  BRA    38C6
....................                   ps->smState = TCP_FIN_WAIT_2; 
38BA:  MOVFF  237,FE9
38BE:  MOVFF  238,FEA
38C2:  MOVLW  05
38C4:  MOVWF  FEF
38C6:  MOVLB  0
....................                } 
....................             } 
....................             else if (ps->smState == TCP_FIN_WAIT_2) { 
38C8:  BRA    399E
38CA:  MOVLB  2
38CC:  MOVFF  237,FE9
38D0:  MOVFF  238,FEA
38D4:  MOVF   FEF,W
38D6:  SUBLW  05
38D8:  BNZ   396A
....................                MACDiscardRx(); 
38DA:  MOVLB  0
38DC:  CALL   1070
....................  
....................                if (h->Flags.bits.flagFIN) { 
38E0:  MOVLW  0D
38E2:  MOVLB  2
38E4:  ADDWF  x23,W
38E6:  MOVWF  FE9
38E8:  MOVLW  00
38EA:  ADDWFC x24,W
38EC:  MOVWF  FEA
38EE:  BTFSS  FEF.0
38F0:  BRA    3968
....................                   flags = ACK; 
38F2:  MOVLW  10
38F4:  MOVWF  x39
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................                   ps->SND_ACK += 1; 
38F6:  MOVLW  1A
38F8:  ADDWF  x37,W
38FA:  MOVWF  FE9
38FC:  MOVLW  00
38FE:  ADDWFC x38,W
3900:  MOVWF  FEA
3902:  MOVLW  01
3904:  ADDWF  FEF,W
3906:  MOVWF  00
3908:  MOVLW  00
390A:  ADDWFC FEC,W
390C:  MOVWF  01
390E:  MOVLW  00
3910:  ADDWFC FEC,W
3912:  MOVWF  02
3914:  MOVLW  00
3916:  ADDWFC FEC,W
3918:  MOVF   FED,F
391A:  MOVF   FED,F
391C:  MOVF   FED,F
391E:  MOVFF  00,FEF
3922:  MOVFF  01,FEC
3926:  MOVFF  02,FEC
392A:  MOVWF  FEC
....................                   ack = ps->SND_ACK; 
392C:  MOVLW  1A
392E:  ADDWF  x37,W
3930:  MOVWF  FE9
3932:  MOVLW  00
3934:  ADDWFC x38,W
3936:  MOVWF  FEA
3938:  MOVFF  FEF,00
393C:  MOVFF  FEC,01
3940:  MOVFF  FEC,02
3944:  MOVFF  FEC,03
3948:  MOVFF  03,22A
394C:  MOVFF  02,229
3950:  MOVFF  01,228
3954:  MOVFF  00,227
....................                   CloseSocket(ps); 
3958:  MOVFF  238,23F
395C:  MOVFF  237,23E
3960:  MOVLB  0
3962:  CALL   27F6
3966:  MOVLB  2
....................                } 
....................             } 
....................             else if (ps->smState == TCP_CLOSING) { 
3968:  BRA    39A0
396A:  MOVFF  237,FE9
396E:  MOVFF  238,FEA
3972:  MOVF   FEF,W
3974:  SUBLW  06
3976:  BNZ   39A0
....................                MACDiscardRx(); 
3978:  MOVLB  0
397A:  CALL   1070
....................  
....................                if (h->Flags.bits.flagACK) { 
397E:  MOVLW  0D
3980:  MOVLB  2
3982:  ADDWF  x23,W
3984:  MOVWF  FE9
3986:  MOVLW  00
3988:  ADDWFC x24,W
398A:  MOVWF  FEA
398C:  BTFSS  FEF.4
398E:  BRA    39A0
....................                   CloseSocket(ps); 
3990:  MOVFF  238,23F
3994:  MOVFF  237,23E
3998:  MOVLB  0
399A:  CALL   27F6
399E:  MOVLB  2
....................                } 
....................             } 
....................          } 
....................       } 
....................       // This packet's sequence number does not match what we were 
....................       // expecting (the last value we ACKed).  Throw this packet 
....................       // away.  This may happen if packets are delivered out of order. 
....................       // Not enough memory is available on our PIC or Ethernet 
....................       // controller to implement a robust stream reconstruction 
....................       // buffer.  As a result, the remote node will just have to 
....................       // retransmit its packets starting with the proper sequence number. 
....................       else { 
39A0:  BRA    39BE
....................          MACDiscardRx(); 
39A2:  MOVLB  0
39A4:  CALL   1070
....................  
....................          // Send a new ACK out in case if the previous one was lost 
....................          // (ACKs aren't ACKed).  This is required to prevent an 
....................          // unlikely but possible situation which would cause the 
....................          // connection to time out if the ACK was lost and the 
....................          // remote node keeps sending us older data than we are 
....................          // expecting. 
....................          flags = ACK; 
39A8:  MOVLW  10
39AA:  MOVLB  2
39AC:  MOVWF  x39
....................          ack = prevAck; 
39AE:  MOVFF  232,22A
39B2:  MOVFF  231,229
39B6:  MOVFF  230,228
39BA:  MOVFF  22F,227
....................       } 
....................    } 
....................  
....................    SendTCPControlPacket: if (flags) { 
39BE:  MOVF   x39,F
39C0:  BZ    3A36
....................       SendTCP(remote, h->DestPort, h->SourcePort, seq, ack, flags); 
39C2:  MOVLW  02
39C4:  ADDWF  x23,W
39C6:  MOVWF  FE9
39C8:  MOVLW  00
39CA:  ADDWFC x24,W
39CC:  MOVWF  FEA
39CE:  MOVFF  FEC,23F
39D2:  MOVF   FED,F
39D4:  MOVFF  FEF,23E
39D8:  MOVFF  223,FE9
39DC:  MOVFF  224,FEA
39E0:  MOVFF  FEC,241
39E4:  MOVF   FED,F
39E6:  MOVFF  FEF,240
39EA:  MOVFF  222,243
39EE:  MOVFF  221,242
39F2:  MOVFF  23F,245
39F6:  MOVFF  23E,244
39FA:  MOVFF  241,247
39FE:  MOVFF  240,246
3A02:  MOVFF  22E,24B
3A06:  MOVFF  22D,24A
3A0A:  MOVFF  22C,249
3A0E:  MOVFF  22B,248
3A12:  MOVFF  22A,24F
3A16:  MOVFF  229,24E
3A1A:  MOVFF  228,24D
3A1E:  MOVFF  227,24C
3A22:  MOVFF  239,250
3A26:  MOVLW  FF
3A28:  MOVWF  x51
3A2A:  CLRF   x53
3A2C:  CLRF   x52
3A2E:  MOVLB  0
3A30:  CALL   2D1C
3A34:  MOVLB  2
....................    } 
....................  
....................    /*if (debugLastState != ps->smState) 
....................     { 
....................     debug_tcp("\r\nHANDLE TCP SEG %U - ", s); 
....................     DebugTCPDisplayState(debugLastState); 
....................     debug_tcp(" -> "); 
....................     DebugTCPDisplayState(ps->smState); 
....................     }*/ 
.................... } 
3A36:  MOVLB  0
3A38:  GOTO   3BE8 (RETURN)
....................  
.................... #endif 
....................  
.................... #if STACK_USE_ICMP 
.................... #include "tcpip/icmp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.C 
....................  * Dependencies:    ICMP.h 
....................  *                  string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/30/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/29/04 SwapICMPPacket() no longer static 
....................  * Howard Schlunder      9/9/04   Added ENC28J60 DMA checksum support 
....................  * Howard Schlunder      1/5/06   Increased DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/icmp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    07/13/06 Increased MAX_ICMP_DATA to 64 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ICMP_H 
.................... #define ICMP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // Windows ping uses 32 bytes, while MAC uses 56 bytes. 
.................... //#define MAX_ICMP_DATA       (32) 
.................... #define MAX_ICMP_DATA       (64) 
....................  
.................... #define MAX_ICMP_DATA_LEN   (MAX_ICMP_DATA) 
....................  
....................  
.................... typedef enum _ICMP_CODE 
.................... { 
....................     ICMP_ECHO_REPLY = 0, 
....................     ICMP_ECHO_REQUEST = 8 
.................... } ICMP_CODE, ICMP_REQUESTS; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPIsTxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is ready 
....................  *                  FALSE if transmit buffer is not ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define ICMPIsTxReady()     MACIsTxReady(TRUE) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... //#define debug_icmp 
.................... //#define debug_icmp   debug_printf 
.................... #define debug_icmp(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................  
.................... //#define MAX_ICMP_DATA       32 //moved to icmp.h 
....................  
.................... /* 
....................  * ICMP packet definition 
....................  */ 
.................... typedef struct _ICMP_PACKET 
.................... { 
....................     BYTE    Type; 
....................     BYTE    Code; 
....................     WORD    Checksum; 
....................     WORD    Identifier; 
....................     WORD    SequenceNumber; 
....................     BYTE    Data[MAX_ICMP_DATA]; 
.................... } ICMP_PACKET; 
.................... #define ICMP_HEADER_SIZE    (sizeof(ICMP_PACKET) - MAX_ICMP_DATA) 
....................  
.................... static void SwapICMPPacket(ICMP_PACKET* p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq) 
.................... { 
....................     ICMP_PACKET packet; 
....................     WORD CalcChecksum; 
....................     WORD ReceivedChecksum; 
.................... #if !defined(MCHP_MAC) 
....................     WORD checksums[2]; 
.................... #endif 
....................  
....................     debug_icmp(debug_putc, "\r\nICMP GET "); 
....................  
....................     // Obtain the ICMP Header 
....................     MACGetArray((BYTE*)&packet, ICMP_HEADER_SIZE); 
*
3CDA:  MOVLW  02
3CDC:  MOVLB  2
3CDE:  MOVWF  x4D
3CE0:  CLRF   x4C
3CE2:  MOVWF  x89
3CE4:  MOVFF  24C,288
3CE8:  CLRF   x8B
3CEA:  MOVLW  08
3CEC:  MOVWF  x8A
3CEE:  MOVLB  0
3CF0:  CALL   1110
....................  
....................  
.................... #if defined(MCHP_MAC) 
....................    // Calculate the checksum using the Microchip MAC's DMA module 
....................    // The checksum data includes the precomputed checksum in the 
....................    // header, so a valid packet will always have a checksum of 
....................    // 0x0000 if the packet is not disturbed. 
....................    ReceivedChecksum = 0x0000; 
3CF4:  MOVLB  2
3CF6:  CLRF   x4B
3CF8:  CLRF   x4A
....................    CalcChecksum = MACCalcRxChecksum(0+sizeof(IP_HEADER), *len); 
3CFA:  MOVFF  1FB,03
3CFE:  MOVFF  1FA,FE9
3D02:  MOVFF  1FB,FEA
3D06:  MOVFF  FEF,24C
3D0A:  MOVLB  2
3D0C:  CLRF   x4E
3D0E:  MOVLW  14
3D10:  MOVWF  x4D
3D12:  CLRF   x50
3D14:  MOVFF  24C,24F
3D18:  MOVLB  0
3D1A:  CALL   1CAE
3D1E:  MOVFF  02,249
3D22:  MOVFF  01,248
.................... #endif 
....................  
....................    // Obtain the ICMP data payload 
....................     *len -= ICMP_HEADER_SIZE; 
3D26:  MOVLB  1
3D28:  MOVFF  1FA,FE9
3D2C:  MOVFF  1FB,FEA
3D30:  MOVLW  08
3D32:  SUBWF  FEF,W
3D34:  MOVWF  FEF
....................     MACGetArray(data, *len); 
3D36:  MOVFF  1FB,03
3D3A:  MOVFF  1FA,FE9
3D3E:  MOVFF  1FB,FEA
3D42:  MOVFF  FEF,24C
3D46:  MOVFF  1F9,289
3D4A:  MOVFF  1F8,288
3D4E:  MOVLB  2
3D50:  CLRF   x8B
3D52:  MOVFF  24C,28A
3D56:  MOVLB  0
3D58:  CALL   1110
....................  
....................  
.................... #if !defined(MCHP_MAC) 
....................    // Calculte the checksum in local memory without hardware help 
....................     ReceivedChecksum = packet.Checksum; 
....................     packet.Checksum = 0; 
....................  
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&packet, ICMP_HEADER_SIZE); 
....................     checksums[1] = ~CalcIPChecksum(data, *len); 
....................  
....................     CalcChecksum = CalcIPChecksum((BYTE*)checksums, 2 * sizeof(WORD)); 
.................... #endif 
....................  
....................     SwapICMPPacket(&packet); 
3D5C:  MOVLW  02
3D5E:  MOVLB  2
3D60:  MOVWF  x4D
3D62:  CLRF   x4C
3D64:  MOVLB  0
3D66:  RCALL  3BFA
....................  
....................     *code = packet.Type; 
3D68:  MOVLB  1
3D6A:  MOVFF  1F6,FE9
3D6E:  MOVFF  1F7,FEA
3D72:  MOVFF  200,FEF
....................     *id = packet.Identifier; 
3D76:  MOVFF  1FC,FE9
3D7A:  MOVFF  1FD,FEA
3D7E:  MOVFF  205,FEC
3D82:  MOVF   FED,F
3D84:  MOVFF  204,FEF
....................     *seq = packet.SequenceNumber; 
3D88:  MOVFF  1FE,FE9
3D8C:  MOVFF  1FF,FEA
3D90:  MOVFF  207,FEC
3D94:  MOVF   FED,F
3D96:  MOVFF  206,FEF
....................  
....................     debug_icmp(debug_putc, "%U", CalcChecksum == ReceivedChecksum); 
....................  
....................     return ( CalcChecksum == ReceivedChecksum ); 
3D9A:  MOVLB  2
3D9C:  MOVF   x4A,W
3D9E:  SUBWF  x48,W
3DA0:  BNZ   3DA8
3DA2:  MOVF   x4B,W
3DA4:  SUBWF  x49,W
3DA6:  BZ    3DAC
3DA8:  MOVLW  00
3DAA:  BRA    3DAE
3DAC:  MOVLW  01
3DAE:  MOVWF  01
.................... } 
3DB0:  MOVLB  0
3DB2:  GOTO   44F8 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq) 
.................... { 
....................     ICMP_PACKET   packet; 
....................     WORD ICMPLen; 
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
3DB6:  MOVLW  01
3DB8:  MOVLB  2
3DBA:  MOVWF  x7A
3DBC:  MOVLB  0
3DBE:  CALL   14D4
3DC2:  MOVFF  01,248
....................  
....................    // Abort if there is no where in the Ethernet controller to 
....................    // store this packet. 
....................    if(MyTxBuffer == INVALID_BUFFER) 
3DC6:  MOVLB  2
3DC8:  INCFSZ x48,W
3DCA:  BRA    3DCE
....................       return; 
3DCC:  BRA    3ECC
....................  
....................    IPSetTxBuffer(MyTxBuffer, 0); 
3DCE:  MOVFF  248,293
3DD2:  CLRF   x95
3DD4:  MOVLW  14
3DD6:  MOVWF  x94
3DD8:  MOVLB  0
3DDA:  CALL   14FC
....................  
....................  
....................    ICMPLen = ICMP_HEADER_SIZE + (WORD)len; 
3DDE:  CLRF   03
3DE0:  MOVLB  1
3DE2:  MOVF   xF9,W
3DE4:  ADDLW  08
3DE6:  MOVLB  2
3DE8:  MOVWF  x46
3DEA:  MOVLW  00
3DEC:  ADDWFC 03,W
3DEE:  MOVWF  x47
....................  
....................     packet.Code             = 0; 
3DF0:  MOVLB  1
3DF2:  CLRF   xFF
....................     packet.Type             = code; 
3DF4:  MOVFF  1F6,1FE
....................     packet.Checksum         = 0; 
3DF8:  MOVLB  2
3DFA:  CLRF   x01
3DFC:  CLRF   x00
....................     packet.Identifier       = id; 
3DFE:  MOVFF  1FB,203
3E02:  MOVFF  1FA,202
....................     packet.SequenceNumber   = seq; 
3E06:  MOVFF  1FD,205
3E0A:  MOVFF  1FC,204
....................  
....................     memcpy((void*)packet.Data, (void*)data, len); 
3E0E:  MOVLW  02
3E10:  MOVWF  FEA
3E12:  MOVLW  06
3E14:  MOVWF  FE9
3E16:  MOVFF  1F8,FE2
3E1A:  MOVFF  1F7,FE1
3E1E:  MOVLB  1
3E20:  MOVF   xF9,W
3E22:  MOVWF  01
3E24:  BZ    3E2E
3E26:  MOVFF  FE6,FEE
3E2A:  DECFSZ 01,F
3E2C:  BRA    3E26
....................  
....................     SwapICMPPacket(&packet); 
3E2E:  MOVLW  01
3E30:  MOVLB  2
3E32:  MOVWF  x4D
3E34:  MOVLW  FE
3E36:  MOVWF  x4C
3E38:  MOVLB  0
3E3A:  RCALL  3BFA
....................  
.................... #if !defined(MCHP_MAC) 
....................     packet.Checksum         = CalcIPChecksum((BYTE*)&packet, 
....................                                     ICMPLen); 
.................... #endif 
....................  
....................     IPPutHeader(remote, 
....................                 IP_PROT_ICMP, 
....................                 (WORD)(ICMP_HEADER_SIZE + len)); 
3E3C:  MOVLW  08
3E3E:  MOVLB  1
3E40:  ADDWF  xF9,W
3E42:  MOVLB  2
3E44:  CLRF   x4A
3E46:  MOVWF  x49
3E48:  MOVFF  1F5,27B
3E4C:  MOVFF  1F4,27A
3E50:  MOVLW  01
3E52:  MOVWF  x7C
3E54:  MOVFF  24A,27E
3E58:  MOVFF  249,27D
3E5C:  MOVLB  0
3E5E:  CALL   2BEC
....................  
....................     IPPutArray((BYTE*)&packet, ICMPLen); 
3E62:  MOVLW  01
3E64:  MOVLB  2
3E66:  MOVWF  x4A
3E68:  MOVLW  FE
3E6A:  MOVFF  24A,29F
3E6E:  MOVWF  x9E
3E70:  MOVFF  247,2A1
3E74:  MOVFF  246,2A0
3E78:  MOVLB  0
3E7A:  CALL   15F8
....................  
.................... #if defined(MCHP_MAC) 
....................     // Calculate and write the ICMP checksum using the Microchip MAC's DMA 
....................    packet.Checksum = MACCalcTxChecksum(sizeof(IP_HEADER), ICMPLen); 
3E7E:  MOVLB  2
3E80:  CLRF   x94
3E82:  MOVLW  14
3E84:  MOVWF  x93
3E86:  MOVFF  247,296
3E8A:  MOVFF  246,295
3E8E:  MOVLB  0
3E90:  CALL   2AB8
3E94:  MOVFF  02,201
3E98:  MOVFF  01,200
....................    IPSetTxBuffer(MyTxBuffer, 2); 
3E9C:  MOVFF  248,293
3EA0:  MOVLB  2
3EA2:  CLRF   x95
3EA4:  MOVLW  16
3EA6:  MOVWF  x94
3EA8:  MOVLB  0
3EAA:  CALL   14FC
....................    MACPutArray((BYTE*)&packet.Checksum, 2); 
3EAE:  MOVLW  02
3EB0:  MOVLB  2
3EB2:  MOVWF  x4A
3EB4:  CLRF   x49
3EB6:  MOVWF  x9F
3EB8:  MOVFF  249,29E
3EBC:  CLRF   xA1
3EBE:  MOVWF  xA0
3EC0:  MOVLB  0
3EC2:  CALL   15F8
.................... #endif 
....................  
....................  
....................     MACFlush(); 
3EC6:  CALL   1758
3ECA:  MOVLB  2
.................... } 
3ECC:  MOVLB  0
3ECE:  GOTO   4550 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void SwapICMPPacket(ICMP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p - ICMP packet header 
....................  * 
....................  * Output:          ICMP packet is swapped 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void SwapICMPPacket(ICMP_PACKET* p) 
.................... { 
....................     p->Identifier           = swaps(p->Identifier); 
*
3BFA:  MOVLW  04
3BFC:  MOVLB  2
3BFE:  ADDWF  x4C,W
3C00:  MOVWF  01
3C02:  MOVLW  00
3C04:  ADDWFC x4D,W
3C06:  MOVWF  03
3C08:  MOVFF  01,24E
3C0C:  MOVWF  x4F
3C0E:  MOVLW  04
3C10:  ADDWF  x4C,W
3C12:  MOVWF  FE9
3C14:  MOVLW  00
3C16:  ADDWFC x4D,W
3C18:  MOVWF  FEA
3C1A:  MOVFF  FEC,251
3C1E:  MOVF   FED,F
3C20:  MOVFF  FEF,250
3C24:  MOVFF  251,29A
3C28:  MOVFF  250,299
3C2C:  MOVLB  0
3C2E:  CALL   118C
3C32:  MOVFF  24F,FEA
3C36:  MOVFF  24E,FE9
3C3A:  MOVFF  02,FEC
3C3E:  MOVF   FED,F
3C40:  MOVFF  01,FEF
....................     p->SequenceNumber       = swaps(p->SequenceNumber); 
3C44:  MOVLW  06
3C46:  MOVLB  2
3C48:  ADDWF  x4C,W
3C4A:  MOVWF  01
3C4C:  MOVLW  00
3C4E:  ADDWFC x4D,W
3C50:  MOVWF  03
3C52:  MOVFF  01,24E
3C56:  MOVWF  x4F
3C58:  MOVLW  06
3C5A:  ADDWF  x4C,W
3C5C:  MOVWF  FE9
3C5E:  MOVLW  00
3C60:  ADDWFC x4D,W
3C62:  MOVWF  FEA
3C64:  MOVFF  FEC,251
3C68:  MOVF   FED,F
3C6A:  MOVFF  FEF,250
3C6E:  MOVFF  251,29A
3C72:  MOVFF  250,299
3C76:  MOVLB  0
3C78:  CALL   118C
3C7C:  MOVFF  24F,FEA
3C80:  MOVFF  24E,FE9
3C84:  MOVFF  02,FEC
3C88:  MOVF   FED,F
3C8A:  MOVFF  01,FEF
....................     p->Checksum             = swaps(p->Checksum); 
3C8E:  MOVLW  02
3C90:  MOVLB  2
3C92:  ADDWF  x4C,W
3C94:  MOVWF  01
3C96:  MOVLW  00
3C98:  ADDWFC x4D,W
3C9A:  MOVWF  03
3C9C:  MOVFF  01,24E
3CA0:  MOVWF  x4F
3CA2:  MOVLW  02
3CA4:  ADDWF  x4C,W
3CA6:  MOVWF  FE9
3CA8:  MOVLW  00
3CAA:  ADDWFC x4D,W
3CAC:  MOVWF  FEA
3CAE:  MOVFF  FEC,251
3CB2:  MOVF   FED,F
3CB4:  MOVFF  FEF,250
3CB8:  MOVFF  251,29A
3CBC:  MOVFF  250,299
3CC0:  MOVLB  0
3CC2:  CALL   118C
3CC6:  MOVFF  24F,FEA
3CCA:  MOVFF  24E,FE9
3CCE:  MOVFF  02,FEC
3CD2:  MOVF   FED,F
3CD4:  MOVFF  01,FEF
.................... } 
3CD8:  RETLW  00
....................  
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
.................... #include "tcpip/udp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #include "tcpip/dhcp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
.................... #include "tcpip/telnet2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
.................... #include "tcpip/arptsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.c 
....................  * Dependencies:    compiler.h 
....................  *                  string.h 
....................  *                  ARP.h 
....................  *                  ARPTsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A macdiscardrx() added to arpprocess() to handle times when an eth packet with arp has padding bytes at the end 
....................  * Darren Rook (CCS)    06/28/04 ArpInit clears cache like in 2.20 
....................  * Darren Rook (CCS)    06/29/04 smArp, Cache no longer static 
....................  * Darren Rook (CCS)    07/12/06 MACDiscardRx spelled wrong (case) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  *                               I am assuming STACK_CLIENT_MODE is TRUE for ARP. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/arptsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ARP_TSK_H 
.................... #define ARP_TSK_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arptask 
.................... //#define debug_arptask   debug_printf 
....................  
.................... /* 
....................  * ARP Task FSM States 
....................  */ 
.................... typedef enum _ARP_STATE 
.................... { 
....................     SM_ARP_IDLE, 
....................     SM_ARP_REPLY 
.................... } ARP_STATE; 
....................  
....................  
.................... /* 
....................  * This ARP task caches one ARP response. 
....................  */ 
.................... static ARP_STATE smARP; 
....................  
.................... static NODE_INFO Cache; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void) 
.................... { 
....................     smARP = SM_ARP_IDLE; 
*
05BE:  BCF    x83.1
....................  
....................     Cache.MACAddr.v[0] = 0xff; 
05C0:  MOVLW  FF
05C2:  MOVLB  1
05C4:  MOVWF  x40
....................     Cache.MACAddr.v[1] = 0xff; 
05C6:  MOVWF  x41
....................     Cache.MACAddr.v[2] = 0xff; 
05C8:  MOVWF  x42
....................     Cache.MACAddr.v[3] = 0xff; 
05CA:  MOVWF  x43
....................     Cache.MACAddr.v[4] = 0xff; 
05CC:  MOVWF  x44
....................     Cache.MACAddr.v[5] = 0xff; 
05CE:  MOVWF  x45
....................  
....................     Cache.IPAddr.Val = 0x0; 
05D0:  CLRF   x49
05D2:  CLRF   x48
05D4:  CLRF   x47
05D6:  CLRF   x46
.................... } 
05D8:  MOVLB  0
05DA:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void) 
.................... { 
....................     NODE_INFO remoteNode; 
....................     BYTE opCode; 
....................  
....................     switch(smARP) 
....................     { 
*
1C18:  MOVLW  00
1C1A:  BTFSC  x83.1
1C1C:  MOVLW  01
1C1E:  XORLW  00
1C20:  BZ    1C24
1C22:  BRA    1C86
....................     case SM_ARP_IDLE: 
....................         if ( !ARPGet(&remoteNode, &opCode) ) 
1C24:  MOVLW  01
1C26:  MOVLB  2
1C28:  MOVWF  x00
1C2A:  MOVLW  F4
1C2C:  MOVLB  1
1C2E:  MOVWF  xFF
1C30:  MOVLW  01
1C32:  MOVLB  2
1C34:  MOVWF  x02
1C36:  MOVLW  FE
1C38:  MOVWF  x01
1C3A:  MOVLB  0
1C3C:  GOTO   13EC
1C40:  MOVF   01,F
1C42:  BNZ   1C46
....................             break; 
1C44:  BRA    1CA6
....................  
....................          //dsr add 071204 
....................          //dsr fix 071206 
....................          MACDiscardRx(); 
1C46:  CALL   1070
....................  
....................         if ( opCode == ARP_REPLY ) 
1C4A:  MOVLB  1
1C4C:  MOVF   xFE,F
1C4E:  BNZ   1C82
....................         { 
.................... 			Cache.MACAddr = remoteNode.MACAddr; 
1C50:  MOVLW  01
1C52:  MOVWF  FEA
1C54:  MOVLW  40
1C56:  MOVWF  FE9
1C58:  MOVLW  01
1C5A:  MOVWF  FE2
1C5C:  MOVLW  F4
1C5E:  MOVWF  FE1
1C60:  MOVLW  06
1C62:  MOVWF  01
1C64:  MOVFF  FE6,FEE
1C68:  DECFSZ 01,F
1C6A:  BRA    1C64
....................             Cache.IPAddr.Val = remoteNode.IPAddr.Val; 
1C6C:  MOVFF  1FD,149
1C70:  MOVFF  1FC,148
1C74:  MOVFF  1FB,147
1C78:  MOVFF  1FA,146
....................             break; 
1C7C:  MOVLB  0
1C7E:  BRA    1CA6
....................         } 
....................         else 
1C80:  BRA    1C86
....................             smARP = SM_ARP_REPLY; 
1C82:  MOVLB  0
1C84:  BSF    x83.1
....................  
....................     default: 
.................... 		if(ARPPut(&remoteNode, ARP_REPLY)) 
1C86:  MOVLW  01
1C88:  MOVLB  2
1C8A:  MOVWF  x18
1C8C:  MOVLW  F4
1C8E:  MOVWF  x17
1C90:  CLRF   x19
1C92:  MOVLB  0
1C94:  RCALL  1A8A
1C96:  MOVF   01,F
1C98:  BZ    1C9E
.................... 		{ 
.................... 			smARP = SM_ARP_IDLE; 
1C9A:  BCF    x83.1
.................... 		} 
....................         else 
1C9C:  BRA    1CA4
....................             return FALSE; 
1C9E:  MOVLW  00
1CA0:  MOVWF  01
1CA2:  BRA    1CAA
....................         break; 
1CA4:  BRA    1CA6
....................  
....................     } 
....................     return TRUE; 
1CA6:  MOVLW  01
1CA8:  MOVWF  01
.................... } 
1CAA:  GOTO   441C (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    MACIsTxReady(TRUE) returns TRUE 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr) 
.................... { 
....................     NODE_INFO remoteNode; 
....................  
....................     remoteNode.IPAddr = *IPAddr; 
*
4B7E:  MOVLB  2
4B80:  MOVFF  20B,FE9
4B84:  MOVFF  20C,FEA
4B88:  MOVFF  FEF,00
4B8C:  MOVFF  FEC,01
4B90:  MOVFF  FEC,02
4B94:  MOVFF  FEC,03
4B98:  MOVFF  03,216
4B9C:  MOVFF  02,215
4BA0:  MOVFF  01,214
4BA4:  MOVFF  00,213
....................  
....................     ARPPut(&remoteNode, ARP_REQUEST); 
4BA8:  MOVLW  02
4BAA:  MOVWF  x18
4BAC:  MOVLW  0D
4BAE:  MOVWF  x17
4BB0:  MOVLW  01
4BB2:  MOVWF  x19
4BB4:  MOVLB  0
4BB6:  CALL   1A8A
.................... } 
4BBA:  GOTO   60C0 (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr) 
.................... { 
....................     if(Cache.IPAddr.Val == IPAddr->Val || Cache.IPAddr.Val == AppConfig.MyGateway.Val) 
4BBE:  MOVLB  2
4BC0:  MOVFF  20B,FE9
4BC4:  MOVFF  20C,FEA
4BC8:  MOVFF  FEF,00
4BCC:  MOVFF  FEC,01
4BD0:  MOVFF  FEC,02
4BD4:  MOVFF  FEC,03
4BD8:  MOVF   00,W
4BDA:  MOVLB  1
4BDC:  SUBWF  x46,W
4BDE:  BNZ   4BF2
4BE0:  MOVF   01,W
4BE2:  SUBWF  x47,W
4BE4:  BNZ   4BF2
4BE6:  MOVF   02,W
4BE8:  SUBWF  x48,W
4BEA:  BNZ   4BF2
4BEC:  MOVF   03,W
4BEE:  SUBWF  x49,W
4BF0:  BZ    4C0A
4BF2:  MOVF   51,W
4BF4:  SUBWF  x46,W
4BF6:  BNZ   4C34
4BF8:  MOVF   52,W
4BFA:  SUBWF  x47,W
4BFC:  BNZ   4C34
4BFE:  MOVF   53,W
4C00:  SUBWF  x48,W
4C02:  BNZ   4C34
4C04:  MOVF   54,W
4C06:  SUBWF  x49,W
4C08:  BNZ   4C34
....................     { 
....................         *MACAddr = Cache.MACAddr; 
4C0A:  MOVFF  20E,03
4C0E:  MOVLB  2
4C10:  MOVFF  20D,FE9
4C14:  MOVFF  20E,FEA
4C18:  MOVLW  01
4C1A:  MOVWF  FE2
4C1C:  MOVLW  40
4C1E:  MOVWF  FE1
4C20:  MOVLW  06
4C22:  MOVWF  01
4C24:  MOVFF  FE6,FEE
4C28:  DECFSZ 01,F
4C2A:  BRA    4C24
....................         return TRUE; 
4C2C:  MOVLW  01
4C2E:  MOVWF  01
4C30:  BRA    4C3A
4C32:  MOVLB  1
....................     } 
....................     return FALSE; 
4C34:  MOVLW  00
4C36:  MOVWF  01
4C38:  MOVLB  2
.................... } 
4C3A:  MOVLB  0
4C3C:  GOTO   60EE (RETURN)
....................  
....................  
....................  
.................... #include "tcpip/arp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.c 
....................  * Dependencies:    string.h 
....................  *                  stacktsk.h 
....................  *                  helpers.h 
....................  *                  arp.h 
....................  *                  mac.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................  EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
.................... #if defined(__PCH__) 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
.................... #else 
.................... #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
.................... #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
.................... #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
.................... #undef STACK_USE_MAC 
.................... #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_PPP 
.................... #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
.................... #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
.................... #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
.................... #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
.................... #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
.................... #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
.................... #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
.................... #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
.................... #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
.................... #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
.................... #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
.................... #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
.................... #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
.................... #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
.................... #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
.................... #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
.................... #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
.................... #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
.................... #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
.................... #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
.................... #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #undef STACK_USE_DHCP 
.................... #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
.................... #if defined(STACK_USE_UDP) 
.................... #undef STACK_USE_UDP 
.................... #endif 
.................... #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
.................... #if defined(STACK_USE_ICMP) 
.................... #undef STACK_USE_ICMP 
.................... #endif 
.................... #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #define MCHP_MAC 
.................... #endif 
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
.................... #if STACK_USE_DHCP 
.................... #error DHCP cannot be used when SLIP is enabled. 
.................... #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     1 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 1 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
.................... #if (MAX_UDP_SOCKETS < 1) 
.................... #error Set MAX_UDP_SOCKETS to at least one. 
.................... #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................    BYTE Val; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................    }bits; 
.................... }BYTE_VAL; 
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................    int32 Val; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................       int8 USB; 
....................    }bytes; 
.................... }SWORD_VAL; 
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................    int16 Val; 
....................    int8 v[2]; 
....................    struct 
....................    { 
....................       int8 LSB; 
....................       int8 MSB; 
....................    }bytes; 
.................... }WORD_VAL; 
....................  
.................... /* 
....................  typedef union _DWORD_VAL 
....................  { 
....................  int32 Val; 
....................  int8 v[4]; 
....................  } DWORD_VAL; 
....................  */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................    DWORD Val; 
....................    WORD w[2]; 
....................    BYTE v[4]; 
....................    struct 
....................    { 
....................       WORD LW; 
....................       WORD HW; 
....................    }word; 
....................    struct 
....................    { 
....................       BYTE LB; 
....................       BYTE HB; 
....................       BYTE UB; 
....................       BYTE MB; 
....................    }byte; 
....................    struct 
....................    { 
....................       unsigned char b0:1; 
....................       unsigned char b1:1; 
....................       unsigned char b2:1; 
....................       unsigned char b3:1; 
....................       unsigned char b4:1; 
....................       unsigned char b5:1; 
....................       unsigned char b6:1; 
....................       unsigned char b7:1; 
....................       unsigned char b8:1; 
....................       unsigned char b9:1; 
....................       unsigned char b10:1; 
....................       unsigned char b11:1; 
....................       unsigned char b12:1; 
....................       unsigned char b13:1; 
....................       unsigned char b14:1; 
....................       unsigned char b15:1; 
....................       unsigned char b16:1; 
....................       unsigned char b17:1; 
....................       unsigned char b18:1; 
....................       unsigned char b19:1; 
....................       unsigned char b20:1; 
....................       unsigned char b21:1; 
....................       unsigned char b22:1; 
....................       unsigned char b23:1; 
....................       unsigned char b24:1; 
....................       unsigned char b25:1; 
....................       unsigned char b26:1; 
....................       unsigned char b27:1; 
....................       unsigned char b28:1; 
....................       unsigned char b29:1; 
....................       unsigned char b30:1; 
....................       unsigned char b31:1; 
....................    }bits; 
.................... }DWORD_VAL; 
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................    BYTE v[6]; 
.................... }MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................    BYTE v[4]; 
....................    DWORD Val; 
.................... }IP_ADDR; 
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................    MAC_ADDR MACAddr; 
....................    IP_ADDR IPAddr; 
.................... }NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................    IP_ADDR MyIPAddr; 
....................    MAC_ADDR MyMACAddr; 
....................    IP_ADDR MyMask; 
....................    IP_ADDR MyGateway; 
....................    IP_ADDR PrimaryDNSServer; 
....................    struct 
....................    { 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    }Flags; 
....................    WORD_VAL SerialNumber; 
....................    IP_ADDR SMTPServerAddr;     // Not used. 
....................    IP_ADDR TFTPServerAddr;// Not used. 
....................    BYTE NetBIOSName[16]; 
.................... }APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
....................  { 
....................  struct 
....................  { 
....................  int1 bInConfigMode : 1; 
....................  } bits; 
....................  int8 Val; 
....................  } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
.................... #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
.................... #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... //#define debug_arp 
.................... //#define debug_arp debug_printf 
.................... #define debug_arp(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................  
.................... // ARP Operation codes. 
.................... #define ARP_OPERATION_REQ       0x01u 
.................... #define ARP_OPERATION_RESP      0x02u 
....................  
.................... // ETHERNET packet type as defined by IEEE 802.3 
.................... #define HW_ETHERNET             (0x0001u) 
.................... #define ARP_IP                  (0x0800u) 
....................  
....................  
....................  
.................... // ARP packet 
.................... typedef struct _ARP_PACKET 
.................... { 
....................     WORD        HardwareType; 
....................     WORD        Protocol; 
....................     BYTE        MACAddrLen; 
....................     BYTE        ProtocolLen; 
....................     WORD        Operation; 
....................     MAC_ADDR    SenderMACAddr; 
....................     IP_ADDR     SenderIPAddr; 
....................     MAC_ADDR    TargetMACAddr; 
....................     IP_ADDR     TargetIPAddr; 
.................... } ARP_PACKET; 
....................  
.................... // Helper function 
.................... static void SwapARPPacket(ARP_PACKET *p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int1 ARPGet(NODE_INFO *remote, int8 *opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................     //MACGetArray((int8*)&packet, sizeof(packet)); 
....................     MACGetArray(&packet, sizeof(ARP_PACKET)); 
*
13EC:  MOVLW  02
13EE:  MOVLB  2
13F0:  MOVWF  x89
13F2:  MOVLW  03
13F4:  MOVWF  x88
13F6:  CLRF   x8B
13F8:  MOVLW  1C
13FA:  MOVWF  x8A
13FC:  MOVLB  0
13FE:  RCALL  1110
....................  
....................     MACDiscardRx(); 
1400:  RCALL  1070
....................  
....................     SwapARPPacket(&packet); 
1402:  MOVLW  02
1404:  MOVLB  2
1406:  MOVWF  x38
1408:  MOVLW  03
140A:  MOVWF  x37
140C:  MOVLB  0
140E:  RCALL  1318
....................  
....................     /* 
....................     debug_arp(debug_putc, "\r\nARP: HW:%LX PR:%LX ML:%U PL:%U O:%LX TI:%U.%U.%U.%U FI:%U.%U.%U.%U", 
....................       packet.HardwareType, packet.Protocol, packet.MACAddrLen, packet.ProtocolLen, 
....................       packet.Operation, packet.TargetIPAddr.v[0],packet.TargetIPAddr.v[1], 
....................       packet.TargetIPAddr.v[2],packet.TargetIPAddr.v[3], 
....................       packet.SenderIPAddr.v[0],packet.SenderIPAddr.v[1],packet.SenderIPAddr.v[2],packet.SenderIPAddr.v[3]); 
.................... 	*/ 
....................     if ( packet.HardwareType != HW_ETHERNET     || 
....................          packet.MACAddrLen != sizeof(MAC_ADDR)  || 
....................          packet.ProtocolLen != sizeof(IP_ADDR) ) 
1410:  MOVLB  2
1412:  DECFSZ x03,W
1414:  BRA    1426
1416:  MOVF   x04,F
1418:  BNZ   1426
141A:  MOVF   x07,W
141C:  SUBLW  06
141E:  BNZ   1426
1420:  MOVF   x08,W
1422:  SUBLW  04
1424:  BZ    142C
....................          return FALSE; 
1426:  MOVLW  00
1428:  MOVWF  01
142A:  BRA    14CE
....................  
....................     if ( packet.Operation == ARP_OPERATION_RESP ) 
142C:  MOVF   x09,W
142E:  SUBLW  02
1430:  BNZ   1442
1432:  MOVF   x0A,F
1434:  BNZ   1442
....................         *opCode = ARP_REPLY; 
1436:  MOVFF  201,FE9
143A:  MOVFF  202,FEA
143E:  CLRF   FEF
....................     else if ( packet.Operation == ARP_OPERATION_REQ ) 
1440:  BRA    146A
1442:  DECFSZ x09,W
1444:  BRA    1458
1446:  MOVF   x0A,F
1448:  BNZ   1458
....................         *opCode = ARP_REQUEST; 
144A:  MOVFF  201,FE9
144E:  MOVFF  202,FEA
1452:  MOVLW  01
1454:  MOVWF  FEF
....................     else 
1456:  BRA    146A
....................     { 
....................         *opCode = ARP_UNKNOWN; 
1458:  MOVFF  201,FE9
145C:  MOVFF  202,FEA
1460:  MOVLW  02
1462:  MOVWF  FEF
....................         return FALSE; 
1464:  MOVLW  00
1466:  MOVWF  01
1468:  BRA    14CE
....................     } 
....................  
....................     if(packet.TargetIPAddr.Val == AppConfig.MyIPAddr.Val) 
146A:  MOVF   43,W
146C:  SUBWF  x1B,W
146E:  BNZ   14C8
1470:  MOVF   44,W
1472:  SUBWF  x1C,W
1474:  BNZ   14C8
1476:  MOVF   45,W
1478:  SUBWF  x1D,W
147A:  BNZ   14C8
147C:  MOVF   46,W
147E:  SUBWF  x1E,W
1480:  BNZ   14C8
....................     { 
....................         remote->MACAddr     = packet.SenderMACAddr; 
1482:  MOVFF  1FF,FE9
1486:  MOVLB  2
1488:  MOVFF  200,FEA
148C:  MOVLW  02
148E:  MOVWF  FE2
1490:  MOVLW  0B
1492:  MOVWF  FE1
1494:  MOVLW  06
1496:  MOVWF  01
1498:  MOVFF  FE6,FEE
149C:  DECFSZ 01,F
149E:  BRA    1498
....................         remote->IPAddr      = packet.SenderIPAddr; 
14A0:  MOVLW  06
14A2:  MOVLB  1
14A4:  ADDWF  xFF,W
14A6:  MOVWF  FE9
14A8:  MOVLW  00
14AA:  MOVLB  2
14AC:  ADDWFC x00,W
14AE:  MOVWF  FEA
14B0:  MOVFF  211,FEF
14B4:  MOVFF  212,FEC
14B8:  MOVFF  213,FEC
14BC:  MOVFF  214,FEC
....................         return TRUE; 
14C0:  MOVLW  01
14C2:  MOVWF  01
14C4:  BRA    14CE
....................     } 
....................     else 
14C6:  BRA    14CE
....................         return FALSE; 
14C8:  MOVLW  00
14CA:  MOVWF  01
14CC:  BRA    14CE
.................... } 
14CE:  MOVLB  0
14D0:  GOTO   1C40 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          TRUE - The ARP packet was generated properly 
....................  *               FALSE - Unable to allocate a TX buffer 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
*
1A8A:  MOVLW  01
1A8C:  MOVLB  2
1A8E:  MOVWF  x7A
1A90:  MOVLB  0
1A92:  RCALL  14D4
1A94:  MOVFF  01,236
....................     
....................    // Do not respond if there is no room to generate the ARP reply 
....................    if(MyTxBuffer == INVALID_BUFFER) 
1A98:  MOVLB  2
1A9A:  INCFSZ x36,W
1A9C:  BRA    1AA4
....................       return FALSE; 
1A9E:  MOVLW  00
1AA0:  MOVWF  01
1AA2:  BRA    1C14
....................  
....................    MACSetTxBuffer(MyTxBuffer, 0); 
1AA4:  MOVFF  236,293
1AA8:  CLRF   x95
1AAA:  CLRF   x94
1AAC:  MOVLB  0
1AAE:  RCALL  14FC
....................     
....................     
....................     packet.HardwareType             = HW_ETHERNET; 
1AB0:  MOVLB  2
1AB2:  CLRF   x1B
1AB4:  MOVLW  01
1AB6:  MOVWF  x1A
....................     packet.Protocol                 = ARP_IP; 
1AB8:  MOVLW  08
1ABA:  MOVWF  x1D
1ABC:  CLRF   x1C
....................     packet.MACAddrLen               = sizeof(MAC_ADDR); 
1ABE:  MOVLW  06
1AC0:  MOVWF  x1E
....................     packet.ProtocolLen              = sizeof(IP_ADDR); 
1AC2:  MOVLW  04
1AC4:  MOVWF  x1F
....................  
....................     if ( opCode == ARP_REQUEST ) 
1AC6:  DECFSZ x19,W
1AC8:  BRA    1AE0
....................     { 
....................         packet.Operation            = ARP_OPERATION_REQ; 
1ACA:  CLRF   x21
1ACC:  MOVLW  01
1ACE:  MOVWF  x20
....................         packet.TargetMACAddr.v[0]   = 0xff; 
1AD0:  MOVLW  FF
1AD2:  MOVWF  x2C
....................         packet.TargetMACAddr.v[1]   = 0xff; 
1AD4:  MOVWF  x2D
....................         packet.TargetMACAddr.v[2]   = 0xff; 
1AD6:  MOVWF  x2E
....................         packet.TargetMACAddr.v[3]   = 0xff; 
1AD8:  MOVWF  x2F
....................         packet.TargetMACAddr.v[4]   = 0xff; 
1ADA:  MOVWF  x30
....................         packet.TargetMACAddr.v[5]   = 0xff; 
1ADC:  MOVWF  x31
....................     } 
....................     else 
1ADE:  BRA    1B0E
....................     { 
....................         packet.Operation            = ARP_OPERATION_RESP; 
1AE0:  CLRF   x21
1AE2:  MOVLW  02
1AE4:  MOVWF  x20
....................         packet.TargetMACAddr        = remote->MACAddr; 
1AE6:  MOVFF  218,03
1AEA:  MOVFF  217,237
1AEE:  MOVFF  218,238
1AF2:  MOVLW  02
1AF4:  MOVWF  FEA
1AF6:  MOVLW  2C
1AF8:  MOVWF  FE9
1AFA:  MOVFF  218,FE2
1AFE:  MOVFF  217,FE1
1B02:  MOVLW  06
1B04:  MOVWF  01
1B06:  MOVFF  FE6,FEE
1B0A:  DECFSZ 01,F
1B0C:  BRA    1B06
....................     } 
....................  
....................     packet.SenderMACAddr = AppConfig.MyMACAddr; 
1B0E:  MOVLW  02
1B10:  MOVWF  FEA
1B12:  MOVLW  22
1B14:  MOVWF  FE9
1B16:  CLRF   FE2
1B18:  MOVLW  47
1B1A:  MOVWF  FE1
1B1C:  MOVLW  06
1B1E:  MOVWF  01
1B20:  MOVFF  FE6,FEE
1B24:  DECFSZ 01,F
1B26:  BRA    1B20
....................     packet.SenderIPAddr  = AppConfig.MyIPAddr; 
1B28:  MOVFF  46,22B
1B2C:  MOVFF  45,22A
1B30:  MOVFF  44,229
1B34:  MOVFF  43,228
....................  
....................  
....................     // Check to see if target is on same subnet, if not, find Gateway MAC. 
....................     // Once we get Gateway MAC, all access to remote host will go through Gateway. 
....................     if((packet.SenderIPAddr.Val ^ remote->IPAddr.Val) & AppConfig.MyMask.Val) 
1B38:  MOVLW  06
1B3A:  ADDWF  x17,W
1B3C:  MOVWF  FE9
1B3E:  MOVLW  00
1B40:  ADDWFC x18,W
1B42:  MOVWF  FEA
1B44:  MOVFF  FEF,00
1B48:  MOVFF  FEC,01
1B4C:  MOVFF  FEC,02
1B50:  MOVFF  FEC,03
1B54:  MOVF   00,W
1B56:  XORWF  x28,W
1B58:  MOVWF  x37
1B5A:  MOVF   01,W
1B5C:  XORWF  x29,W
1B5E:  MOVWF  x38
1B60:  MOVF   02,W
1B62:  XORWF  x2A,W
1B64:  MOVWF  x39
1B66:  MOVF   03,W
1B68:  XORWF  x2B,W
1B6A:  MOVWF  x3A
1B6C:  MOVF   x37,W
1B6E:  ANDWF  4D,W
1B70:  MOVWF  00
1B72:  MOVF   x38,W
1B74:  ANDWF  4E,W
1B76:  MOVWF  01
1B78:  MOVF   x39,W
1B7A:  ANDWF  4F,W
1B7C:  MOVWF  02
1B7E:  MOVF   x3A,W
1B80:  ANDWF  50,W
1B82:  MOVWF  03
1B84:  MOVF   00,F
1B86:  BNZ   1B94
1B88:  MOVF   01,F
1B8A:  BNZ   1B94
1B8C:  MOVF   02,F
1B8E:  BNZ   1B94
1B90:  MOVF   03,F
1B92:  BZ    1BA6
....................     { 
....................       packet.TargetIPAddr = AppConfig.MyGateway; 
1B94:  MOVFF  54,235
1B98:  MOVFF  53,234
1B9C:  MOVFF  52,233
1BA0:  MOVFF  51,232
....................     } 
....................     else 
1BA4:  BRA    1BD2
....................         packet.TargetIPAddr             = remote->IPAddr; 
1BA6:  MOVLW  06
1BA8:  ADDWF  x17,W
1BAA:  MOVWF  FE9
1BAC:  MOVLW  00
1BAE:  ADDWFC x18,W
1BB0:  MOVWF  FEA
1BB2:  MOVFF  FEF,00
1BB6:  MOVFF  FEC,01
1BBA:  MOVFF  FEC,02
1BBE:  MOVFF  FEC,03
1BC2:  MOVFF  03,235
1BC6:  MOVFF  02,234
1BCA:  MOVFF  01,233
1BCE:  MOVFF  00,232
....................  
....................     SwapARPPacket(&packet); 
1BD2:  MOVLW  02
1BD4:  MOVWF  x38
1BD6:  MOVLW  1A
1BD8:  MOVWF  x37
1BDA:  MOVLB  0
1BDC:  CALL   1318
....................  
....................     MACPutHeader(&packet.TargetMACAddr, MAC_ARP, sizeof(packet)); 
1BE0:  MOVLW  02
1BE2:  MOVLB  2
1BE4:  MOVWF  x98
1BE6:  MOVLW  2C
1BE8:  MOVWF  x97
1BEA:  MOVLW  06
1BEC:  MOVWF  x99
1BEE:  CLRF   x9B
1BF0:  MOVLW  1C
1BF2:  MOVWF  x9A
1BF4:  MOVLB  0
1BF6:  RCALL  165E
....................  
....................     //MACPutArray((int8*)&packet, sizeof(packet)); 
....................     MACPutArray(&packet, sizeof(ARP_PACKET)); 
1BF8:  MOVLW  02
1BFA:  MOVLB  2
1BFC:  MOVWF  x9F
1BFE:  MOVLW  1A
1C00:  MOVWF  x9E
1C02:  CLRF   xA1
1C04:  MOVLW  1C
1C06:  MOVWF  xA0
1C08:  MOVLB  0
1C0A:  RCALL  15F8
....................  
....................     MACFlush(); 
1C0C:  RCALL  1758
....................     
....................    return TRUE; 
1C0E:  MOVLW  01
1C10:  MOVWF  01
1C12:  MOVLB  2
.................... } 
1C14:  MOVLB  0
1C16:  RETLW  00
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapARPPacket(ARP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p   - ARP packet to be swapped. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapARPPacket(ARP_PACKET *p) 
.................... { 
....................     p->HardwareType     = swaps(p->HardwareType); 
*
1318:  MOVLB  2
131A:  MOVFF  237,01
131E:  MOVFF  238,03
1322:  MOVFF  237,239
1326:  MOVFF  238,23A
132A:  MOVFF  237,FE9
132E:  MOVFF  238,FEA
1332:  MOVFF  FEC,23C
1336:  MOVF   FED,F
1338:  MOVFF  FEF,23B
133C:  MOVFF  23C,29A
1340:  MOVFF  23B,299
1344:  MOVLB  0
1346:  RCALL  118C
1348:  MOVFF  23A,FEA
134C:  MOVFF  239,FE9
1350:  MOVFF  02,FEC
1354:  MOVF   FED,F
1356:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol); 
135A:  MOVLW  02
135C:  MOVLB  2
135E:  ADDWF  x37,W
1360:  MOVWF  01
1362:  MOVLW  00
1364:  ADDWFC x38,W
1366:  MOVWF  03
1368:  MOVFF  01,239
136C:  MOVWF  x3A
136E:  MOVLW  02
1370:  ADDWF  x37,W
1372:  MOVWF  FE9
1374:  MOVLW  00
1376:  ADDWFC x38,W
1378:  MOVWF  FEA
137A:  MOVFF  FEC,23C
137E:  MOVF   FED,F
1380:  MOVFF  FEF,23B
1384:  MOVFF  23C,29A
1388:  MOVFF  23B,299
138C:  MOVLB  0
138E:  RCALL  118C
1390:  MOVFF  23A,FEA
1394:  MOVFF  239,FE9
1398:  MOVFF  02,FEC
139C:  MOVF   FED,F
139E:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation); 
13A2:  MOVLW  06
13A4:  MOVLB  2
13A6:  ADDWF  x37,W
13A8:  MOVWF  01
13AA:  MOVLW  00
13AC:  ADDWFC x38,W
13AE:  MOVWF  03
13B0:  MOVFF  01,239
13B4:  MOVWF  x3A
13B6:  MOVLW  06
13B8:  ADDWF  x37,W
13BA:  MOVWF  FE9
13BC:  MOVLW  00
13BE:  ADDWFC x38,W
13C0:  MOVWF  FEA
13C2:  MOVFF  FEC,23C
13C6:  MOVF   FED,F
13C8:  MOVFF  FEF,23B
13CC:  MOVFF  23C,29A
13D0:  MOVFF  23B,299
13D4:  MOVLB  0
13D6:  RCALL  118C
13D8:  MOVFF  23A,FEA
13DC:  MOVFF  239,FE9
13E0:  MOVFF  02,FEC
13E4:  MOVF   FED,F
13E6:  MOVFF  01,FEF
.................... } 
13EA:  RETLW  00
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
.................... #include "mpfs/mpfs.c" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
.................... #include "tcpip/http.c" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
.................... #include "tcpip/http2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
.................... #include "tcpip/ftp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
.................... #include "tcpip/tftp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
.................... #include "tcpip/smtp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
.................... #include "tcpip/dns.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
.................... #include "tcpip/announce.h" 
.................... #include "tcpip/announce.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
.................... #include "tcpip/snmp.c" 
.................... #endif 
....................  
.................... //#define MAX_ICMP_DATA_LEN   64 //moved to icmp.h 
....................  
.................... /* 
....................  * Stack FSM states. 
....................  */ 
.................... typedef enum _SM_STACK 
.................... { 
....................    SM_STACK_IDLE=0, 
....................    SM_STACK_MAC, 
....................    SM_STACK_IP, 
....................    SM_STACK_ICMP, 
....................    SM_STACK_ICMP_REPLY, 
....................    SM_STACK_ARP, 
....................    SM_STACK_TCP, 
....................    SM_STACK_UDP 
.................... }SM_STACK; 
....................  
.................... SM_STACK smStack; 
....................  
.................... NODE_INFO remoteNode; 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componets are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines are used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void) 
.................... { 
....................    smStack = SM_STACK_IDLE; 
*
0854:  MOVLB  1
0856:  CLRF   x4A
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................    /* 
....................     * If DHCP or IP Gleaning is enabled, 
....................     * startup in Config Mode. 
....................     */ 
....................    AppConfig.Flags.bInConfigMode = TRUE; 
.................... #endif 
....................  
....................    TickInit(); 
0858:  MOVLB  0
085A:  RCALL  010E
....................  
.................... #if STACK_USE_MAC 
....................    MACInit(); 
085C:  RCALL  03F2
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................    ARPInit(); 
085E:  RCALL  05BE
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................    UDPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................    TCPInit(); 
0860:  RCALL  0712
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    DHCPReset(); 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    ppp_init(); 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP||STACK_USE_HTTP2 
....................    HTTP_Init(); 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
....................    FTPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
....................    TFTPInit(); 
.................... #endif 
.................... } 
0862:  RETLW  00
....................  
.................... /* 
....................  #if STACK_USE_MCPENC 
....................  #if MAC_TX_BUFFER_COUNT > 1 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U TXB0.ADD=0x%LX TXB0.FR=%U NPL=0x%LX CPL=0x%LX",NICCurrentTxBuffer, TxBuffers[0].StartAddress, TxBuffers[0].bFree, NextPacketLocation.Val, CurrentPacketLocation.Val) 
....................  #else 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U NPL=0x%LX CPL=0x%LX", NICCurrentTxBuffer, NextPacketLocation.Val, CurrentPacketLocation.Val) 
....................  #endif 
....................  #else 
....................  #define DebugDisplayVals() 
....................  #endif 
....................  */ 
....................  
.................... #define DebugDisplayVals() 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void) 
.................... { 
*
43BE:  MOVLB  1
43C0:  BCF    xF3.0
....................    static WORD dataCount; 
....................  
.................... #if STACK_USE_ICMP 
....................    static BYTE data[MAX_ICMP_DATA_LEN]; 
....................    static WORD ICMPId; 
....................    static WORD ICMPSeq; 
.................... #endif 
....................    IP_ADDR tempLocalIP; 
....................  
....................    union 
....................    { 
....................       BYTE MACFrameType; 
....................       BYTE IPFrameType; 
.................... #if STACK_USE_ICMP 
....................       ICMP_CODE ICMPCode; 
.................... #endif 
....................    }type; 
....................  
....................    BOOL lbContinue=FALSE; 
....................  
....................    do 
....................    { 
....................       lbContinue = FALSE; 
43C2:  BCF    xF3.0
....................       switch(smStack) 
....................       { 
43C4:  MOVF   x4A,W
43C6:  ADDLW  F9
43C8:  BTFSC  FD8.0
43CA:  BRA    455A
43CC:  ADDLW  07
43CE:  MOVLB  0
43D0:  GOTO   4566
....................          case SM_STACK_IDLE: 
....................          case SM_STACK_MAC: 
....................          if ( !MACGetHeader(&remoteNode.MACAddr, &type.MACFrameType) ) 
43D4:  MOVLW  01
43D6:  MOVLB  1
43D8:  MOVWF  xF5
43DA:  MOVLW  4B
43DC:  MOVWF  xF4
43DE:  MOVLW  01
43E0:  MOVWF  xF7
43E2:  MOVLW  F2
43E4:  MOVWF  xF6
43E6:  MOVLB  0
43E8:  GOTO   11A2
43EC:  MOVF   01,F
43EE:  BNZ   43F4
....................          { 
.................... #if STACK_USE_DHCP 
....................             // Normally, an application would not include  DHCP module 
....................             // if it is not enabled. But in case some one wants to disable 
....................             // DHCP module at run-time, remember to not clear our IP 
....................             // address if link is removed. 
....................             if ( !DHCPIsDisabled() ) 
....................             { 
....................                if ( !MACIsLinked() ) 
....................                { 
....................                   AppConfig.MyIPAddr.Val = 0x00000000ul; 
....................                   AppConfig.Flags.bInConfigMode = TRUE; 
....................                   DHCPReset(); 
....................                } 
....................             } 
.................... #endif 
....................             break; 
43F0:  MOVLB  1
43F2:  BRA    455A
....................          } 
....................  
....................          //debug_stack(debug_putc, "\r\nMAC GET "); 
....................  
....................          lbContinue = TRUE; 
43F4:  MOVLB  1
43F6:  BSF    xF3.0
....................          if ( type.MACFrameType == MAC_IP ) { 
43F8:  MOVF   xF2,F
43FA:  BNZ   4402
....................             smStack = SM_STACK_IP; 
43FC:  MOVLW  02
43FE:  MOVWF  x4A
....................             //debug_stack(debug_putc, "IP "); 
....................          } 
....................          else if ( type.MACFrameType == MAC_ARP ) { 
4400:  BRA    4416
4402:  MOVF   xF2,W
4404:  SUBLW  06
4406:  BNZ   440E
....................             smStack = SM_STACK_ARP; 
4408:  MOVLW  05
440A:  MOVWF  x4A
....................             //debug_stack(debug_putc, "ARP "); 
....................          } 
....................          else { 
440C:  BRA    4416
....................             MACDiscardRx(); 
440E:  MOVLB  0
4410:  CALL   1070
4414:  MOVLB  1
....................             //debug_stack(debug_putc, "DISCARD"); 
....................          } 
....................          break; 
4416:  BRA    455A
....................  
....................          case SM_STACK_ARP: 
.................... #if STACK_USE_ARP 
....................          if ( ARPProcess() ) { 
4418:  GOTO   1C18
441C:  MOVF   01,F
441E:  BZ    4424
....................             smStack = SM_STACK_IDLE; 
4420:  MOVLB  1
4422:  CLRF   x4A
....................          } 
.................... #else 
....................          smStack = SM_STACK_IDLE; 
.................... #endif 
....................          break; 
4424:  MOVLB  1
4426:  BRA    455A
....................  
....................          case SM_STACK_IP: 
....................          if ( IPGetHeader(&tempLocalIP, 
....................                      &remoteNode, 
....................                      &type.IPFrameType, 
....................                      &dataCount) ) 
4428:  MOVLW  01
442A:  MOVLB  1
442C:  MOVWF  xF5
442E:  MOVLW  EE
4430:  MOVWF  xF4
4432:  MOVLW  01
4434:  MOVWF  xF7
4436:  MOVLW  4B
4438:  MOVWF  xF6
443A:  MOVLW  01
443C:  MOVWF  xF9
443E:  MOVLW  F2
4440:  MOVWF  xF8
4442:  MOVLW  01
4444:  MOVWF  xFB
4446:  MOVLW  55
4448:  MOVWF  xFA
444A:  MOVLB  0
444C:  GOTO   1FB2
4450:  MOVF   01,F
4452:  BZ    447E
....................          { 
....................             lbContinue = TRUE; 
4454:  MOVLB  1
4456:  BSF    xF3.0
....................             if ( type.IPFrameType == IP_PROT_ICMP ) 
4458:  DECFSZ xF2,W
445A:  BRA    4462
....................             { 
....................                smStack = SM_STACK_ICMP; 
445C:  MOVLW  03
445E:  MOVWF  x4A
....................                //debug_stack(debug_putc, "ICMP "); 
.................... #if STACK_USE_IP_GLEANING 
....................                if(AppConfig.Flags.bInConfigMode && !DHCPIsDisabled()) 
....................                { 
....................                   /* 
....................                    * Accoriding to "IP Gleaning" procedure, 
....................                    * when we receive an ICMP packet with a valid 
....................                    * IP address while we are still in configuration 
....................                    * mode, accept that address as ours and conclude 
....................                    * configuration mode. 
....................                    */ 
....................                   if( tempLocalIP.Val != 0xffffffff ) 
....................                   { 
....................                      AppConfig.Flags.bInConfigMode = FALSE; 
....................                      AppConfig.MyIPAddr = tempLocalIP; 
....................                      myDHCPBindCount--; 
....................                   } 
....................                } 
.................... #endif 
....................             } 
....................  
.................... #if STACK_USE_TCP 
....................             else if ( type.IPFrameType == IP_PROT_TCP ) { 
4460:  BRA    447A
4462:  MOVF   xF2,W
4464:  SUBLW  06
4466:  BNZ   446E
....................                smStack = SM_STACK_TCP; 
4468:  MOVLW  06
446A:  MOVWF  x4A
....................                //debug_stack(debug_putc, "TCP "); 
....................             } 
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................             else if ( type.IPFrameType == IP_PROT_UDP ) { 
....................                smStack = SM_STACK_UDP; 
....................                //debug_stack(debug_putc, "UDP "); 
....................             } 
.................... #endif 
....................  
....................             else 
446C:  BRA    447A
....................             { 
....................                lbContinue = FALSE; 
446E:  BCF    xF3.0
....................                MACDiscardRx(); 
4470:  MOVLB  0
4472:  CALL   1070
....................  
....................                smStack = SM_STACK_IDLE; 
4476:  MOVLB  1
4478:  CLRF   x4A
....................                //debug_stack(debug_putc, "UNKOWN-IP1 "); 
....................             } 
....................          } 
....................          else 
447A:  BRA    4486
447C:  MOVLB  0
....................          { 
....................             MACDiscardRx(); 
447E:  CALL   1070
....................             smStack = SM_STACK_IDLE; 
4482:  MOVLB  1
4484:  CLRF   x4A
....................             //debug_stack(debug_putc, "UNKOWN-IP2 "); 
....................          } 
....................          break; 
4486:  BRA    455A
....................  
.................... #if STACK_USE_UDP 
....................          case SM_STACK_UDP: 
....................          if ( UDPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
....................          { 
....................         	 //debug_stack(debug_putc, "\r\nUDP PROCESSED"); 
....................         	 //DebugDisplayVals(); 
....................             smStack = SM_STACK_IDLE; 
....................          } 
....................          break; 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................          case SM_STACK_TCP: 
....................          if ( TCPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
4488:  MOVLW  01
448A:  MOVLB  1
448C:  MOVWF  xF5
448E:  MOVLW  4B
4490:  MOVWF  xF4
4492:  MOVLW  01
4494:  MOVWF  xF7
4496:  MOVLW  EE
4498:  MOVWF  xF6
449A:  MOVFF  156,1F9
449E:  MOVFF  155,1F8
44A2:  MOVLB  0
44A4:  GOTO   3A3C
44A8:  MOVF   01,F
44AA:  BZ    44B0
....................          { 
....................         	 //debug_stack(debug_putc, "\r\nTCP PROCESSED"); 
....................         	 //DebugDisplayVals(); 
....................             smStack = SM_STACK_IDLE; 
44AC:  MOVLB  1
44AE:  CLRF   x4A
....................          } 
....................          break; 
44B0:  MOVLB  1
44B2:  BRA    455A
.................... #endif 
....................  
....................          case SM_STACK_ICMP: 
....................          smStack = SM_STACK_IDLE; 
44B4:  MOVLB  1
44B6:  CLRF   x4A
....................  
.................... #if STACK_USE_ICMP 
....................          //if ( dataCount <= (MAX_ICMP_DATA_LEN+9) ) 
....................          if ( dataCount <= (MAX_ICMP_DATA_LEN+8) ) 
44B8:  MOVF   x56,F
44BA:  BNZ   450A
44BC:  MOVF   x55,W
44BE:  SUBLW  48
44C0:  BNC   450A
....................          { 
....................             if ( ICMPGet(&type.ICMPCode, 
....................                         data, 
....................                         (BYTE*)&dataCount, 
....................                         &ICMPId, 
....................                         &ICMPSeq) ) 
44C2:  MOVLW  01
44C4:  MOVWF  xF5
44C6:  MOVLW  55
44C8:  MOVWF  xF4
44CA:  MOVLW  01
44CC:  MOVWF  xF7
44CE:  MOVLW  F2
44D0:  MOVWF  xF6
44D2:  MOVLW  01
44D4:  MOVWF  xF9
44D6:  MOVLW  57
44D8:  MOVWF  xF8
44DA:  MOVFF  1F5,1FB
44DE:  MOVFF  1F4,1FA
44E2:  MOVLW  01
44E4:  MOVWF  xFD
44E6:  MOVLW  97
44E8:  MOVWF  xFC
44EA:  MOVLW  01
44EC:  MOVWF  xFF
44EE:  MOVLW  99
44F0:  MOVWF  xFE
44F2:  MOVLB  0
44F4:  GOTO   3CDA
44F8:  MOVF   01,F
44FA:  BZ    450C
....................             { 
....................                if ( type.ICMPCode == ICMP_ECHO_REQUEST ) 
44FC:  MOVLB  1
44FE:  MOVF   xF2,W
4500:  SUBLW  08
4502:  BNZ   450A
....................                { 
....................             	   // debug_stack(debug_putc, "\r\nICMP PROCESSED"); 
....................                   lbContinue = TRUE; 
4504:  BSF    xF3.0
....................                   smStack = SM_STACK_ICMP_REPLY; 
4506:  MOVLW  04
4508:  MOVWF  x4A
450A:  MOVLB  0
....................                } 
....................             } 
....................          } 
....................          //DebugDisplayVals(); 
.................... #endif 
....................          MACDiscardRx(); 
450C:  CALL   1070
....................          break; 
4510:  MOVLB  1
4512:  BRA    455A
....................  
.................... #if STACK_USE_ICMP 
....................          case SM_STACK_ICMP_REPLY: 
....................          if ( ICMPIsTxReady() ) 
4514:  MOVLW  01
4516:  MOVLB  2
4518:  MOVWF  x7A
451A:  MOVLB  0
451C:  CALL   2906
4520:  MOVF   01,F
4522:  BZ    4554
....................          { 
....................             ICMPPut(&remoteNode, 
....................                   ICMP_ECHO_REPLY, 
....................                   data, 
....................                   (BYTE)dataCount, 
....................                   ICMPId, 
....................                   ICMPSeq); 
4524:  MOVLW  01
4526:  MOVLB  1
4528:  MOVWF  xF5
452A:  MOVLW  4B
452C:  MOVWF  xF4
452E:  CLRF   xF6
4530:  MOVLW  01
4532:  MOVWF  xF8
4534:  MOVLW  57
4536:  MOVWF  xF7
4538:  MOVFF  155,1F9
453C:  MOVFF  198,1FB
4540:  MOVFF  197,1FA
4544:  MOVFF  19A,1FD
4548:  MOVFF  199,1FC
454C:  MOVLB  0
454E:  BRA    3DB6
....................  
....................             //debug_stack(debug_putc, "\r\nICMP REPLIED"); 
....................             //DebugDisplayVals(); 
....................             smStack = SM_STACK_IDLE; 
4550:  MOVLB  1
4552:  CLRF   x4A
....................          } 
....................          break; 
4554:  MOVLB  1
4556:  BRA    455A
4558:  MOVLB  1
.................... #endif 
....................  
....................       } 
....................  
....................    }while( lbContinue ); 
455A:  BTFSC  xF3.0
455C:  BRA    43C2
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
....................    AnnounceTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................    // Perform timed TCP FSM. 
....................    TCPTick(); 
455E:  MOVLB  0
4560:  BRA    3ED2
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    HTTP_Task(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    HTTP_Task(); 
.................... #endif 
....................  
.................... #IF STACK_USE_FTP 
....................    FTPTask(); 
.................... #ENDIF    
....................  
.................... #if STACK_USE_TFTP 
....................    TFTPTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    /* 
....................     * DHCP must be called all the time even after IP configuration is 
....................     * discovered. 
....................     * DHCP has to account lease expiration time and renew the configuration 
....................     * time. 
....................     */ 
....................    DHCPTask(); 
....................  
....................    if ( DHCPIsBound() ) 
....................    AppConfig.Flags.bInConfigMode = FALSE; 
....................  
.................... #endif 
.................... } 
4562:  GOTO   6BC0 (RETURN)
....................  
.................... #include "config.c" 
.................... /********************************************************************* 
....................  * FileName:        config.c 
....................  * Dependencies:    config.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30, dsPIC33F 
....................  * Complier:        Microchip C18 v3.03 or higher 
....................  *                  Microchip C30 v2.01 or higher 
....................  * Company:         IOnOff Technology, Inc. 
....................  * 
....................  * Author               Date       Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Sann Tran            30/06/16   Original 
....................  ********************************************************************/ 
.................... #define __CONFIG_C 
....................  
.................... void MacReset(void) {     
....................    // Microchip VendorID, MAC: 00-04-A3-XX-XX-XX 
....................    MyEEPRom.Macs[0] = MY_DEFAULT_MAC_BYTE3; 
*
0A42:  MOVLW  A3
0A44:  MOVWF  37
....................    MyEEPRom.Macs[1] = MY_DEFAULT_MAC_BYTE4; 
0A46:  CLRF   38
....................    MyEEPRom.Macs[2] = MY_DEFAULT_MAC_BYTE5; 
0A48:  CLRF   39
....................    MyEEPRom.Macs[3] = MY_DEFAULT_MAC_BYTE6; 
0A4A:  CLRF   3A
.................... } 
0A4C:  GOTO   0DC8 (RETURN)
....................  
.................... void ConfigReset(void) { 
....................    MyEEPRom.Flag = TRUE;   
0A50:  MOVLW  01
0A52:  MOVWF  26
....................     
....................    MyEEPRom.SrvIps[0] = 192; 
0A54:  MOVLW  C0
0A56:  MOVWF  27
....................    MyEEPRom.SrvIps[1] = 168; 
0A58:  MOVLW  A8
0A5A:  MOVWF  28
....................    MyEEPRom.SrvIps[2] = 1; 
0A5C:  MOVLW  01
0A5E:  MOVWF  29
....................    MyEEPRom.SrvIps[3] = 252; 
0A60:  MOVLW  FC
0A62:  MOVWF  2A
....................  
....................    MyEEPRom.Ips[0] = MY_DEFAULT_IP_ADDR_BYTE1; 
0A64:  MOVLW  C0
0A66:  MOVWF  2B
....................    MyEEPRom.Ips[1] = MY_DEFAULT_IP_ADDR_BYTE2; 
0A68:  MOVLW  A8
0A6A:  MOVWF  2C
....................    MyEEPRom.Ips[2] = MY_DEFAULT_IP_ADDR_BYTE3; 
0A6C:  MOVLW  01
0A6E:  MOVWF  2D
....................    MyEEPRom.Ips[3] = MY_DEFAULT_IP_ADDR_BYTE4; 
0A70:  MOVLW  81
0A72:  MOVWF  2E
....................  
....................    //Mascara de Subred 
....................    MyEEPRom.Masks[0] = MY_DEFAULT_MASK_BYTE1; 
0A74:  MOVLW  FF
0A76:  MOVWF  2F
....................    MyEEPRom.Masks[1] = MY_DEFAULT_MASK_BYTE2; 
0A78:  MOVWF  30
....................    MyEEPRom.Masks[2] = MY_DEFAULT_MASK_BYTE3; 
0A7A:  MOVWF  31
....................    MyEEPRom.Masks[3] = MY_DEFAULT_MASK_BYTE4; 
0A7C:  CLRF   32
....................  
....................    //Puerta de Enlace 
....................    MyEEPRom.Gates[0] = MY_DEFAULT_GATE_BYTE1; 
0A7E:  MOVLW  C0
0A80:  MOVWF  33
....................    MyEEPRom.Gates[1] = MY_DEFAULT_GATE_BYTE2; 
0A82:  MOVLW  A8
0A84:  MOVWF  34
....................    MyEEPRom.Gates[2] = MY_DEFAULT_GATE_BYTE3; 
0A86:  MOVLW  01
0A88:  MOVWF  35
....................    MyEEPRom.Gates[3] = MY_DEFAULT_GATE_BYTE4;  
0A8A:  MOVWF  36
....................  
....................    // Set default input types 
....................    int8 i; 
....................    for (i = 0; i < 8; i++) { 
0A8C:  MOVLB  1
0A8E:  CLRF   xEF
0A90:  MOVF   xEF,W
0A92:  SUBLW  07
0A94:  BNC   0AAC
....................       MyEEPRom.InputTypes[i] = INPUT_SWITCH; 
0A96:  CLRF   03
0A98:  MOVF   xEF,W
0A9A:  ADDLW  3B
0A9C:  MOVWF  FE9
0A9E:  MOVLW  00
0AA0:  ADDWFC 03,W
0AA2:  MOVWF  FEA
0AA4:  MOVLW  01
0AA6:  MOVWF  FEF
....................    } 
0AA8:  INCF   xEF,F
0AAA:  BRA    0A90
.................... } 
0AAC:  MOVLB  0
0AAE:  RETLW  00
....................  
.................... void EEPWriteFlag() { 
....................    write_eeprom(0, MyEEPRom.Flag); 
*
0B06:  CLRF   FA9
0B08:  MOVFF  26,FA8
0B0C:  BCF    FA6.6
0B0E:  BCF    FA6.7
0B10:  BSF    FA6.2
0B12:  MOVF   FF2,W
0B14:  MOVWF  00
0B16:  BCF    FF2.7
0B18:  MOVLB  F
0B1A:  MOVLW  55
0B1C:  MOVWF  FA7
0B1E:  MOVLW  AA
0B20:  MOVWF  FA7
0B22:  BSF    FA6.1
0B24:  BTFSC  FA6.1
0B26:  BRA    0B24
0B28:  BCF    FA6.2
0B2A:  MOVF   00,W
0B2C:  IORWF  FF2,F
.................... } 
0B2E:  MOVLB  0
0B30:  GOTO   0CE4 (RETURN)
....................  
.................... void EEPWriteSrvIp() { 
....................    int i; 
....................    for (i = 0; i < 4; i++) { 
0B34:  MOVLB  2
0B36:  CLRF   x27
0B38:  MOVF   x27,W
0B3A:  SUBLW  03
0B3C:  BNC   0B86
....................       write_eeprom(1 + i, MyEEPRom.SrvIps[i]); 
0B3E:  MOVLW  01
0B40:  ADDWF  x27,W
0B42:  MOVWF  x28
0B44:  CLRF   03
0B46:  MOVF   x27,W
0B48:  ADDLW  27
0B4A:  MOVWF  FE9
0B4C:  MOVLW  00
0B4E:  ADDWFC 03,W
0B50:  MOVWF  FEA
0B52:  MOVFF  FEF,229
0B56:  MOVFF  228,FA9
0B5A:  MOVFF  229,FA8
0B5E:  BCF    FA6.6
0B60:  BCF    FA6.7
0B62:  BSF    FA6.2
0B64:  MOVF   FF2,W
0B66:  MOVWF  00
0B68:  BCF    FF2.7
0B6A:  MOVLB  F
0B6C:  MOVLW  55
0B6E:  MOVWF  FA7
0B70:  MOVLW  AA
0B72:  MOVWF  FA7
0B74:  BSF    FA6.1
0B76:  BTFSC  FA6.1
0B78:  BRA    0B76
0B7A:  BCF    FA6.2
0B7C:  MOVF   00,W
0B7E:  IORWF  FF2,F
....................    }    
0B80:  MOVLB  2
0B82:  INCF   x27,F
0B84:  BRA    0B38
.................... } 
0B86:  MOVLB  0
0B88:  RETLW  00
....................  
.................... void EEPWriteIp() { 
....................    int i; 
....................    for (i = 0; i < 4; i++) { 
0B8A:  MOVLB  2
0B8C:  CLRF   x27
0B8E:  MOVF   x27,W
0B90:  SUBLW  03
0B92:  BNC   0BDC
....................       write_eeprom(5 + i, MyEEPRom.Ips[i]); 
0B94:  MOVLW  05
0B96:  ADDWF  x27,W
0B98:  MOVWF  x28
0B9A:  CLRF   03
0B9C:  MOVF   x27,W
0B9E:  ADDLW  2B
0BA0:  MOVWF  FE9
0BA2:  MOVLW  00
0BA4:  ADDWFC 03,W
0BA6:  MOVWF  FEA
0BA8:  MOVFF  FEF,229
0BAC:  MOVFF  228,FA9
0BB0:  MOVFF  229,FA8
0BB4:  BCF    FA6.6
0BB6:  BCF    FA6.7
0BB8:  BSF    FA6.2
0BBA:  MOVF   FF2,W
0BBC:  MOVWF  00
0BBE:  BCF    FF2.7
0BC0:  MOVLB  F
0BC2:  MOVLW  55
0BC4:  MOVWF  FA7
0BC6:  MOVLW  AA
0BC8:  MOVWF  FA7
0BCA:  BSF    FA6.1
0BCC:  BTFSC  FA6.1
0BCE:  BRA    0BCC
0BD0:  BCF    FA6.2
0BD2:  MOVF   00,W
0BD4:  IORWF  FF2,F
....................    } 
0BD6:  MOVLB  2
0BD8:  INCF   x27,F
0BDA:  BRA    0B8E
.................... } 
0BDC:  MOVLB  0
0BDE:  RETLW  00
....................  
.................... void EEPWriteGate() { 
....................    int i; 
....................    for (i = 0; i < 4; i++) { 
0BE0:  MOVLB  2
0BE2:  CLRF   x27
0BE4:  MOVF   x27,W
0BE6:  SUBLW  03
0BE8:  BNC   0C32
....................       write_eeprom(9 + i, MyEEPRom.Gates[i]); 
0BEA:  MOVLW  09
0BEC:  ADDWF  x27,W
0BEE:  MOVWF  x28
0BF0:  CLRF   03
0BF2:  MOVF   x27,W
0BF4:  ADDLW  33
0BF6:  MOVWF  FE9
0BF8:  MOVLW  00
0BFA:  ADDWFC 03,W
0BFC:  MOVWF  FEA
0BFE:  MOVFF  FEF,229
0C02:  MOVFF  228,FA9
0C06:  MOVFF  229,FA8
0C0A:  BCF    FA6.6
0C0C:  BCF    FA6.7
0C0E:  BSF    FA6.2
0C10:  MOVF   FF2,W
0C12:  MOVWF  00
0C14:  BCF    FF2.7
0C16:  MOVLB  F
0C18:  MOVLW  55
0C1A:  MOVWF  FA7
0C1C:  MOVLW  AA
0C1E:  MOVWF  FA7
0C20:  BSF    FA6.1
0C22:  BTFSC  FA6.1
0C24:  BRA    0C22
0C26:  BCF    FA6.2
0C28:  MOVF   00,W
0C2A:  IORWF  FF2,F
....................    } 
0C2C:  MOVLB  2
0C2E:  INCF   x27,F
0C30:  BRA    0BE4
.................... } 
0C32:  MOVLB  0
0C34:  RETLW  00
....................  
.................... void EEPWriteMask() { 
....................    int i; 
....................    for (i = 0; i < 4; i++) { 
0C36:  MOVLB  2
0C38:  CLRF   x27
0C3A:  MOVF   x27,W
0C3C:  SUBLW  03
0C3E:  BNC   0C88
....................       write_eeprom(13 + i, MyEEPRom.Masks[i]); 
0C40:  MOVLW  0D
0C42:  ADDWF  x27,W
0C44:  MOVWF  x28
0C46:  CLRF   03
0C48:  MOVF   x27,W
0C4A:  ADDLW  2F
0C4C:  MOVWF  FE9
0C4E:  MOVLW  00
0C50:  ADDWFC 03,W
0C52:  MOVWF  FEA
0C54:  MOVFF  FEF,229
0C58:  MOVFF  228,FA9
0C5C:  MOVFF  229,FA8
0C60:  BCF    FA6.6
0C62:  BCF    FA6.7
0C64:  BSF    FA6.2
0C66:  MOVF   FF2,W
0C68:  MOVWF  00
0C6A:  BCF    FF2.7
0C6C:  MOVLB  F
0C6E:  MOVLW  55
0C70:  MOVWF  FA7
0C72:  MOVLW  AA
0C74:  MOVWF  FA7
0C76:  BSF    FA6.1
0C78:  BTFSC  FA6.1
0C7A:  BRA    0C78
0C7C:  BCF    FA6.2
0C7E:  MOVF   00,W
0C80:  IORWF  FF2,F
....................    } 
0C82:  MOVLB  2
0C84:  INCF   x27,F
0C86:  BRA    0C3A
.................... } 
0C88:  MOVLB  0
0C8A:  RETLW  00
....................  
.................... void EEPWriteMac() {   
....................    // Just store MAC bytes from 3-6 
....................    int i; 
....................    for (i = 0; i < 4; i++) { 
*
0AB0:  MOVLB  2
0AB2:  CLRF   x27
0AB4:  MOVF   x27,W
0AB6:  SUBLW  03
0AB8:  BNC   0B02
....................       write_eeprom(17 + i, MyEEPRom.Macs[i]); 
0ABA:  MOVLW  11
0ABC:  ADDWF  x27,W
0ABE:  MOVWF  x28
0AC0:  CLRF   03
0AC2:  MOVF   x27,W
0AC4:  ADDLW  37
0AC6:  MOVWF  FE9
0AC8:  MOVLW  00
0ACA:  ADDWFC 03,W
0ACC:  MOVWF  FEA
0ACE:  MOVFF  FEF,229
0AD2:  MOVFF  228,FA9
0AD6:  MOVFF  229,FA8
0ADA:  BCF    FA6.6
0ADC:  BCF    FA6.7
0ADE:  BSF    FA6.2
0AE0:  MOVF   FF2,W
0AE2:  MOVWF  00
0AE4:  BCF    FF2.7
0AE6:  MOVLB  F
0AE8:  MOVLW  55
0AEA:  MOVWF  FA7
0AEC:  MOVLW  AA
0AEE:  MOVWF  FA7
0AF0:  BSF    FA6.1
0AF2:  BTFSC  FA6.1
0AF4:  BRA    0AF2
0AF6:  BCF    FA6.2
0AF8:  MOVF   00,W
0AFA:  IORWF  FF2,F
....................    } 
0AFC:  MOVLB  2
0AFE:  INCF   x27,F
0B00:  BRA    0AB4
.................... } 
0B02:  MOVLB  0
0B04:  RETLW  00
....................  
.................... void EEPWriteInputTypes() { // 21 - 28 
....................    int8 i; 
....................    for (i = 0; i < 8; i++) { 
*
0C8C:  MOVLB  2
0C8E:  CLRF   x0C
0C90:  MOVF   x0C,W
0C92:  SUBLW  07
0C94:  BNC   0CDE
....................       write_eeprom(i + 21, MyEEPRom.InputTypes[i]); 
0C96:  MOVLW  15
0C98:  ADDWF  x0C,W
0C9A:  MOVWF  x0D
0C9C:  CLRF   03
0C9E:  MOVF   x0C,W
0CA0:  ADDLW  3B
0CA2:  MOVWF  FE9
0CA4:  MOVLW  00
0CA6:  ADDWFC 03,W
0CA8:  MOVWF  FEA
0CAA:  MOVFF  FEF,20E
0CAE:  MOVFF  20D,FA9
0CB2:  MOVFF  20E,FA8
0CB6:  BCF    FA6.6
0CB8:  BCF    FA6.7
0CBA:  BSF    FA6.2
0CBC:  MOVF   FF2,W
0CBE:  MOVWF  00
0CC0:  BCF    FF2.7
0CC2:  MOVLB  F
0CC4:  MOVLW  55
0CC6:  MOVWF  FA7
0CC8:  MOVLW  AA
0CCA:  MOVWF  FA7
0CCC:  BSF    FA6.1
0CCE:  BTFSC  FA6.1
0CD0:  BRA    0CCE
0CD2:  BCF    FA6.2
0CD4:  MOVF   00,W
0CD6:  IORWF  FF2,F
....................    } 
0CD8:  MOVLB  2
0CDA:  INCF   x0C,F
0CDC:  BRA    0C90
.................... } 
0CDE:  MOVLB  0
0CE0:  RETLW  00
....................  
.................... void EEPWriteOutputState(int8 idx) { // 29 - 36 
....................    if (idx >= 1 && idx <= 8) { 
*
4610:  MOVLB  2
4612:  MOVF   x0F,W
4614:  SUBLW  00
4616:  BTFSC  FD8.0
4618:  BRA    47FE
461A:  MOVF   x0F,W
461C:  SUBLW  08
461E:  BTFSS  FD8.0
4620:  BRA    47FE
....................       if (idx == 1) { 
4622:  DECFSZ x0F,W
4624:  BRA    465C
....................          write_eeprom(29, input_state(OUT_1)); 
4626:  MOVLW  00
4628:  BTFSC  F84.1
462A:  MOVLW  01
462C:  MOVWF  x10
462E:  MOVLW  1D
4630:  MOVWF  FA9
4632:  MOVFF  210,FA8
4636:  BCF    FA6.6
4638:  BCF    FA6.7
463A:  BSF    FA6.2
463C:  MOVF   FF2,W
463E:  MOVWF  00
4640:  BCF    FF2.7
4642:  MOVLB  F
4644:  MOVLW  55
4646:  MOVWF  FA7
4648:  MOVLW  AA
464A:  MOVWF  FA7
464C:  BSF    FA6.1
464E:  BTFSC  FA6.1
4650:  BRA    464E
4652:  BCF    FA6.2
4654:  MOVF   00,W
4656:  IORWF  FF2,F
....................       } 
....................       else if (idx == 2) { 
4658:  BRA    47FC
465A:  MOVLB  2
465C:  MOVF   x0F,W
465E:  SUBLW  02
4660:  BNZ   4698
....................          write_eeprom(30, input_state(OUT_2)); 
4662:  MOVLW  00
4664:  BTFSC  F84.0
4666:  MOVLW  01
4668:  MOVWF  x10
466A:  MOVLW  1E
466C:  MOVWF  FA9
466E:  MOVFF  210,FA8
4672:  BCF    FA6.6
4674:  BCF    FA6.7
4676:  BSF    FA6.2
4678:  MOVF   FF2,W
467A:  MOVWF  00
467C:  BCF    FF2.7
467E:  MOVLB  F
4680:  MOVLW  55
4682:  MOVWF  FA7
4684:  MOVLW  AA
4686:  MOVWF  FA7
4688:  BSF    FA6.1
468A:  BTFSC  FA6.1
468C:  BRA    468A
468E:  BCF    FA6.2
4690:  MOVF   00,W
4692:  IORWF  FF2,F
....................       } 
....................       else if (idx == 3) { 
4694:  BRA    47FC
4696:  MOVLB  2
4698:  MOVF   x0F,W
469A:  SUBLW  03
469C:  BNZ   46D4
....................          write_eeprom(31, input_state(OUT_3)); 
469E:  MOVLW  00
46A0:  BTFSC  F80.5
46A2:  MOVLW  01
46A4:  MOVWF  x10
46A6:  MOVLW  1F
46A8:  MOVWF  FA9
46AA:  MOVFF  210,FA8
46AE:  BCF    FA6.6
46B0:  BCF    FA6.7
46B2:  BSF    FA6.2
46B4:  MOVF   FF2,W
46B6:  MOVWF  00
46B8:  BCF    FF2.7
46BA:  MOVLB  F
46BC:  MOVLW  55
46BE:  MOVWF  FA7
46C0:  MOVLW  AA
46C2:  MOVWF  FA7
46C4:  BSF    FA6.1
46C6:  BTFSC  FA6.1
46C8:  BRA    46C6
46CA:  BCF    FA6.2
46CC:  MOVF   00,W
46CE:  IORWF  FF2,F
....................       } 
....................       else if (idx == 4) { 
46D0:  BRA    47FC
46D2:  MOVLB  2
46D4:  MOVF   x0F,W
46D6:  SUBLW  04
46D8:  BNZ   4710
....................          write_eeprom(32, input_state(OUT_4)); 
46DA:  MOVLW  00
46DC:  BTFSC  F80.4
46DE:  MOVLW  01
46E0:  MOVWF  x10
46E2:  MOVLW  20
46E4:  MOVWF  FA9
46E6:  MOVFF  210,FA8
46EA:  BCF    FA6.6
46EC:  BCF    FA6.7
46EE:  BSF    FA6.2
46F0:  MOVF   FF2,W
46F2:  MOVWF  00
46F4:  BCF    FF2.7
46F6:  MOVLB  F
46F8:  MOVLW  55
46FA:  MOVWF  FA7
46FC:  MOVLW  AA
46FE:  MOVWF  FA7
4700:  BSF    FA6.1
4702:  BTFSC  FA6.1
4704:  BRA    4702
4706:  BCF    FA6.2
4708:  MOVF   00,W
470A:  IORWF  FF2,F
....................       } 
....................       else if (idx == 5) { 
470C:  BRA    47FC
470E:  MOVLB  2
4710:  MOVF   x0F,W
4712:  SUBLW  05
4714:  BNZ   474C
....................          write_eeprom(33, input_state(OUT_5)); 
4716:  MOVLW  00
4718:  BTFSC  F82.2
471A:  MOVLW  01
471C:  MOVWF  x10
471E:  MOVLW  21
4720:  MOVWF  FA9
4722:  MOVFF  210,FA8
4726:  BCF    FA6.6
4728:  BCF    FA6.7
472A:  BSF    FA6.2
472C:  MOVF   FF2,W
472E:  MOVWF  00
4730:  BCF    FF2.7
4732:  MOVLB  F
4734:  MOVLW  55
4736:  MOVWF  FA7
4738:  MOVLW  AA
473A:  MOVWF  FA7
473C:  BSF    FA6.1
473E:  BTFSC  FA6.1
4740:  BRA    473E
4742:  BCF    FA6.2
4744:  MOVF   00,W
4746:  IORWF  FF2,F
....................       } 
....................       else if (idx == 6) { 
4748:  BRA    47FC
474A:  MOVLB  2
474C:  MOVF   x0F,W
474E:  SUBLW  06
4750:  BNZ   4788
....................          write_eeprom(34, input_state(OUT_6)); 
4752:  MOVLW  00
4754:  BTFSC  F82.1
4756:  MOVLW  01
4758:  MOVWF  x10
475A:  MOVLW  22
475C:  MOVWF  FA9
475E:  MOVFF  210,FA8
4762:  BCF    FA6.6
4764:  BCF    FA6.7
4766:  BSF    FA6.2
4768:  MOVF   FF2,W
476A:  MOVWF  00
476C:  BCF    FF2.7
476E:  MOVLB  F
4770:  MOVLW  55
4772:  MOVWF  FA7
4774:  MOVLW  AA
4776:  MOVWF  FA7
4778:  BSF    FA6.1
477A:  BTFSC  FA6.1
477C:  BRA    477A
477E:  BCF    FA6.2
4780:  MOVF   00,W
4782:  IORWF  FF2,F
....................       }  
....................       else if (idx == 7) { 
4784:  BRA    47FC
4786:  MOVLB  2
4788:  MOVF   x0F,W
478A:  SUBLW  07
478C:  BNZ   47C4
....................          write_eeprom(35, input_state(OUT_7)); 
478E:  MOVLW  00
4790:  BTFSC  F82.0
4792:  MOVLW  01
4794:  MOVWF  x10
4796:  MOVLW  23
4798:  MOVWF  FA9
479A:  MOVFF  210,FA8
479E:  BCF    FA6.6
47A0:  BCF    FA6.7
47A2:  BSF    FA6.2
47A4:  MOVF   FF2,W
47A6:  MOVWF  00
47A8:  BCF    FF2.7
47AA:  MOVLB  F
47AC:  MOVLW  55
47AE:  MOVWF  FA7
47B0:  MOVLW  AA
47B2:  MOVWF  FA7
47B4:  BSF    FA6.1
47B6:  BTFSC  FA6.1
47B8:  BRA    47B6
47BA:  BCF    FA6.2
47BC:  MOVF   00,W
47BE:  IORWF  FF2,F
....................       } 
....................       else if (idx == 8) { 
47C0:  BRA    47FC
47C2:  MOVLB  2
47C4:  MOVF   x0F,W
47C6:  SUBLW  08
47C8:  BNZ   47FE
....................          write_eeprom(36, input_state(OUT_8)); 
47CA:  MOVLW  00
47CC:  BTFSC  F84.2
47CE:  MOVLW  01
47D0:  MOVWF  x10
47D2:  MOVLW  24
47D4:  MOVWF  FA9
47D6:  MOVFF  210,FA8
47DA:  BCF    FA6.6
47DC:  BCF    FA6.7
47DE:  BSF    FA6.2
47E0:  MOVF   FF2,W
47E2:  MOVWF  00
47E4:  BCF    FF2.7
47E6:  MOVLB  F
47E8:  MOVLW  55
47EA:  MOVWF  FA7
47EC:  MOVLW  AA
47EE:  MOVWF  FA7
47F0:  BSF    FA6.1
47F2:  BTFSC  FA6.1
47F4:  BRA    47F2
47F6:  BCF    FA6.2
47F8:  MOVF   00,W
47FA:  IORWF  FF2,F
47FC:  MOVLB  2
....................       }       
....................    }    
.................... } 
47FE:  MOVLB  0
4800:  RETLW  00
....................  
.................... void EEPWriteConfig() { 
....................    EEPWriteFlag(); 
*
0CE2:  BRA    0B06
....................    EEPWriteSrvIp(); 
0CE4:  RCALL  0B34
....................    EEPWriteIp(); 
0CE6:  RCALL  0B8A
....................    EEPWriteGate(); 
0CE8:  RCALL  0BE0
....................    EEPWriteMask(); 
0CEA:  RCALL  0C36
....................    EEPWriteInputTypes(); 
0CEC:  RCALL  0C8C
.................... } 
0CEE:  RETLW  00
....................  
.................... void EEPReadAll() { 
....................    MyEEPRom.Flag = read_eeprom(0); 
*
08D4:  MOVFF  FF2,1EF
08D8:  BCF    FF2.7
08DA:  CLRF   FA9
08DC:  BCF    FA6.6
08DE:  BCF    FA6.7
08E0:  BSF    FA6.0
08E2:  MOVF   FA8,W
08E4:  MOVLB  1
08E6:  BTFSC  xEF.7
08E8:  BSF    FF2.7
08EA:  MOVWF  26
....................    int8 i; 
....................    for (i = 0; i < 4; i++) { 
08EC:  CLRF   xEE
08EE:  MOVF   xEE,W
08F0:  SUBLW  03
08F2:  BNC   0924
....................       MyEEPRom.SrvIps[i] = read_eeprom(1 + i); 
08F4:  CLRF   03
08F6:  MOVF   xEE,W
08F8:  ADDLW  27
08FA:  MOVWF  FE9
08FC:  MOVLW  00
08FE:  ADDWFC 03,W
0900:  MOVWF  FEA
0902:  MOVLW  01
0904:  ADDWF  xEE,W
0906:  MOVWF  xF1
0908:  MOVFF  FF2,1F2
090C:  BCF    FF2.7
090E:  MOVFF  1F1,FA9
0912:  BCF    FA6.6
0914:  BCF    FA6.7
0916:  BSF    FA6.0
0918:  MOVF   FA8,W
091A:  BTFSC  xF2.7
091C:  BSF    FF2.7
091E:  MOVWF  FEF
....................    } 
0920:  INCF   xEE,F
0922:  BRA    08EE
....................    for (i = 0; i < 4; i++) { 
0924:  CLRF   xEE
0926:  MOVF   xEE,W
0928:  SUBLW  03
092A:  BNC   095C
....................       MyEEPRom.Ips[i] = read_eeprom(5 + i); 
092C:  CLRF   03
092E:  MOVF   xEE,W
0930:  ADDLW  2B
0932:  MOVWF  FE9
0934:  MOVLW  00
0936:  ADDWFC 03,W
0938:  MOVWF  FEA
093A:  MOVLW  05
093C:  ADDWF  xEE,W
093E:  MOVWF  xF1
0940:  MOVFF  FF2,1F2
0944:  BCF    FF2.7
0946:  MOVFF  1F1,FA9
094A:  BCF    FA6.6
094C:  BCF    FA6.7
094E:  BSF    FA6.0
0950:  MOVF   FA8,W
0952:  BTFSC  xF2.7
0954:  BSF    FF2.7
0956:  MOVWF  FEF
....................    } 
0958:  INCF   xEE,F
095A:  BRA    0926
....................    for (i = 0; i < 4; i++) { 
095C:  CLRF   xEE
095E:  MOVF   xEE,W
0960:  SUBLW  03
0962:  BNC   0994
....................       MyEEPRom.Gates[i] = read_eeprom(9 + i); 
0964:  CLRF   03
0966:  MOVF   xEE,W
0968:  ADDLW  33
096A:  MOVWF  FE9
096C:  MOVLW  00
096E:  ADDWFC 03,W
0970:  MOVWF  FEA
0972:  MOVLW  09
0974:  ADDWF  xEE,W
0976:  MOVWF  xF1
0978:  MOVFF  FF2,1F2
097C:  BCF    FF2.7
097E:  MOVFF  1F1,FA9
0982:  BCF    FA6.6
0984:  BCF    FA6.7
0986:  BSF    FA6.0
0988:  MOVF   FA8,W
098A:  BTFSC  xF2.7
098C:  BSF    FF2.7
098E:  MOVWF  FEF
....................    } 
0990:  INCF   xEE,F
0992:  BRA    095E
....................    for (i = 0; i < 4; i++) { 
0994:  CLRF   xEE
0996:  MOVF   xEE,W
0998:  SUBLW  03
099A:  BNC   09CC
....................       MyEEPRom.Masks[i] = read_eeprom(13 + i); 
099C:  CLRF   03
099E:  MOVF   xEE,W
09A0:  ADDLW  2F
09A2:  MOVWF  FE9
09A4:  MOVLW  00
09A6:  ADDWFC 03,W
09A8:  MOVWF  FEA
09AA:  MOVLW  0D
09AC:  ADDWF  xEE,W
09AE:  MOVWF  xF1
09B0:  MOVFF  FF2,1F2
09B4:  BCF    FF2.7
09B6:  MOVFF  1F1,FA9
09BA:  BCF    FA6.6
09BC:  BCF    FA6.7
09BE:  BSF    FA6.0
09C0:  MOVF   FA8,W
09C2:  BTFSC  xF2.7
09C4:  BSF    FF2.7
09C6:  MOVWF  FEF
....................    } 
09C8:  INCF   xEE,F
09CA:  BRA    0996
....................    for (i = 0; i < 4; i++) { 
09CC:  CLRF   xEE
09CE:  MOVF   xEE,W
09D0:  SUBLW  03
09D2:  BNC   0A04
....................       MyEEPRom.Macs[i] = read_eeprom(17 + i); 
09D4:  CLRF   03
09D6:  MOVF   xEE,W
09D8:  ADDLW  37
09DA:  MOVWF  FE9
09DC:  MOVLW  00
09DE:  ADDWFC 03,W
09E0:  MOVWF  FEA
09E2:  MOVLW  11
09E4:  ADDWF  xEE,W
09E6:  MOVWF  xF1
09E8:  MOVFF  FF2,1F2
09EC:  BCF    FF2.7
09EE:  MOVFF  1F1,FA9
09F2:  BCF    FA6.6
09F4:  BCF    FA6.7
09F6:  BSF    FA6.0
09F8:  MOVF   FA8,W
09FA:  BTFSC  xF2.7
09FC:  BSF    FF2.7
09FE:  MOVWF  FEF
....................    }    
0A00:  INCF   xEE,F
0A02:  BRA    09CE
....................    for (i = 0; i < 8; i++) { 
0A04:  CLRF   xEE
0A06:  MOVF   xEE,W
0A08:  SUBLW  07
0A0A:  BNC   0A3C
....................       MyEEPRom.InputTypes[i] = read_eeprom(21 + i); 
0A0C:  CLRF   03
0A0E:  MOVF   xEE,W
0A10:  ADDLW  3B
0A12:  MOVWF  FE9
0A14:  MOVLW  00
0A16:  ADDWFC 03,W
0A18:  MOVWF  FEA
0A1A:  MOVLW  15
0A1C:  ADDWF  xEE,W
0A1E:  MOVWF  xF1
0A20:  MOVFF  FF2,1F2
0A24:  BCF    FF2.7
0A26:  MOVFF  1F1,FA9
0A2A:  BCF    FA6.6
0A2C:  BCF    FA6.7
0A2E:  BSF    FA6.0
0A30:  MOVF   FA8,W
0A32:  BTFSC  xF2.7
0A34:  BSF    FF2.7
0A36:  MOVWF  FEF
....................    } 
0A38:  INCF   xEE,F
0A3A:  BRA    0A06
.................... } 
0A3C:  MOVLB  0
0A3E:  GOTO   0DC0 (RETURN)
....................  
....................  
.................... #include "tcpclient.c" 
.................... /********************************************************************* 
....................  * 
....................  *  TCP Client Application to send IO status notification to IOnOff server 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        tcpclient.c 
....................  * Dependencies:    tcp.h, config.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30, dsPIC33F 
....................  * Complier:        CCS 4.15 
....................  * Company:         IOnOff Technology. 
....................  * PreCondition:    Stack is initialized() 
....................  * 
....................  * Author           Date          Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * SannTran          30/06/2016      Customize from Generic TCP Client 
....................  *                            Thanks to Microchip Inc 
....................  ********************************************************************/ 
....................  
.................... #define __TCPCLIENT_C 
....................  
....................  
.................... /*********************************************************************/ 
.................... // Global variables 
....................  
.................... WORD CenterPort; 
.................... NODE_INFO Server; 
.................... BOOLEAN IsInputChanged; 
.................... BOOLEAN IsEnc28J60Reset; 
.................... int8 EncTransactionCount; 
.................... BOOLEAN IsTCPClientBusy; 
....................  
.................... // Internal variables 
.................... #define DATA_RECEIVED_LEN 32 
.................... #define CONF_SET_SRV_IP 1 
.................... #define CONF_SET_IP 2 
.................... #define CONF_SET_MASK 3 
.................... #define CONF_SET_GATE 4 
.................... #define CONF_SET_MAC 5 
....................  
.................... #define CMD_NA 0 
.................... #define CMD_IO 1 
.................... #define CMD_CF 2 
.................... #define CMD_ER 3 
....................  
.................... int8 CmdReceived; 
.................... char DataReceived[DATA_RECEIVED_LEN]; 
....................  
.................... /*********************************************************************/ 
....................  
.................... TCP_SOCKET ClientSocket = INVALID_SOCKET; 
....................  
.................... void ClientSockPut(char c) { 
....................    TCPPut(ClientSocket, c); 
*
536E:  MOVFF  1C9,20E
5372:  MOVFF  20D,20F
5376:  BRA    5224
.................... } 
5378:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPClientTask(void) 
....................  * 
....................  * PreCondition:    Stack is initialized() 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TCPClientInit() { 
....................    CenterPort = 8118; 
*
0864:  MOVLW  1F
0866:  MOVLB  1
0868:  MOVWF  x9C
086A:  MOVLW  B6
086C:  MOVWF  x9B
....................    EncTransactionCount = 0; 
086E:  CLRF   xA7
....................    IsTCPClientBusy = FALSE; 
0870:  MOVLB  0
0872:  BCF    x83.4
....................    IsEnc28J60Reset = TRUE; 
0874:  BSF    x83.3
....................    Server.IPAddr.v[0] = MY_SRV_IP_BYTES[0]; 
0876:  MOVFF  22,1A3
....................    Server.IPAddr.v[1] = MY_SRV_IP_BYTES[1]; 
087A:  MOVFF  23,1A4
....................    Server.IPAddr.v[2] = MY_SRV_IP_BYTES[2]; 
087E:  MOVFF  24,1A5
....................    Server.IPAddr.v[3] = MY_SRV_IP_BYTES[3]; 
0882:  MOVFF  25,1A6
.................... } 
0886:  RETLW  00
....................  
.................... void LCDPrintCmdUK() { 
.................... #ifdef USE_PORTD_LCD 
....................    printf(lcd_putc, "\f%s", "ER:BADCMD"); 
.................... #endif 
.................... } 
*
0006:  RETLW  00
....................  
.................... void OutSet(int8 pin, char val, int8 idx) { 
....................  
....................    if (val == '0') { 
*
5574:  MOVLB  2
5576:  MOVF   x0D,W
5578:  SUBLW  30
557A:  BNZ   55B2
....................       output_low(pin);       
557C:  MOVFF  20C,20F
5580:  CLRF   x10
5582:  MOVLW  0F
5584:  MOVWF  x12
5586:  MOVLW  89
5588:  MOVWF  x11
558A:  MOVLB  0
558C:  CALL   0E20
5590:  MOVFF  20C,20F
5594:  MOVLB  2
5596:  CLRF   x10
5598:  MOVLW  0F
559A:  MOVWF  x12
559C:  MOVLW  92
559E:  MOVWF  x11
55A0:  MOVLB  0
55A2:  CALL   0E20
....................       EEPWriteOutputState(idx); 
55A6:  MOVFF  20E,20F
55AA:  CALL   4610
....................    } 
....................    else if (val == '1') { 
55AE:  BRA    5676
55B0:  MOVLB  2
55B2:  MOVF   x0D,W
55B4:  SUBLW  31
55B6:  BNZ   55F0
....................       output_high(pin); 
55B8:  MOVFF  20C,20F
55BC:  MOVLW  01
55BE:  MOVWF  x10
55C0:  MOVLW  0F
55C2:  MOVWF  x12
55C4:  MOVLW  89
55C6:  MOVWF  x11
55C8:  MOVLB  0
55CA:  CALL   0E20
55CE:  MOVFF  20C,20F
55D2:  MOVLB  2
55D4:  CLRF   x10
55D6:  MOVLW  0F
55D8:  MOVWF  x12
55DA:  MOVLW  92
55DC:  MOVWF  x11
55DE:  MOVLB  0
55E0:  CALL   0E20
....................       EEPWriteOutputState(idx); 
55E4:  MOVFF  20E,20F
55E8:  CALL   4610
....................    } 
....................    else if (val == '2') { 
55EC:  BRA    5676
55EE:  MOVLB  2
55F0:  MOVF   x0D,W
55F2:  SUBLW  32
55F4:  BNZ   5678
....................       output_high(pin); 
55F6:  MOVFF  20C,20F
55FA:  MOVLW  01
55FC:  MOVWF  x10
55FE:  MOVLW  0F
5600:  MOVWF  x12
5602:  MOVLW  89
5604:  MOVWF  x11
5606:  MOVLB  0
5608:  CALL   0E20
560C:  MOVFF  20C,20F
5610:  MOVLB  2
5612:  CLRF   x10
5614:  MOVLW  0F
5616:  MOVWF  x12
5618:  MOVLW  92
561A:  MOVWF  x11
561C:  MOVLB  0
561E:  CALL   0E20
....................       delay_ms(920); 
5622:  MOVLW  04
5624:  MOVLB  2
5626:  MOVWF  x0F
5628:  CLRF   19
562A:  BTFSC  FF2.7
562C:  BSF    19.7
562E:  BCF    FF2.7
5630:  MOVLW  E6
5632:  MOVWF  xA9
5634:  MOVLB  0
5636:  CALL   00E6
563A:  BTFSC  19.7
563C:  BSF    FF2.7
563E:  MOVLB  2
5640:  DECFSZ x0F,F
5642:  BRA    5628
....................       output_low(pin); 
5644:  MOVFF  20C,20F
5648:  CLRF   x10
564A:  MOVLW  0F
564C:  MOVWF  x12
564E:  MOVLW  89
5650:  MOVWF  x11
5652:  MOVLB  0
5654:  CALL   0E20
5658:  MOVFF  20C,20F
565C:  MOVLB  2
565E:  CLRF   x10
5660:  MOVLW  0F
5662:  MOVWF  x12
5664:  MOVLW  92
5666:  MOVWF  x11
5668:  MOVLB  0
566A:  CALL   0E20
....................       EEPWriteOutputState(idx); 
566E:  MOVFF  20E,20F
5672:  CALL   4610
5676:  MOVLB  2
....................    } 
.................... #ifdef USE_PORTD_LCD 
....................    if (val == '0') { 
....................       printf(lcd_putc, "\fSet OUT_%d 0", idx); 
....................    } 
....................    else if (val == '1') { 
....................       printf(lcd_putc, "\fSet OUT_%d 1", idx); 
....................    } 
....................    else if (val == '2') { 
....................       printf(lcd_putc, "\fSet OUT_%d 2", idx); 
....................    } 
.................... #endif 
.................... } 
5678:  MOVLB  0
567A:  RETLW  00
....................  
.................... // Method to set server ip, ip, subnet mask, gateway 
.................... void ConfigSet(int8 att) { 
....................    int8 idx[5], i, sep; 
....................    sep = 0; 
*
5A5A:  MOVLB  2
5A5C:  CLRF   x12
....................    idx[0] = 8; // 8 is index of start ip value 
5A5E:  MOVLW  08
5A60:  MOVWF  x0C
....................  
....................    for (i = idx[0]; i < DATA_RECEIVED_LEN; i++) { 
5A62:  MOVFF  20C,211
5A66:  MOVF   x11,W
5A68:  SUBLW  1F
5A6A:  BNC   5ACC
....................       if (DataReceived[i] == '-') { // use '-' instead of '.' 
5A6C:  CLRF   03
5A6E:  MOVF   x11,W
5A70:  ADDLW  A9
5A72:  MOVWF  FE9
5A74:  MOVLW  01
5A76:  ADDWFC 03,W
5A78:  MOVWF  FEA
5A7A:  MOVF   FEF,W
5A7C:  SUBLW  2D
5A7E:  BNZ   5A9A
....................          sep++; 
5A80:  INCF   x12,F
....................          if (sep <= 3) { 
5A82:  MOVF   x12,W
5A84:  SUBLW  03
5A86:  BNC   5A9A
....................             idx[sep] = i; 
5A88:  CLRF   03
5A8A:  MOVF   x12,W
5A8C:  ADDLW  0C
5A8E:  MOVWF  FE9
5A90:  MOVLW  02
5A92:  ADDWFC 03,W
5A94:  MOVWF  FEA
5A96:  MOVFF  211,FEF
....................          } 
....................       } 
....................       if (DataReceived[i] == '}') { 
5A9A:  CLRF   03
5A9C:  MOVF   x11,W
5A9E:  ADDLW  A9
5AA0:  MOVWF  FE9
5AA2:  MOVLW  01
5AA4:  ADDWFC 03,W
5AA6:  MOVWF  FEA
5AA8:  MOVF   FEF,W
5AAA:  SUBLW  7D
5AAC:  BNZ   5AC8
....................          sep++; 
5AAE:  INCF   x12,F
....................          if (sep <= 4) { 
5AB0:  MOVF   x12,W
5AB2:  SUBLW  04
5AB4:  BNC   5AC8
....................             idx[sep] = i; 
5AB6:  CLRF   03
5AB8:  MOVF   x12,W
5ABA:  ADDLW  0C
5ABC:  MOVWF  FE9
5ABE:  MOVLW  02
5AC0:  ADDWFC 03,W
5AC2:  MOVWF  FEA
5AC4:  MOVFF  211,FEF
....................          } 
....................       } 
....................    } 
5AC8:  INCF   x11,F
5ACA:  BRA    5A66
....................  
....................    if  (sep != 4) { 
5ACC:  MOVF   x12,W
5ACE:  SUBLW  04
5AD0:  BZ    5AE2
....................       CmdReceived = CMD_ER; 
5AD2:  MOVLW  03
5AD4:  MOVLB  1
5AD6:  MOVWF  xA8
....................       LCDPrintCmdUK(); 
5AD8:  MOVLB  0
5ADA:  CALL   0006
....................       return; 
5ADE:  BRA    5DCC
5AE0:  MOVLB  2
....................    } 
....................  
....................    int8 b1s, b2s, b3s, b4s; 
....................    b1s = idx[1] - idx[0]; 
5AE2:  MOVF   x0C,W
5AE4:  SUBWF  x0D,W
5AE6:  MOVWF  x13
....................    b2s = idx[2] - idx[1] - 1; 
5AE8:  MOVF   x0D,W
5AEA:  SUBWF  x0E,W
5AEC:  ADDLW  FF
5AEE:  MOVWF  x14
....................    b3s = idx[3] - idx[2] - 1; 
5AF0:  MOVF   x0E,W
5AF2:  SUBWF  x0F,W
5AF4:  ADDLW  FF
5AF6:  MOVWF  x15
....................    b4s = idx[4] - idx[3] - 1; 
5AF8:  MOVF   x0F,W
5AFA:  SUBWF  x10,W
5AFC:  ADDLW  FF
5AFE:  MOVWF  x16
....................    if (b1s > 3 || b1s == 0 || b2s > 3 || b2s == 0 || b3s > 3 || b3s == 0 
....................          || b4s > 3 || b4s == 0) { 
5B00:  MOVF   x13,W
5B02:  SUBLW  03
5B04:  BNC   5B28
5B06:  MOVF   x13,F
5B08:  BZ    5B28
5B0A:  MOVF   x14,W
5B0C:  SUBLW  03
5B0E:  BNC   5B28
5B10:  MOVF   x14,F
5B12:  BZ    5B28
5B14:  MOVF   x15,W
5B16:  SUBLW  03
5B18:  BNC   5B28
5B1A:  MOVF   x15,F
5B1C:  BZ    5B28
5B1E:  MOVF   x16,W
5B20:  SUBLW  03
5B22:  BNC   5B28
5B24:  MOVF   x16,F
5B26:  BNZ   5B38
....................      CmdReceived = CMD_ER; 
5B28:  MOVLW  03
5B2A:  MOVLB  1
5B2C:  MOVWF  xA8
....................      LCDPrintCmdUK(); 
5B2E:  MOVLB  0
5B30:  CALL   0006
....................       return; 
5B34:  BRA    5DCC
5B36:  MOVLB  2
....................    } 
....................  
....................    char b1[4]; 
....................    char b2[4]; 
....................    char b3[4]; 
....................    char b4[4]; 
....................  
....................    for (i = 0; i < b1s; i++) { 
5B38:  CLRF   x11
5B3A:  MOVF   x13,W
5B3C:  SUBWF  x11,W
5B3E:  BC    5B74
....................       b1[i] = DataReceived[i + idx[0]]; 
5B40:  CLRF   03
5B42:  MOVF   x11,W
5B44:  ADDLW  17
5B46:  MOVWF  01
5B48:  MOVLW  02
5B4A:  ADDWFC 03,F
5B4C:  MOVFF  03,228
5B50:  MOVF   x0C,W
5B52:  ADDWF  x11,W
5B54:  CLRF   03
5B56:  ADDLW  A9
5B58:  MOVWF  FE9
5B5A:  MOVLW  01
5B5C:  ADDWFC 03,W
5B5E:  MOVWF  FEA
5B60:  MOVFF  FEF,229
5B64:  MOVFF  228,FEA
5B68:  MOVFF  01,FE9
5B6C:  MOVFF  229,FEF
....................    } 
5B70:  INCF   x11,F
5B72:  BRA    5B3A
....................    for (i = 0; i < b2s; i++) { 
5B74:  CLRF   x11
5B76:  MOVF   x14,W
5B78:  SUBWF  x11,W
5B7A:  BC    5BB2
....................       b2[i] = DataReceived[i + idx[1] + 1]; 
5B7C:  CLRF   03
5B7E:  MOVF   x11,W
5B80:  ADDLW  1B
5B82:  MOVWF  01
5B84:  MOVLW  02
5B86:  ADDWFC 03,F
5B88:  MOVFF  03,228
5B8C:  MOVF   x0D,W
5B8E:  ADDWF  x11,W
5B90:  ADDLW  01
5B92:  CLRF   03
5B94:  ADDLW  A9
5B96:  MOVWF  FE9
5B98:  MOVLW  01
5B9A:  ADDWFC 03,W
5B9C:  MOVWF  FEA
5B9E:  MOVFF  FEF,229
5BA2:  MOVFF  228,FEA
5BA6:  MOVFF  01,FE9
5BAA:  MOVFF  229,FEF
....................    } 
5BAE:  INCF   x11,F
5BB0:  BRA    5B76
....................    for (i = 0; i < b3s; i++) { 
5BB2:  CLRF   x11
5BB4:  MOVF   x15,W
5BB6:  SUBWF  x11,W
5BB8:  BC    5BF0
....................       b3[i] = DataReceived[i + idx[2] + 1]; 
5BBA:  CLRF   03
5BBC:  MOVF   x11,W
5BBE:  ADDLW  1F
5BC0:  MOVWF  01
5BC2:  MOVLW  02
5BC4:  ADDWFC 03,F
5BC6:  MOVFF  03,228
5BCA:  MOVF   x0E,W
5BCC:  ADDWF  x11,W
5BCE:  ADDLW  01
5BD0:  CLRF   03
5BD2:  ADDLW  A9
5BD4:  MOVWF  FE9
5BD6:  MOVLW  01
5BD8:  ADDWFC 03,W
5BDA:  MOVWF  FEA
5BDC:  MOVFF  FEF,229
5BE0:  MOVFF  228,FEA
5BE4:  MOVFF  01,FE9
5BE8:  MOVFF  229,FEF
....................    } 
5BEC:  INCF   x11,F
5BEE:  BRA    5BB4
....................    for (i = 0; i < b4s; i++) { 
5BF0:  CLRF   x11
5BF2:  MOVF   x16,W
5BF4:  SUBWF  x11,W
5BF6:  BC    5C2E
....................       b4[i] = DataReceived[i + idx[3] + 1]; 
5BF8:  CLRF   03
5BFA:  MOVF   x11,W
5BFC:  ADDLW  23
5BFE:  MOVWF  01
5C00:  MOVLW  02
5C02:  ADDWFC 03,F
5C04:  MOVFF  03,228
5C08:  MOVF   x0F,W
5C0A:  ADDWF  x11,W
5C0C:  ADDLW  01
5C0E:  CLRF   03
5C10:  ADDLW  A9
5C12:  MOVWF  FE9
5C14:  MOVLW  01
5C16:  ADDWFC 03,W
5C18:  MOVWF  FEA
5C1A:  MOVFF  FEF,229
5C1E:  MOVFF  228,FEA
5C22:  MOVFF  01,FE9
5C26:  MOVFF  229,FEF
....................    } 
5C2A:  INCF   x11,F
5C2C:  BRA    5BF2
....................  
....................    if (att == CONF_SET_SRV_IP) { 
5C2E:  DECFSZ x0B,W
5C30:  BRA    5C80
....................       MyEEPRom.SrvIps[0] = atoi(b1); 
5C32:  MOVLW  02
5C34:  MOVWF  x28
5C36:  MOVLW  17
5C38:  MOVWF  x27
5C3A:  MOVLB  0
5C3C:  RCALL  58B8
5C3E:  MOVFF  01,27
....................       MyEEPRom.SrvIps[1] = atoi(b2); 
5C42:  MOVLW  02
5C44:  MOVLB  2
5C46:  MOVWF  x28
5C48:  MOVLW  1B
5C4A:  MOVWF  x27
5C4C:  MOVLB  0
5C4E:  RCALL  58B8
5C50:  MOVFF  01,28
....................       MyEEPRom.SrvIps[2] = atoi(b3); 
5C54:  MOVLW  02
5C56:  MOVLB  2
5C58:  MOVWF  x28
5C5A:  MOVLW  1F
5C5C:  MOVWF  x27
5C5E:  MOVLB  0
5C60:  RCALL  58B8
5C62:  MOVFF  01,29
....................       MyEEPRom.SrvIps[3] = atoi(b4); 
5C66:  MOVLW  02
5C68:  MOVLB  2
5C6A:  MOVWF  x28
5C6C:  MOVLW  23
5C6E:  MOVWF  x27
5C70:  MOVLB  0
5C72:  RCALL  58B8
5C74:  MOVFF  01,2A
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\n%u.%u.%u.%u", MyEEPRom.SrvIps[0], MyEEPRom.SrvIps[1], MyEEPRom.SrvIps[2], MyEEPRom.SrvIps[3]); 
.................... #endif 
....................       EEPWriteSrvIp(); 
5C78:  CALL   0B34
....................    } 
....................    else if (att == CONF_SET_IP) { 
5C7C:  BRA    5DCC
5C7E:  MOVLB  2
5C80:  MOVF   x0B,W
5C82:  SUBLW  02
5C84:  BNZ   5CD4
....................       MyEEPRom.Ips[0] = atoi(b1); 
5C86:  MOVLW  02
5C88:  MOVWF  x28
5C8A:  MOVLW  17
5C8C:  MOVWF  x27
5C8E:  MOVLB  0
5C90:  RCALL  58B8
5C92:  MOVFF  01,2B
....................       MyEEPRom.Ips[1] = atoi(b2); 
5C96:  MOVLW  02
5C98:  MOVLB  2
5C9A:  MOVWF  x28
5C9C:  MOVLW  1B
5C9E:  MOVWF  x27
5CA0:  MOVLB  0
5CA2:  RCALL  58B8
5CA4:  MOVFF  01,2C
....................       MyEEPRom.Ips[2] = atoi(b3); 
5CA8:  MOVLW  02
5CAA:  MOVLB  2
5CAC:  MOVWF  x28
5CAE:  MOVLW  1F
5CB0:  MOVWF  x27
5CB2:  MOVLB  0
5CB4:  RCALL  58B8
5CB6:  MOVFF  01,2D
....................       MyEEPRom.Ips[3] = atoi(b4); 
5CBA:  MOVLW  02
5CBC:  MOVLB  2
5CBE:  MOVWF  x28
5CC0:  MOVLW  23
5CC2:  MOVWF  x27
5CC4:  MOVLB  0
5CC6:  RCALL  58B8
5CC8:  MOVFF  01,2E
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\n%u.%u.%u.%u", MyEEPRom.Ips[0], MyEEPRom.Ips[1], MyEEPRom.Ips[2], MyEEPRom.Ips[3]); 
.................... #endif 
....................       EEPWriteIp(); 
5CCC:  CALL   0B8A
....................    } 
....................    else if (att == CONF_SET_MASK) { 
5CD0:  BRA    5DCC
5CD2:  MOVLB  2
5CD4:  MOVF   x0B,W
5CD6:  SUBLW  03
5CD8:  BNZ   5D28
....................       MyEEPRom.Masks[0] = atoi(b1); 
5CDA:  MOVLW  02
5CDC:  MOVWF  x28
5CDE:  MOVLW  17
5CE0:  MOVWF  x27
5CE2:  MOVLB  0
5CE4:  RCALL  58B8
5CE6:  MOVFF  01,2F
....................       MyEEPRom.Masks[1] = atoi(b2); 
5CEA:  MOVLW  02
5CEC:  MOVLB  2
5CEE:  MOVWF  x28
5CF0:  MOVLW  1B
5CF2:  MOVWF  x27
5CF4:  MOVLB  0
5CF6:  RCALL  58B8
5CF8:  MOVFF  01,30
....................       MyEEPRom.Masks[2] = atoi(b3); 
5CFC:  MOVLW  02
5CFE:  MOVLB  2
5D00:  MOVWF  x28
5D02:  MOVLW  1F
5D04:  MOVWF  x27
5D06:  MOVLB  0
5D08:  RCALL  58B8
5D0A:  MOVFF  01,31
....................       MyEEPRom.Masks[3] = atoi(b4); 
5D0E:  MOVLW  02
5D10:  MOVLB  2
5D12:  MOVWF  x28
5D14:  MOVLW  23
5D16:  MOVWF  x27
5D18:  MOVLB  0
5D1A:  RCALL  58B8
5D1C:  MOVFF  01,32
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\n%u.%u.%u.%u", MyEEPRom.Masks[0], MyEEPRom.Masks[1], MyEEPRom.Masks[2], MyEEPRom.Masks[3]); 
.................... #endif 
....................       EEPWriteMask(); 
5D20:  CALL   0C36
....................    } 
....................    else if (att == CONF_SET_GATE) { 
5D24:  BRA    5DCC
5D26:  MOVLB  2
5D28:  MOVF   x0B,W
5D2A:  SUBLW  04
5D2C:  BNZ   5D7C
....................       MyEEPRom.Gates[0] = atoi(b1); 
5D2E:  MOVLW  02
5D30:  MOVWF  x28
5D32:  MOVLW  17
5D34:  MOVWF  x27
5D36:  MOVLB  0
5D38:  RCALL  58B8
5D3A:  MOVFF  01,33
....................       MyEEPRom.Gates[1] = atoi(b2); 
5D3E:  MOVLW  02
5D40:  MOVLB  2
5D42:  MOVWF  x28
5D44:  MOVLW  1B
5D46:  MOVWF  x27
5D48:  MOVLB  0
5D4A:  RCALL  58B8
5D4C:  MOVFF  01,34
....................       MyEEPRom.Gates[2] = atoi(b3); 
5D50:  MOVLW  02
5D52:  MOVLB  2
5D54:  MOVWF  x28
5D56:  MOVLW  1F
5D58:  MOVWF  x27
5D5A:  MOVLB  0
5D5C:  RCALL  58B8
5D5E:  MOVFF  01,35
....................       MyEEPRom.Gates[3] = atoi(b4); 
5D62:  MOVLW  02
5D64:  MOVLB  2
5D66:  MOVWF  x28
5D68:  MOVLW  23
5D6A:  MOVWF  x27
5D6C:  MOVLB  0
5D6E:  RCALL  58B8
5D70:  MOVFF  01,36
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\n%u.%u.%u.%u", MyEEPRom.Gates[0], MyEEPRom.Gates[1], MyEEPRom.Gates[2], MyEEPRom.Gates[3]); 
.................... #endif 
....................       EEPWriteGate(); 
5D74:  CALL   0BE0
....................    } 
....................  
....................    else if (att == CONF_SET_MAC) { 
5D78:  BRA    5DCC
5D7A:  MOVLB  2
5D7C:  MOVF   x0B,W
5D7E:  SUBLW  05
5D80:  BNZ   5DCE
....................       // continue parsing 2 last mac bytes 
....................       // 4 bytes are the last 4 bytes of 6 bytes mac 
....................       MyEEPRom.Macs[0] = atoi(b1); 
5D82:  MOVLW  02
5D84:  MOVWF  x28
5D86:  MOVLW  17
5D88:  MOVWF  x27
5D8A:  MOVLB  0
5D8C:  RCALL  58B8
5D8E:  MOVFF  01,37
....................       MyEEPRom.Macs[1] = atoi(b2); 
5D92:  MOVLW  02
5D94:  MOVLB  2
5D96:  MOVWF  x28
5D98:  MOVLW  1B
5D9A:  MOVWF  x27
5D9C:  MOVLB  0
5D9E:  RCALL  58B8
5DA0:  MOVFF  01,38
....................       MyEEPRom.Macs[2] = atoi(b3); 
5DA4:  MOVLW  02
5DA6:  MOVLB  2
5DA8:  MOVWF  x28
5DAA:  MOVLW  1F
5DAC:  MOVWF  x27
5DAE:  MOVLB  0
5DB0:  RCALL  58B8
5DB2:  MOVFF  01,39
....................       MyEEPRom.Macs[3] = atoi(b4); 
5DB6:  MOVLW  02
5DB8:  MOVLB  2
5DBA:  MOVWF  x28
5DBC:  MOVLW  23
5DBE:  MOVWF  x27
5DC0:  MOVLB  0
5DC2:  RCALL  58B8
5DC4:  MOVFF  01,3A
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\n%X%X%X%X", MyEEPRom.Macs[0], MyEEPRom.Macs[1], MyEEPRom.Macs[2], MyEEPRom.Macs[3]); 
.................... #endif 
....................       EEPWriteMac(); 
5DC8:  CALL   0AB0
5DCC:  MOVLB  2
....................    } 
.................... } 
5DCE:  MOVLB  0
5DD0:  RETLW  00
....................  
.................... void InTypeSet() { 
.................... #ifdef USE_PORTD_LCD 
....................    printf(lcd_putc, "\f%s", "Set InType"); 
....................    printf(lcd_putc, "\n%s", DataReceived); 
.................... #endif 
....................    int i; 
....................    for (i = 8; i < 16; i++) { 
*
57FC:  MOVLW  08
57FE:  MOVLB  2
5800:  MOVWF  x0B
5802:  MOVF   x0B,W
5804:  SUBLW  0F
5806:  BNC   585E
....................       if (DataReceived[i] == '1') { 
5808:  CLRF   03
580A:  MOVF   x0B,W
580C:  ADDLW  A9
580E:  MOVWF  FE9
5810:  MOVLW  01
5812:  ADDWFC 03,W
5814:  MOVWF  FEA
5816:  MOVF   FEF,W
5818:  SUBLW  31
581A:  BNZ   5832
....................          MyEEPRom.InputTypes[i - 8] = INPUT_SWITCH; 
581C:  MOVLW  08
581E:  SUBWF  x0B,W
5820:  CLRF   03
5822:  ADDLW  3B
5824:  MOVWF  FE9
5826:  MOVLW  00
5828:  ADDWFC 03,W
582A:  MOVWF  FEA
582C:  MOVLW  01
582E:  MOVWF  FEF
....................       } 
....................       else if (DataReceived[i] == '2') { 
5830:  BRA    585A
5832:  CLRF   03
5834:  MOVF   x0B,W
5836:  ADDLW  A9
5838:  MOVWF  FE9
583A:  MOVLW  01
583C:  ADDWFC 03,W
583E:  MOVWF  FEA
5840:  MOVF   FEF,W
5842:  SUBLW  32
5844:  BNZ   585A
....................          MyEEPRom.InputTypes[i - 8] = INPUT_BUTTON; 
5846:  MOVLW  08
5848:  SUBWF  x0B,W
584A:  CLRF   03
584C:  ADDLW  3B
584E:  MOVWF  FE9
5850:  MOVLW  00
5852:  ADDWFC 03,W
5854:  MOVWF  FEA
5856:  MOVLW  02
5858:  MOVWF  FEF
....................       } 
....................    } 
585A:  INCF   x0B,F
585C:  BRA    5802
....................    EEPWriteInputTypes(); 
585E:  MOVLB  0
5860:  CALL   0C8C
.................... } 
5864:  GOTO   5E60 (RETURN)
....................  
.................... void SrvSet() { 
.................... #ifdef USE_PORTD_LCD 
....................    printf(lcd_putc, "\f%s", "Set SrvIP"); 
.................... #endif 
....................    ConfigSet(CONF_SET_SRV_IP); 
*
5DD2:  MOVLW  01
5DD4:  MOVLB  2
5DD6:  MOVWF  x0B
5DD8:  MOVLB  0
5DDA:  RCALL  5A5A
.................... } 
5DDC:  GOTO   5E78 (RETURN)
....................  
.................... void IpSet() { 
.................... #ifdef USE_PORTD_LCD 
....................    printf(lcd_putc, "\f%s", "Set MyIP"); 
.................... #endif 
....................    ConfigSet(CONF_SET_IP); 
5DE0:  MOVLW  02
5DE2:  MOVLB  2
5DE4:  MOVWF  x0B
5DE6:  MOVLB  0
5DE8:  RCALL  5A5A
.................... } 
5DEA:  GOTO   5E90 (RETURN)
....................  
.................... void MaskSet() { 
.................... #ifdef USE_PORTD_LCD 
....................    printf(lcd_putc, "\f%s", "Set SubnetMask"); 
.................... #endif 
....................    ConfigSet(CONF_SET_MASK); 
5DEE:  MOVLW  03
5DF0:  MOVLB  2
5DF2:  MOVWF  x0B
5DF4:  MOVLB  0
5DF6:  RCALL  5A5A
.................... } 
5DF8:  GOTO   5EA8 (RETURN)
....................  
.................... void GateSet() { 
.................... #ifdef USE_PORTD_LCD 
....................    printf(lcd_putc, "\f%s", "Set GateWay"); 
.................... #endif 
....................    ConfigSet(CONF_SET_GATE); 
5DFC:  MOVLW  04
5DFE:  MOVLB  2
5E00:  MOVWF  x0B
5E02:  MOVLB  0
5E04:  RCALL  5A5A
.................... } 
5E06:  GOTO   5EC0 (RETURN)
....................  
.................... void MacSet() { 
.................... #ifdef USE_PORTD_LCD 
....................    printf(lcd_putc, "\f%s", "Set Mac"); 
.................... #endif 
....................    ConfigSet(CONF_SET_MAC); 
5E0A:  MOVLW  05
5E0C:  MOVLB  2
5E0E:  MOVWF  x0B
5E10:  MOVLB  0
5E12:  RCALL  5A5A
.................... } 
5E14:  GOTO   5ED8 (RETURN)
....................  
.................... BOOLEAN ObjFound(char c1, char c2) { 
....................    return DataReceived[1] == c1 && DataReceived[2] == c2; 
*
550A:  MOVLB  2
550C:  MOVF   x0B,W
550E:  MOVLB  1
5510:  SUBWF  xAA,W
5512:  BNZ   551E
5514:  MOVLB  2
5516:  MOVF   x0C,W
5518:  MOVLB  1
551A:  SUBWF  xAB,W
551C:  BZ    5522
551E:  MOVLW  00
5520:  BRA    5524
5522:  MOVLW  01
5524:  MOVWF  01
.................... } 
5526:  MOVLB  0
5528:  RETLW  00
....................  
.................... BOOLEAN CmdFound(char c1, char c2, char c3) { 
....................    return DataReceived[3] == c1 && DataReceived[4] == c2 && DataReceived[5] == c3; 
552A:  MOVLB  2
552C:  MOVF   x0C,W
552E:  MOVLB  1
5530:  SUBWF  xAC,W
5532:  BNZ   5548
5534:  MOVLB  2
5536:  MOVF   x0D,W
5538:  MOVLB  1
553A:  SUBWF  xAD,W
553C:  BNZ   5548
553E:  MOVLB  2
5540:  MOVF   x0E,W
5542:  MOVLB  1
5544:  SUBWF  xAE,W
5546:  BZ    554C
5548:  MOVLW  00
554A:  BRA    554E
554C:  MOVLW  01
554E:  MOVWF  01
.................... } 
5550:  MOVLB  0
5552:  RETLW  00
....................  
.................... BOOLEAN AttFound(char c1, char c2) { 
....................    return DataReceived[6] == c1 && DataReceived[7] == c2; 
5554:  MOVLB  2
5556:  MOVF   x0C,W
5558:  MOVLB  1
555A:  SUBWF  xAF,W
555C:  BNZ   5568
555E:  MOVLB  2
5560:  MOVF   x0D,W
5562:  MOVLB  1
5564:  SUBWF  xB0,W
5566:  BZ    556C
5568:  MOVLW  00
556A:  BRA    556E
556C:  MOVLW  01
556E:  MOVWF  01
.................... } 
5570:  MOVLB  0
5572:  RETLW  00
....................  
.................... void IOReqHandle(void) { 
....................    if (CmdFound('g', 'e', 't')) { // Check get io status 
*
567C:  MOVLW  67
567E:  MOVLB  2
5680:  MOVWF  x0C
5682:  MOVLW  65
5684:  MOVWF  x0D
5686:  MOVLW  74
5688:  MOVWF  x0E
568A:  MOVLB  0
568C:  RCALL  552A
568E:  MOVF   01,F
5690:  BZ    5694
....................       // does nothing, forward to next step to return IO status 
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\f%s", "Get IO State"); 
.................... #endif 
....................    } 
....................    else if (CmdFound('s', 'e', 't')) { // Check set io status 
5692:  BRA    57F8
5694:  MOVLW  73
5696:  MOVLB  2
5698:  MOVWF  x0C
569A:  MOVLW  65
569C:  MOVWF  x0D
569E:  MOVLW  74
56A0:  MOVWF  x0E
56A2:  MOVLB  0
56A4:  RCALL  552A
56A6:  MOVF   01,F
56A8:  BTFSC  FD8.2
56AA:  BRA    57EC
....................       char val = DataReceived[8]; 
56AC:  MOVFF  1B1,20B
....................  
....................       if (AttFound('o', '1')) { 
56B0:  MOVLW  6F
56B2:  MOVLB  2
56B4:  MOVWF  x0C
56B6:  MOVLW  31
56B8:  MOVWF  x0D
56BA:  MOVLB  0
56BC:  RCALL  5554
56BE:  MOVF   01,F
56C0:  BZ    56D6
....................          OutSet(OUT_1, val, 1); 
56C2:  MOVLW  21
56C4:  MOVLB  2
56C6:  MOVWF  x0C
56C8:  MOVFF  20B,20D
56CC:  MOVLW  01
56CE:  MOVWF  x0E
56D0:  MOVLB  0
56D2:  RCALL  5574
....................       } 
....................       else if (AttFound('o', '2')) { 
56D4:  BRA    57EA
56D6:  MOVLW  6F
56D8:  MOVLB  2
56DA:  MOVWF  x0C
56DC:  MOVLW  32
56DE:  MOVWF  x0D
56E0:  MOVLB  0
56E2:  RCALL  5554
56E4:  MOVF   01,F
56E6:  BZ    56FC
....................          OutSet(OUT_2, val, 2); 
56E8:  MOVLW  20
56EA:  MOVLB  2
56EC:  MOVWF  x0C
56EE:  MOVFF  20B,20D
56F2:  MOVLW  02
56F4:  MOVWF  x0E
56F6:  MOVLB  0
56F8:  RCALL  5574
....................       } 
....................       else if (AttFound('o', '3')) { 
56FA:  BRA    57EA
56FC:  MOVLW  6F
56FE:  MOVLB  2
5700:  MOVWF  x0C
5702:  MOVLW  33
5704:  MOVWF  x0D
5706:  MOVLB  0
5708:  RCALL  5554
570A:  MOVF   01,F
570C:  BZ    5722
....................          OutSet(OUT_3, val, 3); 
570E:  MOVLW  05
5710:  MOVLB  2
5712:  MOVWF  x0C
5714:  MOVFF  20B,20D
5718:  MOVLW  03
571A:  MOVWF  x0E
571C:  MOVLB  0
571E:  RCALL  5574
....................       } 
....................       else if (AttFound('o', '4')) { 
5720:  BRA    57EA
5722:  MOVLW  6F
5724:  MOVLB  2
5726:  MOVWF  x0C
5728:  MOVLW  34
572A:  MOVWF  x0D
572C:  MOVLB  0
572E:  RCALL  5554
5730:  MOVF   01,F
5732:  BZ    5746
....................          OutSet(OUT_4, val, 4); 
5734:  MOVLW  04
5736:  MOVLB  2
5738:  MOVWF  x0C
573A:  MOVFF  20B,20D
573E:  MOVWF  x0E
5740:  MOVLB  0
5742:  RCALL  5574
....................       } 
....................       else if (AttFound('o', '5')) { 
5744:  BRA    57EA
5746:  MOVLW  6F
5748:  MOVLB  2
574A:  MOVWF  x0C
574C:  MOVLW  35
574E:  MOVWF  x0D
5750:  MOVLB  0
5752:  RCALL  5554
5754:  MOVF   01,F
5756:  BZ    576C
....................          OutSet(OUT_5, val, 5); 
5758:  MOVLW  12
575A:  MOVLB  2
575C:  MOVWF  x0C
575E:  MOVFF  20B,20D
5762:  MOVLW  05
5764:  MOVWF  x0E
5766:  MOVLB  0
5768:  RCALL  5574
....................       } 
....................       else if (AttFound('o', '6')) { 
576A:  BRA    57EA
576C:  MOVLW  6F
576E:  MOVLB  2
5770:  MOVWF  x0C
5772:  MOVLW  36
5774:  MOVWF  x0D
5776:  MOVLB  0
5778:  RCALL  5554
577A:  MOVF   01,F
577C:  BZ    5792
....................          OutSet(OUT_6, val, 6); 
577E:  MOVLW  11
5780:  MOVLB  2
5782:  MOVWF  x0C
5784:  MOVFF  20B,20D
5788:  MOVLW  06
578A:  MOVWF  x0E
578C:  MOVLB  0
578E:  RCALL  5574
....................       } 
....................       else if (AttFound('o', '7')) { 
5790:  BRA    57EA
5792:  MOVLW  6F
5794:  MOVLB  2
5796:  MOVWF  x0C
5798:  MOVLW  37
579A:  MOVWF  x0D
579C:  MOVLB  0
579E:  RCALL  5554
57A0:  MOVF   01,F
57A2:  BZ    57B8
....................          OutSet(OUT_7, val, 7); 
57A4:  MOVLW  10
57A6:  MOVLB  2
57A8:  MOVWF  x0C
57AA:  MOVFF  20B,20D
57AE:  MOVLW  07
57B0:  MOVWF  x0E
57B2:  MOVLB  0
57B4:  RCALL  5574
....................       } 
....................       else if (AttFound('o', '8')) { 
57B6:  BRA    57EA
57B8:  MOVLW  6F
57BA:  MOVLB  2
57BC:  MOVWF  x0C
57BE:  MOVLW  38
57C0:  MOVWF  x0D
57C2:  MOVLB  0
57C4:  RCALL  5554
57C6:  MOVF   01,F
57C8:  BZ    57DE
....................          OutSet(OUT_8, val, 8); 
57CA:  MOVLW  22
57CC:  MOVLB  2
57CE:  MOVWF  x0C
57D0:  MOVFF  20B,20D
57D4:  MOVLW  08
57D6:  MOVWF  x0E
57D8:  MOVLB  0
57DA:  RCALL  5574
....................       } 
....................       else { 
57DC:  BRA    57EA
....................          CmdReceived = CMD_ER; 
57DE:  MOVLW  03
57E0:  MOVLB  1
57E2:  MOVWF  xA8
....................          LCDPrintCmdUK(); 
57E4:  MOVLB  0
57E6:  CALL   0006
....................       } 
....................    } 
....................    else { 
57EA:  BRA    57F8
....................       CmdReceived = CMD_ER; 
57EC:  MOVLW  03
57EE:  MOVLB  1
57F0:  MOVWF  xA8
....................       LCDPrintCmdUK(); 
57F2:  MOVLB  0
57F4:  CALL   0006
....................    } 
.................... } 
57F8:  GOTO   69AE (RETURN)
....................  
.................... void TCPLedOn() { 
....................    output_low(OUT_TCP_STATE); 
*
4E88:  BCF    F93.4
4E8A:  BCF    F8A.4
.................... } 
4E8C:  RETLW  00
....................  
.................... void TCPLedOff() { 
....................    output_high(OUT_TCP_STATE); 
*
0E1A:  BCF    F93.4
0E1C:  BSF    F8A.4
.................... } 
0E1E:  RETLW  00
....................  
.................... void CfReqHandle(void) { 
....................    if (CmdFound('g', 'e', 't')) { // Check to get configs 
*
5E18:  MOVLW  67
5E1A:  MOVLB  2
5E1C:  MOVWF  x0C
5E1E:  MOVLW  65
5E20:  MOVWF  x0D
5E22:  MOVLW  74
5E24:  MOVWF  x0E
5E26:  MOVLB  0
5E28:  CALL   552A
5E2C:  MOVF   01,F
5E2E:  BZ    5E32
....................       // Go to next step to return configs 
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\f%s", "Get Config"); 
.................... #endif 
....................    } 
....................    else if (CmdFound('s', 'e', 't')) { // Check to set configs 
5E30:  BRA    5EF4
5E32:  MOVLW  73
5E34:  MOVLB  2
5E36:  MOVWF  x0C
5E38:  MOVLW  65
5E3A:  MOVWF  x0D
5E3C:  MOVLW  74
5E3E:  MOVWF  x0E
5E40:  MOVLB  0
5E42:  CALL   552A
5E46:  MOVF   01,F
5E48:  BZ    5EE8
....................       if (AttFound('i', 'n')) { // Set input type switch / button 
5E4A:  MOVLW  69
5E4C:  MOVLB  2
5E4E:  MOVWF  x0C
5E50:  MOVLW  6E
5E52:  MOVWF  x0D
5E54:  MOVLB  0
5E56:  CALL   5554
5E5A:  MOVF   01,F
5E5C:  BZ    5E62
....................          InTypeSet(); 
5E5E:  BRA    57FC
....................       } 
....................       else if (AttFound('s', 'v')) { // Set ionoff server ip 
5E60:  BRA    5EE6
5E62:  MOVLW  73
5E64:  MOVLB  2
5E66:  MOVWF  x0C
5E68:  MOVLW  76
5E6A:  MOVWF  x0D
5E6C:  MOVLB  0
5E6E:  CALL   5554
5E72:  MOVF   01,F
5E74:  BZ    5E7A
....................          SrvSet();          
5E76:  BRA    5DD2
....................       } 
....................       else if (AttFound('i', 'p')) { // Set my board ip 
5E78:  BRA    5EE6
5E7A:  MOVLW  69
5E7C:  MOVLB  2
5E7E:  MOVWF  x0C
5E80:  MOVLW  70
5E82:  MOVWF  x0D
5E84:  MOVLB  0
5E86:  CALL   5554
5E8A:  MOVF   01,F
5E8C:  BZ    5E92
....................          IpSet(); 
5E8E:  BRA    5DE0
....................       } 
....................       else if (AttFound('s', 'm')) { // Set subnet mask 
5E90:  BRA    5EE6
5E92:  MOVLW  73
5E94:  MOVLB  2
5E96:  MOVWF  x0C
5E98:  MOVLW  6D
5E9A:  MOVWF  x0D
5E9C:  MOVLB  0
5E9E:  CALL   5554
5EA2:  MOVF   01,F
5EA4:  BZ    5EAA
....................          MaskSet(); 
5EA6:  BRA    5DEE
....................       } 
....................       else if (AttFound('g', 'w')) { // Set gate way 
5EA8:  BRA    5EE6
5EAA:  MOVLW  67
5EAC:  MOVLB  2
5EAE:  MOVWF  x0C
5EB0:  MOVLW  77
5EB2:  MOVWF  x0D
5EB4:  MOVLB  0
5EB6:  CALL   5554
5EBA:  MOVF   01,F
5EBC:  BZ    5EC2
....................          GateSet(); 
5EBE:  BRA    5DFC
....................       } 
....................       else if (AttFound('m', 'a')) { // Set gate way 
5EC0:  BRA    5EE6
5EC2:  MOVLW  6D
5EC4:  MOVLB  2
5EC6:  MOVWF  x0C
5EC8:  MOVLW  61
5ECA:  MOVWF  x0D
5ECC:  MOVLB  0
5ECE:  CALL   5554
5ED2:  MOVF   01,F
5ED4:  BZ    5EDA
....................          MacSet(); 
5ED6:  BRA    5E0A
....................       } 
....................       else { 
5ED8:  BRA    5EE6
....................          CmdReceived = CMD_ER; 
5EDA:  MOVLW  03
5EDC:  MOVLB  1
5EDE:  MOVWF  xA8
....................          LCDPrintCmdUK(); 
5EE0:  MOVLB  0
5EE2:  CALL   0006
....................       } 
....................    } 
....................    else { 
5EE6:  BRA    5EF4
....................       CmdReceived = CMD_ER; 
5EE8:  MOVLW  03
5EEA:  MOVLB  1
5EEC:  MOVWF  xA8
....................       LCDPrintCmdUK(); 
5EEE:  MOVLB  0
5EF0:  CALL   0006
....................    } 
.................... } 
5EF4:  GOTO   69CE (RETURN)
....................  
.................... void TCPClientTask(void) { 
....................     
....................    char BuffC; 
....................    int8 BuffI; 
....................    static int8 ARPCheckResolved; 
....................    static int8 TCPCheckConnected; 
....................    static TICKTYPE Timer;    
....................  
....................    static enum { 
....................       SM_HOME = 0, 
....................       SM_ARP_START_RESOLVE = 1, 
....................       SM_ARP_RESOLVE = 2, 
....................       SM_SOCKET_OBTAIN = 3, 
....................       SM_SOCKET_OBTAINED = 4, 
....................       SM_PROCESS_RESPONSE = 5, 
....................       SM_DISCONNECT = 6, 
....................       SM_DONE = 7 
....................    } TCPClientState = SM_HOME; 
....................   
....................    switch (TCPClientState) { 
*
6084:  MOVLB  1
6086:  MOVF   xCE,W
6088:  ADDLW  F8
608A:  BTFSC  FD8.0
608C:  GOTO   6A1C
6090:  ADDLW  08
6092:  MOVLB  0
6094:  GOTO   6A22
....................    case SM_HOME:       
....................       ARPCheckResolved = 0; 
6098:  MOVLB  1
609A:  CLRF   xCA
....................       TCPCheckConnected = 0; 
609C:  CLRF   xCB
....................       IsTCPClientBusy = FALSE; 
609E:  MOVLB  0
60A0:  BCF    x83.4
....................       EncTransactionCount = EncTransactionCount + 1; 
60A2:  MOVLW  01
60A4:  MOVLB  1
60A6:  ADDWF  xA7,F
....................       CmdReceived = CMD_NA; 
60A8:  CLRF   xA8
....................       TCPClientState = SM_ARP_START_RESOLVE; 
60AA:  MOVWF  xCE
....................       break; 
60AC:  GOTO   6A1C
....................  
....................    case SM_ARP_START_RESOLVE: 
....................       // Obtain the MAC address associated with the server's IP address 
....................       // (either direct MAC address on same subnet, or the MAC address of the Gateway machine) 
....................       ARPResolve(&Server.IPAddr); 
60B0:  MOVLW  01
60B2:  MOVLB  2
60B4:  MOVWF  x0C
60B6:  MOVLW  A3
60B8:  MOVWF  x0B
60BA:  MOVLB  0
60BC:  GOTO   4B7E
....................       Timer = TickGet(); 
60C0:  CALL   0FE8
60C4:  MOVFF  02,1CD
60C8:  MOVFF  01,1CC
....................       TCPClientState = SM_ARP_RESOLVE; 
60CC:  MOVLW  02
60CE:  MOVLB  1
60D0:  MOVWF  xCE
....................       break; 
60D2:  GOTO   6A1C
....................  
....................    case SM_ARP_RESOLVE: 
....................        
....................       // Wait for the MAC address to finish being obtained 
....................       if (!ARPIsResolved(&Server.IPAddr, &Server.MACAddr)) { 
60D6:  MOVLW  01
60D8:  MOVLB  2
60DA:  MOVWF  x0C
60DC:  MOVLW  A3
60DE:  MOVWF  x0B
60E0:  MOVLW  01
60E2:  MOVWF  x0E
60E4:  MOVLW  9D
60E6:  MOVWF  x0D
60E8:  MOVLB  0
60EA:  GOTO   4BBE
60EE:  MOVF   01,F
60F0:  BNZ   6132
....................          // Time out if too much time is spent in this state 
....................          if (TickGet() - Timer > 3 * TICK_SECOND) {             
60F2:  CALL   0FE8
60F6:  MOVFF  02,20C
60FA:  MOVFF  01,20B
60FE:  MOVLB  1
6100:  MOVF   xCC,W
6102:  MOVLB  2
6104:  SUBWF  x0B,F
6106:  MOVLB  1
6108:  MOVF   xCD,W
610A:  MOVLB  2
610C:  SUBWFB x0C,F
610E:  BNZ   6116
6110:  MOVF   x0B,W
6112:  SUBLW  24
6114:  BC    612A
....................             if (ARPCheckResolved >= 3) { 
6116:  MOVLB  1
6118:  MOVF   xCA,W
611A:  SUBLW  02
611C:  BC    6124
.................... #ifdef USE_PORTD_LCD 
....................                printf(lcd_putc, "\f%s", "ARPNotResolved/"); 
.................... #endif 
....................                TCPClientState = SM_DONE; // ignore sending this notification 
611E:  MOVLW  07
6120:  MOVWF  xCE
....................             } 
....................             else { 
6122:  BRA    6128
.................... #ifdef USE_PORTD_LCD 
....................                printf(lcd_putc, "\f%s", "ARPNotResolved+"); 
.................... #endif 
....................                TCPClientState = SM_ARP_START_RESOLVE; // try to reconnect 
6124:  MOVLW  01
6126:  MOVWF  xCE
....................             } 
....................             ARPCheckResolved ++; 
6128:  INCF   xCA,F
....................          } 
....................          break; 
612A:  MOVLB  1
612C:  GOTO   6A1C
6130:  MOVLB  0
....................       } 
....................       Timer = TickGet(); 
6132:  CALL   0FE8
6136:  MOVFF  02,1CD
613A:  MOVFF  01,1CC
....................       TCPClientState = SM_SOCKET_OBTAIN; 
613E:  MOVLW  03
6140:  MOVLB  1
6142:  MOVWF  xCE
....................       break; 
6144:  GOTO   6A1C
....................  
....................    case SM_SOCKET_OBTAIN: 
....................        
....................       // Connect a socket to the remote TCP server 
....................       ClientSocket = TCPConnect(&Server, CenterPort); 
6148:  MOVLW  01
614A:  MOVLB  2
614C:  MOVWF  x0C
614E:  MOVLW  9D
6150:  MOVWF  x0B
6152:  MOVFF  19C,20E
6156:  MOVFF  19B,20D
615A:  MOVLB  0
615C:  GOTO   4C40
6160:  MOVFF  01,1C9
....................       // Abort operation if no TCP sockets are available 
....................       // If this ever happens, incrementing MAX_TCP_SOCKETS in 
....................       // stacktsk.h may help (at the expense of more global memory 
....................       // resources). 
....................       if (ClientSocket == INVALID_SOCKET) { 
6164:  MOVLB  1
6166:  MOVF   xC9,W
6168:  SUBLW  FE
616A:  BNZ   619E
....................          if (TickGet() - Timer > 3 * TICK_SECOND) { 
616C:  MOVLB  0
616E:  CALL   0FE8
6172:  MOVFF  02,20C
6176:  MOVFF  01,20B
617A:  MOVLB  1
617C:  MOVF   xCC,W
617E:  MOVLB  2
6180:  SUBWF  x0B,F
6182:  MOVLB  1
6184:  MOVF   xCD,W
6186:  MOVLB  2
6188:  SUBWFB x0C,F
618A:  BNZ   6192
618C:  MOVF   x0B,W
618E:  SUBLW  24
6190:  BC    6198
.................... #ifdef USE_PORTD_LCD 
....................             printf(lcd_putc, "\f%s", "TCPConnectFailed"); 
.................... #endif   
....................             TCPClientState = SM_DONE;          
6192:  MOVLW  07
6194:  MOVLB  1
6196:  MOVWF  xCE
....................          } 
....................          break; 
6198:  MOVLB  1
619A:  GOTO   6A1C
....................       } 
....................       TCPClientState = SM_SOCKET_OBTAINED; 
619E:  MOVLW  04
61A0:  MOVWF  xCE
....................       Timer = TickGet(); 
61A2:  MOVLB  0
61A4:  CALL   0FE8
61A8:  MOVFF  02,1CD
61AC:  MOVFF  01,1CC
....................       break; 
61B0:  MOVLB  1
61B2:  GOTO   6A1C
....................  
....................    case SM_SOCKET_OBTAINED: 
....................       // Wait for the remote server to accept connection request 
....................       if (!TCPIsConnected(ClientSocket)) { 
61B6:  MOVFF  1C9,20B
61BA:  CALL   4E5E
61BE:  MOVF   01,F
61C0:  BNZ   61F8
....................          // Time out if too much time is spent in this state 
....................          if (TickGet() - Timer > 3 * TICK_SECOND) { 
61C2:  CALL   0FE8
61C6:  MOVFF  02,20C
61CA:  MOVFF  01,20B
61CE:  MOVLB  1
61D0:  MOVF   xCC,W
61D2:  MOVLB  2
61D4:  SUBWF  x0B,F
61D6:  MOVLB  1
61D8:  MOVF   xCD,W
61DA:  MOVLB  2
61DC:  SUBWFB x0C,F
61DE:  BNZ   61E6
61E0:  MOVF   x0B,W
61E2:  SUBLW  24
61E4:  BC    61F0
....................             TCPClientState = SM_DISCONNECT; 
61E6:  MOVLW  06
61E8:  MOVLB  1
61EA:  MOVWF  xCE
....................             break;            
61EC:  GOTO   6A1C
....................          } 
....................          break; 
61F0:  MOVLB  1
61F2:  GOTO   6A1C
61F6:  MOVLB  0
....................       } 
....................      TCPLedOn();      
61F8:  CALL   4E88
....................      IsTCPClientBusy = TRUE; 
61FC:  BSF    x83.4
....................        
....................        
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\f%s", "TCPNowConnected."); 
.................... #endif 
....................       // Make certain the socket can be written to 
....................       if (!TCPIsPutReady(ClientSocket)) { 
61FE:  MOVFF  1C9,20B
6202:  GOTO   4E8E
6206:  MOVF   01,F
6208:  BNZ   6212
....................          break; 
620A:  MOVLB  1
620C:  GOTO   6A1C
6210:  MOVLB  0
....................       } 
....................       char ioStates[18]; 
....................        
....................       if (CmdReceived == CMD_NA || CmdReceived == CMD_IO) { 
6212:  MOVLB  1
6214:  MOVF   xA8,F
6216:  BZ    621C
6218:  DECFSZ xA8,W
621A:  BRA    65B2
....................          // Place the data into the transmit buffer. 
....................          sprintf(ioStates, "%d%d%d%d%d%d%d%d,%d%d%d%d%d%d%d%d", 
....................                input_state(IN_1), input_state(IN_2), input_state(IN_3), 
....................                input_state(IN_4), input_state(IN_5), input_state(IN_6), 
....................                input_state(IN_7), input_state(IN_8), 
....................                input_state(OUT_1), 
....................                input_state(OUT_2), input_state(OUT_3), input_state(OUT_4), 
....................                input_state(OUT_5), input_state(OUT_6), input_state(OUT_7), 
....................                input_state(OUT_8)); 
621C:  MOVLW  00
621E:  BTFSC  F83.7
6220:  MOVLW  01
6222:  MOVLB  2
6224:  MOVWF  x0B
6226:  MOVLW  00
6228:  BTFSC  F81.0
622A:  MOVLW  01
622C:  MOVWF  x0C
622E:  MOVLW  00
6230:  BTFSC  F81.1
6232:  MOVLW  01
6234:  MOVWF  x0D
6236:  MOVLW  00
6238:  BTFSC  F81.2
623A:  MOVLW  01
623C:  MOVWF  x0E
623E:  MOVLW  00
6240:  BTFSC  F82.4
6242:  MOVLW  01
6244:  MOVWF  x0F
6246:  MOVLW  00
6248:  BTFSC  F82.5
624A:  MOVLW  01
624C:  MOVWF  x10
624E:  MOVLW  00
6250:  BTFSC  F83.5
6252:  MOVLW  01
6254:  MOVWF  x11
6256:  MOVLW  00
6258:  BTFSC  F83.6
625A:  MOVLW  01
625C:  MOVWF  x12
625E:  MOVLW  00
6260:  BTFSC  F84.1
6262:  MOVLW  01
6264:  MOVWF  x13
6266:  MOVLW  00
6268:  BTFSC  F84.0
626A:  MOVLW  01
626C:  MOVWF  x14
626E:  MOVLW  00
6270:  BTFSC  F80.5
6272:  MOVLW  01
6274:  MOVWF  x15
6276:  MOVLW  00
6278:  BTFSC  F80.4
627A:  MOVLW  01
627C:  MOVWF  x16
627E:  MOVLW  00
6280:  BTFSC  F82.2
6282:  MOVLW  01
6284:  MOVWF  x17
6286:  MOVLW  00
6288:  BTFSC  F82.1
628A:  MOVLW  01
628C:  MOVWF  x18
628E:  MOVLW  00
6290:  BTFSC  F82.0
6292:  MOVLW  01
6294:  MOVWF  x19
6296:  MOVLW  00
6298:  BTFSC  F84.2
629A:  MOVLW  01
629C:  MOVWF  x1A
629E:  MOVLW  01
62A0:  MOVLB  1
62A2:  MOVWF  xD0
62A4:  MOVLW  F0
62A6:  MOVWF  xCF
62A8:  MOVFF  20B,21B
62AC:  MOVLW  1F
62AE:  MOVLB  2
62B0:  MOVWF  x1C
62B2:  MOVLB  0
62B4:  CALL   4F7C
62B8:  MOVFF  20C,21B
62BC:  MOVLW  1F
62BE:  MOVLB  2
62C0:  MOVWF  x1C
62C2:  MOVLB  0
62C4:  CALL   4F7C
62C8:  MOVFF  20D,21B
62CC:  MOVLW  1F
62CE:  MOVLB  2
62D0:  MOVWF  x1C
62D2:  MOVLB  0
62D4:  CALL   4F7C
62D8:  MOVFF  20E,21B
62DC:  MOVLW  1F
62DE:  MOVLB  2
62E0:  MOVWF  x1C
62E2:  MOVLB  0
62E4:  CALL   4F7C
62E8:  MOVFF  20F,21B
62EC:  MOVLW  1F
62EE:  MOVLB  2
62F0:  MOVWF  x1C
62F2:  MOVLB  0
62F4:  CALL   4F7C
62F8:  MOVFF  210,21B
62FC:  MOVLW  1F
62FE:  MOVLB  2
6300:  MOVWF  x1C
6302:  MOVLB  0
6304:  CALL   4F7C
6308:  MOVFF  211,21B
630C:  MOVLW  1F
630E:  MOVLB  2
6310:  MOVWF  x1C
6312:  MOVLB  0
6314:  CALL   4F7C
6318:  MOVFF  212,21B
631C:  MOVLW  1F
631E:  MOVLB  2
6320:  MOVWF  x1C
6322:  MOVLB  0
6324:  CALL   4F7C
6328:  MOVLW  2C
632A:  MOVLB  2
632C:  MOVWF  x21
632E:  MOVLB  0
6330:  CALL   4F5A
6334:  MOVFF  213,21B
6338:  MOVLW  1F
633A:  MOVLB  2
633C:  MOVWF  x1C
633E:  MOVLB  0
6340:  CALL   4F7C
6344:  MOVFF  214,21B
6348:  MOVLW  1F
634A:  MOVLB  2
634C:  MOVWF  x1C
634E:  MOVLB  0
6350:  CALL   4F7C
6354:  MOVFF  215,21B
6358:  MOVLW  1F
635A:  MOVLB  2
635C:  MOVWF  x1C
635E:  MOVLB  0
6360:  CALL   4F7C
6364:  MOVFF  216,21B
6368:  MOVLW  1F
636A:  MOVLB  2
636C:  MOVWF  x1C
636E:  MOVLB  0
6370:  CALL   4F7C
6374:  MOVFF  217,21B
6378:  MOVLW  1F
637A:  MOVLB  2
637C:  MOVWF  x1C
637E:  MOVLB  0
6380:  CALL   4F7C
6384:  MOVFF  218,21B
6388:  MOVLW  1F
638A:  MOVLB  2
638C:  MOVWF  x1C
638E:  MOVLB  0
6390:  CALL   4F7C
6394:  MOVFF  219,21B
6398:  MOVLW  1F
639A:  MOVLB  2
639C:  MOVWF  x1C
639E:  MOVLB  0
63A0:  CALL   4F7C
63A4:  MOVFF  21A,21B
63A8:  MOVLW  1F
63AA:  MOVLB  2
63AC:  MOVWF  x1C
63AE:  MOVLB  0
63B0:  CALL   4F7C
....................          if (CmdReceived == CMD_NA) { 
63B4:  MOVLB  1
63B6:  MOVF   xA8,F
63B8:  BTFSS  FD8.2
63BA:  BRA    6572
....................             if (IsEnc28J60Reset == TRUE){ 
63BC:  MOVLB  0
63BE:  BTFSS  x83.3
63C0:  BRA    644C
....................                printf(ClientSockPut, "RS:%s,%X%X%X%X\n", ioStates, MY_MAC_BYTE3, MY_MAC_BYTE4, MY_MAC_BYTE5, MY_MAC_BYTE6); 
63C2:  MOVLW  52
63C4:  MOVLB  2
63C6:  MOVWF  x0D
63C8:  MOVLB  0
63CA:  CALL   536E
63CE:  MOVLW  53
63D0:  MOVLB  2
63D2:  MOVWF  x0D
63D4:  MOVLB  0
63D6:  CALL   536E
63DA:  MOVLW  3A
63DC:  MOVLB  2
63DE:  MOVWF  x0D
63E0:  MOVLB  0
63E2:  CALL   536E
63E6:  MOVLW  01
63E8:  MOVWF  FEA
63EA:  MOVLW  F0
63EC:  MOVWF  FE9
63EE:  CALL   537A
63F2:  MOVLW  2C
63F4:  MOVLB  2
63F6:  MOVWF  x0D
63F8:  MOVLB  0
63FA:  CALL   536E
63FE:  MOVFF  49,20B
6402:  MOVLW  37
6404:  MOVLB  2
6406:  MOVWF  x0C
6408:  MOVLB  0
640A:  CALL   539E
640E:  MOVFF  4A,20B
6412:  MOVLW  37
6414:  MOVLB  2
6416:  MOVWF  x0C
6418:  MOVLB  0
641A:  CALL   539E
641E:  MOVFF  4B,20B
6422:  MOVLW  37
6424:  MOVLB  2
6426:  MOVWF  x0C
6428:  MOVLB  0
642A:  CALL   539E
642E:  MOVFF  4C,20B
6432:  MOVLW  37
6434:  MOVLB  2
6436:  MOVWF  x0C
6438:  MOVLB  0
643A:  CALL   539E
643E:  MOVLW  0A
6440:  MOVLB  2
6442:  MOVWF  x0D
6444:  MOVLB  0
6446:  CALL   536E
....................             }       
....................             else if (IsInputChanged == TRUE){ 
644A:  BRA    6562
644C:  BTFSS  x83.2
644E:  BRA    64DA
....................                printf(ClientSockPut, "CH:%s,%X%X%X%X\n", ioStates, MY_MAC_BYTE3, MY_MAC_BYTE4, MY_MAC_BYTE5, MY_MAC_BYTE6); 
6450:  MOVLW  43
6452:  MOVLB  2
6454:  MOVWF  x0D
6456:  MOVLB  0
6458:  CALL   536E
645C:  MOVLW  48
645E:  MOVLB  2
6460:  MOVWF  x0D
6462:  MOVLB  0
6464:  CALL   536E
6468:  MOVLW  3A
646A:  MOVLB  2
646C:  MOVWF  x0D
646E:  MOVLB  0
6470:  CALL   536E
6474:  MOVLW  01
6476:  MOVWF  FEA
6478:  MOVLW  F0
647A:  MOVWF  FE9
647C:  CALL   537A
6480:  MOVLW  2C
6482:  MOVLB  2
6484:  MOVWF  x0D
6486:  MOVLB  0
6488:  CALL   536E
648C:  MOVFF  49,20B
6490:  MOVLW  37
6492:  MOVLB  2
6494:  MOVWF  x0C
6496:  MOVLB  0
6498:  CALL   539E
649C:  MOVFF  4A,20B
64A0:  MOVLW  37
64A2:  MOVLB  2
64A4:  MOVWF  x0C
64A6:  MOVLB  0
64A8:  CALL   539E
64AC:  MOVFF  4B,20B
64B0:  MOVLW  37
64B2:  MOVLB  2
64B4:  MOVWF  x0C
64B6:  MOVLB  0
64B8:  CALL   539E
64BC:  MOVFF  4C,20B
64C0:  MOVLW  37
64C2:  MOVLB  2
64C4:  MOVWF  x0C
64C6:  MOVLB  0
64C8:  CALL   539E
64CC:  MOVLW  0A
64CE:  MOVLB  2
64D0:  MOVWF  x0D
64D2:  MOVLB  0
64D4:  CALL   536E
....................             } 
....................             else { 
64D8:  BRA    6562
....................                printf(ClientSockPut, "ST:%s,%X%X%X%X\n", ioStates, MY_MAC_BYTE3, MY_MAC_BYTE4, MY_MAC_BYTE5, MY_MAC_BYTE6); 
64DA:  MOVLW  53
64DC:  MOVLB  2
64DE:  MOVWF  x0D
64E0:  MOVLB  0
64E2:  CALL   536E
64E6:  MOVLW  54
64E8:  MOVLB  2
64EA:  MOVWF  x0D
64EC:  MOVLB  0
64EE:  CALL   536E
64F2:  MOVLW  3A
64F4:  MOVLB  2
64F6:  MOVWF  x0D
64F8:  MOVLB  0
64FA:  CALL   536E
64FE:  MOVLW  01
6500:  MOVWF  FEA
6502:  MOVLW  F0
6504:  MOVWF  FE9
6506:  CALL   537A
650A:  MOVLW  2C
650C:  MOVLB  2
650E:  MOVWF  x0D
6510:  MOVLB  0
6512:  CALL   536E
6516:  MOVFF  49,20B
651A:  MOVLW  37
651C:  MOVLB  2
651E:  MOVWF  x0C
6520:  MOVLB  0
6522:  CALL   539E
6526:  MOVFF  4A,20B
652A:  MOVLW  37
652C:  MOVLB  2
652E:  MOVWF  x0C
6530:  MOVLB  0
6532:  CALL   539E
6536:  MOVFF  4B,20B
653A:  MOVLW  37
653C:  MOVLB  2
653E:  MOVWF  x0C
6540:  MOVLB  0
6542:  CALL   539E
6546:  MOVFF  4C,20B
654A:  MOVLW  37
654C:  MOVLB  2
654E:  MOVWF  x0C
6550:  MOVLB  0
6552:  CALL   539E
6556:  MOVLW  0A
6558:  MOVLB  2
655A:  MOVWF  x0D
655C:  MOVLB  0
655E:  CALL   536E
....................             } 
....................             if (IsInputChanged == TRUE){ 
6562:  BTFSS  x83.2
6564:  BRA    6568
....................                IsInputChanged = FALSE; 
6566:  BCF    x83.2
....................             } 
....................             if (IsEnc28J60Reset == TRUE){ 
6568:  BTFSS  x83.3
656A:  BRA    656E
....................                IsEnc28J60Reset = FALSE; 
656C:  BCF    x83.3
....................             } 
....................          } 
....................           
....................          else { // CmdReceived == CMD_IO  
656E:  BRA    65AE
6570:  MOVLB  1
....................             printf(ClientSockPut, "IO:%s\n", ioStates); 
6572:  MOVLW  49
6574:  MOVLB  2
6576:  MOVWF  x0D
6578:  MOVLB  0
657A:  CALL   536E
657E:  MOVLW  4F
6580:  MOVLB  2
6582:  MOVWF  x0D
6584:  MOVLB  0
6586:  CALL   536E
658A:  MOVLW  3A
658C:  MOVLB  2
658E:  MOVWF  x0D
6590:  MOVLB  0
6592:  CALL   536E
6596:  MOVLW  01
6598:  MOVWF  FEA
659A:  MOVLW  F0
659C:  MOVWF  FE9
659E:  CALL   537A
65A2:  MOVLW  0A
65A4:  MOVLB  2
65A6:  MOVWF  x0D
65A8:  MOVLB  0
65AA:  CALL   536E
....................          }          
....................       } 
....................       else if (CmdReceived == CMD_CF) { 
65AE:  BRA    68BC
65B0:  MOVLB  1
65B2:  MOVF   xA8,W
65B4:  SUBLW  02
65B6:  BTFSS  FD8.2
65B8:  BRA    68AE
....................          char inputTypes[9]; 
....................          sprintf(inputTypes, "%d%d%d%d%d%d%d%d", 
....................                MyEEPRom.InputTypes[0], MyEEPRom.InputTypes[1], MyEEPRom.InputTypes[2], MyEEPRom.InputTypes[3], 
....................                MyEEPRom.InputTypes[4], MyEEPRom.InputTypes[5], MyEEPRom.InputTypes[6], MyEEPRom.InputTypes[7]); 
65BA:  MOVLW  02
65BC:  MOVWF  xD0
65BE:  MOVWF  xCF
65C0:  MOVFF  3B,21B
65C4:  MOVLW  1F
65C6:  MOVLB  2
65C8:  MOVWF  x1C
65CA:  MOVLB  0
65CC:  CALL   4F7C
65D0:  MOVFF  3C,21B
65D4:  MOVLW  1F
65D6:  MOVLB  2
65D8:  MOVWF  x1C
65DA:  MOVLB  0
65DC:  CALL   4F7C
65E0:  MOVFF  3D,21B
65E4:  MOVLW  1F
65E6:  MOVLB  2
65E8:  MOVWF  x1C
65EA:  MOVLB  0
65EC:  CALL   4F7C
65F0:  MOVFF  3E,21B
65F4:  MOVLW  1F
65F6:  MOVLB  2
65F8:  MOVWF  x1C
65FA:  MOVLB  0
65FC:  CALL   4F7C
6600:  MOVFF  3F,21B
6604:  MOVLW  1F
6606:  MOVLB  2
6608:  MOVWF  x1C
660A:  MOVLB  0
660C:  CALL   4F7C
6610:  MOVFF  40,21B
6614:  MOVLW  1F
6616:  MOVLB  2
6618:  MOVWF  x1C
661A:  MOVLB  0
661C:  CALL   4F7C
6620:  MOVFF  41,21B
6624:  MOVLW  1F
6626:  MOVLB  2
6628:  MOVWF  x1C
662A:  MOVLB  0
662C:  CALL   4F7C
6630:  MOVFF  42,21B
6634:  MOVLW  1F
6636:  MOVLB  2
6638:  MOVWF  x1C
663A:  MOVLB  0
663C:  CALL   4F7C
....................          printf(ClientSockPut, 
....................             "CF:%X.%X.%X.%X,%X.%X.%X.%X,%X.%X.%X.%X,%X.%X.%X.%X,%X-%X-%X-%X,%s\n", 
....................             MyEEPRom.SrvIps[0], MyEEPRom.SrvIps[1], MyEEPRom.SrvIps[2], MyEEPRom.SrvIps[3], 
....................             MyEEPRom.Ips[0], MyEEPRom.Ips[1], MyEEPRom.Ips[2], MyEEPRom.Ips[3], 
....................             MyEEPRom.Masks[0], MyEEPRom.Masks[1], MyEEPRom.Masks[2], MyEEPRom.Masks[3],  
....................             MyEEPRom.Gates[0], MyEEPRom.Gates[1], MyEEPRom.Gates[2], MyEEPRom.Gates[3], 
....................             // Just send mac from byte 3 to 6 
....................             MyEEPRom.Macs[0], MyEEPRom.Macs[1], MyEEPRom.Macs[2], MyEEPRom.Macs[3], 
....................             inputTypes); 
6640:  MOVLW  43
6642:  MOVLB  2
6644:  MOVWF  x0D
6646:  MOVLB  0
6648:  CALL   536E
664C:  MOVLW  46
664E:  MOVLB  2
6650:  MOVWF  x0D
6652:  MOVLB  0
6654:  CALL   536E
6658:  MOVLW  3A
665A:  MOVLB  2
665C:  MOVWF  x0D
665E:  MOVLB  0
6660:  CALL   536E
6664:  MOVFF  27,20B
6668:  MOVLW  37
666A:  MOVLB  2
666C:  MOVWF  x0C
666E:  MOVLB  0
6670:  CALL   539E
6674:  MOVLW  2E
6676:  MOVLB  2
6678:  MOVWF  x0D
667A:  MOVLB  0
667C:  CALL   536E
6680:  MOVFF  28,20B
6684:  MOVLW  37
6686:  MOVLB  2
6688:  MOVWF  x0C
668A:  MOVLB  0
668C:  CALL   539E
6690:  MOVLW  2E
6692:  MOVLB  2
6694:  MOVWF  x0D
6696:  MOVLB  0
6698:  CALL   536E
669C:  MOVFF  29,20B
66A0:  MOVLW  37
66A2:  MOVLB  2
66A4:  MOVWF  x0C
66A6:  MOVLB  0
66A8:  CALL   539E
66AC:  MOVLW  2E
66AE:  MOVLB  2
66B0:  MOVWF  x0D
66B2:  MOVLB  0
66B4:  CALL   536E
66B8:  MOVFF  2A,20B
66BC:  MOVLW  37
66BE:  MOVLB  2
66C0:  MOVWF  x0C
66C2:  MOVLB  0
66C4:  CALL   539E
66C8:  MOVLW  2C
66CA:  MOVLB  2
66CC:  MOVWF  x0D
66CE:  MOVLB  0
66D0:  CALL   536E
66D4:  MOVFF  2B,20B
66D8:  MOVLW  37
66DA:  MOVLB  2
66DC:  MOVWF  x0C
66DE:  MOVLB  0
66E0:  CALL   539E
66E4:  MOVLW  2E
66E6:  MOVLB  2
66E8:  MOVWF  x0D
66EA:  MOVLB  0
66EC:  CALL   536E
66F0:  MOVFF  2C,20B
66F4:  MOVLW  37
66F6:  MOVLB  2
66F8:  MOVWF  x0C
66FA:  MOVLB  0
66FC:  CALL   539E
6700:  MOVLW  2E
6702:  MOVLB  2
6704:  MOVWF  x0D
6706:  MOVLB  0
6708:  CALL   536E
670C:  MOVFF  2D,20B
6710:  MOVLW  37
6712:  MOVLB  2
6714:  MOVWF  x0C
6716:  MOVLB  0
6718:  CALL   539E
671C:  MOVLW  2E
671E:  MOVLB  2
6720:  MOVWF  x0D
6722:  MOVLB  0
6724:  CALL   536E
6728:  MOVFF  2E,20B
672C:  MOVLW  37
672E:  MOVLB  2
6730:  MOVWF  x0C
6732:  MOVLB  0
6734:  CALL   539E
6738:  MOVLW  2C
673A:  MOVLB  2
673C:  MOVWF  x0D
673E:  MOVLB  0
6740:  CALL   536E
6744:  MOVFF  2F,20B
6748:  MOVLW  37
674A:  MOVLB  2
674C:  MOVWF  x0C
674E:  MOVLB  0
6750:  CALL   539E
6754:  MOVLW  2E
6756:  MOVLB  2
6758:  MOVWF  x0D
675A:  MOVLB  0
675C:  CALL   536E
6760:  MOVFF  30,20B
6764:  MOVLW  37
6766:  MOVLB  2
6768:  MOVWF  x0C
676A:  MOVLB  0
676C:  CALL   539E
6770:  MOVLW  2E
6772:  MOVLB  2
6774:  MOVWF  x0D
6776:  MOVLB  0
6778:  CALL   536E
677C:  MOVFF  31,20B
6780:  MOVLW  37
6782:  MOVLB  2
6784:  MOVWF  x0C
6786:  MOVLB  0
6788:  CALL   539E
678C:  MOVLW  2E
678E:  MOVLB  2
6790:  MOVWF  x0D
6792:  MOVLB  0
6794:  CALL   536E
6798:  MOVFF  32,20B
679C:  MOVLW  37
679E:  MOVLB  2
67A0:  MOVWF  x0C
67A2:  MOVLB  0
67A4:  CALL   539E
67A8:  MOVLW  2C
67AA:  MOVLB  2
67AC:  MOVWF  x0D
67AE:  MOVLB  0
67B0:  CALL   536E
67B4:  MOVFF  33,20B
67B8:  MOVLW  37
67BA:  MOVLB  2
67BC:  MOVWF  x0C
67BE:  MOVLB  0
67C0:  CALL   539E
67C4:  MOVLW  2E
67C6:  MOVLB  2
67C8:  MOVWF  x0D
67CA:  MOVLB  0
67CC:  CALL   536E
67D0:  MOVFF  34,20B
67D4:  MOVLW  37
67D6:  MOVLB  2
67D8:  MOVWF  x0C
67DA:  MOVLB  0
67DC:  CALL   539E
67E0:  MOVLW  2E
67E2:  MOVLB  2
67E4:  MOVWF  x0D
67E6:  MOVLB  0
67E8:  CALL   536E
67EC:  MOVFF  35,20B
67F0:  MOVLW  37
67F2:  MOVLB  2
67F4:  MOVWF  x0C
67F6:  MOVLB  0
67F8:  CALL   539E
67FC:  MOVLW  2E
67FE:  MOVLB  2
6800:  MOVWF  x0D
6802:  MOVLB  0
6804:  CALL   536E
6808:  MOVFF  36,20B
680C:  MOVLW  37
680E:  MOVLB  2
6810:  MOVWF  x0C
6812:  MOVLB  0
6814:  CALL   539E
6818:  MOVLW  2C
681A:  MOVLB  2
681C:  MOVWF  x0D
681E:  MOVLB  0
6820:  CALL   536E
6824:  MOVFF  37,20B
6828:  MOVLW  37
682A:  MOVLB  2
682C:  MOVWF  x0C
682E:  MOVLB  0
6830:  CALL   539E
6834:  MOVLW  2D
6836:  MOVLB  2
6838:  MOVWF  x0D
683A:  MOVLB  0
683C:  CALL   536E
6840:  MOVFF  38,20B
6844:  MOVLW  37
6846:  MOVLB  2
6848:  MOVWF  x0C
684A:  MOVLB  0
684C:  CALL   539E
6850:  MOVLW  2D
6852:  MOVLB  2
6854:  MOVWF  x0D
6856:  MOVLB  0
6858:  CALL   536E
685C:  MOVFF  39,20B
6860:  MOVLW  37
6862:  MOVLB  2
6864:  MOVWF  x0C
6866:  MOVLB  0
6868:  CALL   539E
686C:  MOVLW  2D
686E:  MOVLB  2
6870:  MOVWF  x0D
6872:  MOVLB  0
6874:  CALL   536E
6878:  MOVFF  3A,20B
687C:  MOVLW  37
687E:  MOVLB  2
6880:  MOVWF  x0C
6882:  MOVLB  0
6884:  CALL   539E
6888:  MOVLW  2C
688A:  MOVLB  2
688C:  MOVWF  x0D
688E:  MOVLB  0
6890:  CALL   536E
6894:  MOVLW  02
6896:  MOVWF  FEA
6898:  MOVWF  FE9
689A:  CALL   537A
689E:  MOVLW  0A
68A0:  MOVLB  2
68A2:  MOVWF  x0D
68A4:  MOVLB  0
68A6:  CALL   536E
....................       } 
....................       else { //CmdReceived == CMD_ER 
68AA:  BRA    68BC
68AC:  MOVLB  1
....................          printf(ClientSockPut, "ER:BADCMD\n"); 
68AE:  MOVLW  DA
68B0:  MOVWF  FF6
68B2:  MOVLW  00
68B4:  MOVWF  FF7
68B6:  MOVLB  0
68B8:  GOTO   53E4
....................       } 
....................        
....................       // Send the packet 
....................       TCPFlush(ClientSocket); 
68BC:  MOVFF  1C9,214
68C0:  CALL   505A
....................       if (CmdReceived == CMD_NA) { 
68C4:  MOVLB  1
68C6:  MOVF   xA8,F
68C8:  BNZ   68D0
....................          TCPClientState = SM_PROCESS_RESPONSE; 
68CA:  MOVLW  05
68CC:  MOVWF  xCE
....................       } 
....................       else { 
68CE:  BRA    68D4
....................          TCPClientState = SM_DISCONNECT; 
68D0:  MOVLW  06
68D2:  MOVWF  xCE
....................       } 
....................       Timer = TickGet(); 
68D4:  MOVLB  0
68D6:  CALL   0FE8
68DA:  MOVFF  02,1CD
68DE:  MOVFF  01,1CC
....................       break; 
68E2:  MOVLB  1
68E4:  BRA    6A1C
....................  
....................    case SM_PROCESS_RESPONSE: 
....................       IsTCPClientBusy = TRUE; 
68E6:  BSF    x83.4
....................       // Check to see if the remote node has disconnected from us or sent us any application data 
....................       if (!TCPIsConnected(ClientSocket)) { 
68E8:  MOVFF  1C9,20B
68EC:  CALL   4E5E
68F0:  MOVF   01,F
68F2:  BNZ   6900
....................          IsTCPClientBusy = FALSE; 
68F4:  BCF    x83.4
....................          TCPClientState = SM_DISCONNECT; 
68F6:  MOVLW  06
68F8:  MOVLB  1
68FA:  MOVWF  xCE
....................          break; 
68FC:  BRA    6A1C
68FE:  MOVLB  0
....................       } 
....................       if (!TCPIsGetReady(ClientSocket)) { 
6900:  MOVFF  1C9,20B
6904:  GOTO   5406
6908:  MOVF   01,F
690A:  BNZ   6952
....................          IsTCPClientBusy = FALSE; 
690C:  BCF    x83.4
....................          if (TickGet() - Timer > 30 * TICK_SECOND) { 
690E:  CALL   0FE8
6912:  MOVFF  02,20C
6916:  MOVFF  01,20B
691A:  MOVLB  1
691C:  MOVF   xCC,W
691E:  MOVLB  2
6920:  SUBWF  x0B,F
6922:  MOVLB  1
6924:  MOVF   xCD,W
6926:  MOVLB  2
6928:  SUBWFB x0C,F
692A:  MOVF   x0C,W
692C:  SUBLW  00
692E:  BC    6940
6930:  XORLW  FF
6932:  BNZ   693A
6934:  MOVF   x0B,W
6936:  SUBLW  68
6938:  BC    6940
....................             TCPClientState = SM_DISCONNECT; 
693A:  MOVLW  06
693C:  MOVLB  1
693E:  MOVWF  xCE
....................          } 
....................          if (IsInputChanged == TRUE) { 
6940:  MOVLB  0
6942:  BTFSS  x83.2
6944:  BRA    694C
....................             TCPClientState = SM_DISCONNECT; 
6946:  MOVLW  06
6948:  MOVLB  1
694A:  MOVWF  xCE
....................          } 
....................          break; 
694C:  MOVLB  1
694E:  BRA    6A1C
6950:  MOVLB  0
....................       } 
....................       TCPLedOn(); 
6952:  CALL   4E88
....................       BuffI = 0; 
6956:  MOVLB  1
6958:  CLRF   xEF
....................       // Obtain the server reply 
....................       while (TCPGet(ClientSocket, &BuffC)) { 
695A:  MOVFF  1C9,20B
695E:  MOVLW  01
6960:  MOVLB  2
6962:  MOVWF  x0D
6964:  MOVLW  EE
6966:  MOVWF  x0C
6968:  MOVLB  0
696A:  GOTO   5434
696E:  MOVF   01,F
6970:  BZ    6996
....................          DataReceived[BuffI] = BuffC; 
6972:  CLRF   03
6974:  MOVLB  1
6976:  MOVF   xEF,W
6978:  ADDLW  A9
697A:  MOVWF  FE9
697C:  MOVLW  01
697E:  ADDWFC 03,W
6980:  MOVWF  FEA
6982:  MOVFF  1EE,FEF
....................          BuffI++; 
6986:  INCF   xEF,F
....................          if (BuffC == '\n') { 
6988:  MOVF   xEE,W
698A:  SUBLW  0A
698C:  BNZ   6994
....................             break; 
698E:  MOVLB  0
6990:  BRA    6996
6992:  MOVLB  1
....................          } 
....................       } 
6994:  BRA    695A
....................  
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\fREQ:%s", DataReceived); 
.................... #endif 
....................       // Handle Data Received 
....................       if (ObjFound('i', 'o')) { 
6996:  MOVLW  69
6998:  MOVLB  2
699A:  MOVWF  x0B
699C:  MOVLW  6F
699E:  MOVWF  x0C
69A0:  MOVLB  0
69A2:  CALL   550A
69A6:  MOVF   01,F
69A8:  BZ    69B6
....................          IOReqHandle(); 
69AA:  GOTO   567C
....................          CmdReceived = CMD_IO; 
69AE:  MOVLW  01
69B0:  MOVLB  1
69B2:  MOVWF  xA8
....................       } 
....................       else if (ObjFound('c', 'f')) { 
69B4:  BRA    69E2
69B6:  MOVLW  63
69B8:  MOVLB  2
69BA:  MOVWF  x0B
69BC:  MOVLW  66
69BE:  MOVWF  x0C
69C0:  MOVLB  0
69C2:  CALL   550A
69C6:  MOVF   01,F
69C8:  BZ    69D8
....................          CfReqHandle(); 
69CA:  GOTO   5E18
....................          CmdReceived = CMD_CF; 
69CE:  MOVLW  02
69D0:  MOVLB  1
69D2:  MOVWF  xA8
....................       } 
....................       else { 
69D4:  BRA    69E2
69D6:  MOVLB  0
....................          LCDPrintCmdUK(); 
69D8:  CALL   0006
....................          CmdReceived = CMD_ER; 
69DC:  MOVLW  03
69DE:  MOVLB  1
69E0:  MOVWF  xA8
....................       } 
....................  
....................       // Continue reading data... 
....................       Timer = TickGet(); 
69E2:  MOVLB  0
69E4:  CALL   0FE8
69E8:  MOVFF  02,1CD
69EC:  MOVFF  01,1CC
....................       TCPClientState = SM_SOCKET_OBTAINED; 
69F0:  MOVLW  04
69F2:  MOVLB  1
69F4:  MOVWF  xCE
....................       break; 
69F6:  BRA    6A1C
....................  
....................    case SM_DISCONNECT: 
....................       // Close the socket so it can be used by other modules 
....................       // For this application, we wish to stay connected, but this state will still get entered if the remote server decides to disconnect 
....................       TCPDisconnect(ClientSocket); 
69F8:  MOVFF  1C9,20B
69FC:  GOTO   5F48
....................       ClientSocket = INVALID_SOCKET; 
6A00:  MOVLW  FE
6A02:  MOVLB  1
6A04:  MOVWF  xC9
....................       TCPClientState = SM_DONE;       
6A06:  MOVLW  07
6A08:  MOVWF  xCE
....................       break; 
6A0A:  BRA    6A1C
....................  
....................    case SM_DONE: 
....................       TCPClientState = SM_HOME;    
6A0C:  MOVLB  1
6A0E:  CLRF   xCE
....................       TCPLedOff(); 
6A10:  MOVLB  0
6A12:  CALL   0E1A
....................       break; 
6A16:  MOVLB  1
6A18:  BRA    6A1C
6A1A:  MOVLB  1
....................    } 
.................... } 
6A1C:  MOVLB  0
6A1E:  GOTO   6BC8 (RETURN)
....................  
.................... #include "inputscan.c" 
.................... /********************************************************************* 
....................  * 
....................  * Inputs Changed Handler to handle input change. When input changed, 
....................  * output pin will be switched state and trigger InChangedFlag to make 
....................  * TCPClient send notification to IOnOff server 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        inlisten.c 
....................  * Dependencies:    tcp.h, dns.h, tcpclient.c, config.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30, dsPIC33F 
....................  * Complier:        CCS 4.15 
....................  * Company:         IOnOff Technology. 
....................  * 
....................  * Author           Date          Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * SannTran          30/06/2016      Original 
....................  ********************************************************************/ 
.................... // 9 includes RESET button 
.................... BOOLEAN InStates[9]; 
.................... BOOLEAN NewInStates[9]; 
.................... BOOLEAN InStatesChanged[9]; 
.................... TICKTYPE InStatesChangedTime[9]; 
.................... BOOLEAN ControlDecisions[9]; 
....................  
.................... // 
.................... TICKTYPE ResetPressedTime; 
....................  
.................... // Init pin as output and input 
.................... void InsStore(void) { 
....................    InStates[0] = input_state(IN_RESET); 
*
0FAA:  MOVLB  1
0FAC:  BCF    xD1.0
0FAE:  BTFSC  F81.3
0FB0:  BSF    xD1.0
....................    InStates[1] = input_state(IN_1); 
0FB2:  BCF    xD1.1
0FB4:  BTFSC  F83.7
0FB6:  BSF    xD1.1
....................    InStates[2] = input_state(IN_2); 
0FB8:  BCF    xD1.2
0FBA:  BTFSC  F81.0
0FBC:  BSF    xD1.2
....................    InStates[3] = input_state(IN_3); 
0FBE:  BCF    xD1.3
0FC0:  BTFSC  F81.1
0FC2:  BSF    xD1.3
....................    InStates[4] = input_state(IN_4); 
0FC4:  BCF    xD1.4
0FC6:  BTFSC  F81.2
0FC8:  BSF    xD1.4
....................    InStates[5] = input_state(IN_5); 
0FCA:  BCF    xD1.5
0FCC:  BTFSC  F82.4
0FCE:  BSF    xD1.5
....................    InStates[6] = input_state(IN_6); 
0FD0:  BCF    xD1.6
0FD2:  BTFSC  F82.5
0FD4:  BSF    xD1.6
....................    InStates[7] = input_state(IN_7); 
0FD6:  BCF    xD1.7
0FD8:  BTFSC  F83.5
0FDA:  BSF    xD1.7
....................    InStates[8] = input_state(IN_8); 
0FDC:  BCF    xD2.0
0FDE:  BTFSC  F83.6
0FE0:  BSF    xD2.0
.................... } 
0FE2:  MOVLB  0
0FE4:  GOTO   1004 (RETURN)
....................  
.................... void InputsScanInit(void) { 
....................    InsStore(); 
*
1002:  BRA    0FAA
....................    TICKTYPE tick = TickGet(); 
....................    int8 i; 
1004:  RCALL  0FE8
1006:  MOVFF  02,1EF
100A:  MOVFF  01,1EE
....................    for (i = 0; i < 9; i++) {       
100E:  MOVLB  1
1010:  CLRF   xF0
1012:  MOVF   xF0,W
1014:  SUBLW  08
1016:  BNC   104C
....................       InStatesChanged[i] = FALSE; 
1018:  MOVFF  1F0,20F
101C:  MOVLB  2
101E:  CLRF   x10
1020:  MOVLW  01
1022:  MOVWF  x12
1024:  MOVLW  D5
1026:  MOVWF  x11
1028:  MOVLB  0
102A:  RCALL  0E20
....................       InStatesChangedTime[i] = tick; 
102C:  BCF    FD8.0
102E:  MOVLB  1
1030:  RLCF   xF0,W
1032:  CLRF   03
1034:  ADDLW  D7
1036:  MOVWF  FE9
1038:  MOVLW  01
103A:  ADDWFC 03,W
103C:  MOVWF  FEA
103E:  MOVFF  1EF,FEC
1042:  MOVF   FED,F
1044:  MOVFF  1EE,FEF
....................    } 
1048:  INCF   xF0,F
104A:  BRA    1012
....................    IsInputChanged = FALSE; 
104C:  MOVLB  0
104E:  BCF    x83.2
....................    ResetPressedTime = 0; 
1050:  MOVLB  1
1052:  CLRF   xEC
1054:  CLRF   xEB
.................... } 
1056:  MOVLB  0
1058:  GOTO   6B7C (RETURN)
....................  
.................... void OnResetBtnReleased(void) { 
....................    if ((TickGet() - ResetPressedTime) > 5 * TICK_SECOND) { 
*
45C0:  CALL   0FE8
45C4:  MOVFF  02,1F0
45C8:  MOVFF  01,1EF
45CC:  MOVLB  1
45CE:  MOVF   xEB,W
45D0:  SUBWF  xEF,F
45D2:  MOVF   xEC,W
45D4:  SUBWFB xF0,F
45D6:  BNZ   45DE
45D8:  MOVF   xEF,W
45DA:  SUBLW  3C
45DC:  BC    45EC
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\f%s", "ResetAll..."); 
.................... #endif 
....................       ConfigReset(); 
45DE:  MOVLB  0
45E0:  CALL   0A50
....................       EEPWriteConfig(); 
45E4:  CALL   0CE2
....................    } 
....................    else { 
45E8:  BRA    45EA
45EA:  MOVLB  1
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\f%s", "ResetPIC..."); 
.................... #endif 
....................    } 
....................    // Just delay to let WDT reset 
....................    output_low(OUT_IAM_RUNNING); 
45EC:  BCF    F95.0
45EE:  BCF    F8C.0
45F0:  CLRF   19
45F2:  BTFSC  FF2.7
45F4:  BSF    19.7
45F6:  BCF    FF2.7
....................    delay_ms(10); 
45F8:  MOVLW  0A
45FA:  MOVLB  2
45FC:  MOVWF  xA9
45FE:  MOVLB  0
4600:  CALL   00E6
4604:  BTFSC  19.7
4606:  BSF    FF2.7
....................    setup_wdt(WDT_ON); 
4608:  BSF    FD1.0
....................    restart_wdt(); 
460A:  CLRWDT
.................... } 
460C:  GOTO   49DA (RETURN)
....................  
.................... void InChangedHandle(int8 pin, int8 idx) { 
.................... #ifdef USE_PORTD_LCD 
....................     printf(lcd_putc, "\fIN_%d Changed OK", idx); 
.................... #endif 
....................  
....................     IsInputChanged = TRUE; 
*
4802:  BSF    x83.2
....................     output_toggle(pin); 
4804:  MOVFF  1EF,1F2
4808:  MOVLW  0F
480A:  MOVLB  1
480C:  MOVWF  xF4
480E:  MOVLW  80
4810:  MOVWF  xF3
4812:  MOVLB  0
4814:  RCALL  458E
4816:  MOVLW  00
4818:  BTFSS  01.0
481A:  MOVLW  01
481C:  MOVFF  1EF,20F
4820:  MOVLB  2
4822:  MOVWF  x10
4824:  MOVLW  0F
4826:  MOVWF  x12
4828:  MOVLW  89
482A:  MOVWF  x11
482C:  MOVLB  0
482E:  CALL   0E20
4832:  MOVFF  1EF,20F
4836:  MOVLB  2
4838:  CLRF   x10
483A:  MOVLW  0F
483C:  MOVWF  x12
483E:  MOVLW  92
4840:  MOVWF  x11
4842:  MOVLB  0
4844:  CALL   0E20
....................     EEPWriteOutputState(idx); 
4848:  MOVFF  1F0,20F
484C:  RCALL  4610
.................... } 
484E:  RETLW  00
....................  
.................... void InsListen(void) {    
....................    int8 i; 
....................    for (i = 0; i < 9; i++) { 
4850:  MOVLB  1
4852:  CLRF   xEE
4854:  MOVF   xEE,W
4856:  SUBLW  08
4858:  BNC   4876
....................       ControlDecisions[i] = FALSE; 
485A:  MOVFF  1EE,20F
485E:  MOVLB  2
4860:  CLRF   x10
4862:  MOVLW  01
4864:  MOVWF  x12
4866:  MOVLW  E9
4868:  MOVWF  x11
486A:  MOVLB  0
486C:  CALL   0E20
....................    } 
4870:  MOVLB  1
4872:  INCF   xEE,F
4874:  BRA    4854
....................    NewInStates[0] = input_state(IN_RESET); 
4876:  BCF    xD3.0
4878:  BTFSC  F81.3
487A:  BSF    xD3.0
....................    NewInStates[1] = input_state(IN_1); 
487C:  BCF    xD3.1
487E:  BTFSC  F83.7
4880:  BSF    xD3.1
....................    NewInStates[2] = input_state(IN_2); 
4882:  BCF    xD3.2
4884:  BTFSC  F81.0
4886:  BSF    xD3.2
....................    NewInStates[3] = input_state(IN_3); 
4888:  BCF    xD3.3
488A:  BTFSC  F81.1
488C:  BSF    xD3.3
....................    NewInStates[4] = input_state(IN_4); 
488E:  BCF    xD3.4
4890:  BTFSC  F81.2
4892:  BSF    xD3.4
....................    NewInStates[5] = input_state(IN_5); 
4894:  BCF    xD3.5
4896:  BTFSC  F82.4
4898:  BSF    xD3.5
....................    NewInStates[6] = input_state(IN_6); 
489A:  BCF    xD3.6
489C:  BTFSC  F82.5
489E:  BSF    xD3.6
....................    NewInStates[7] = input_state(IN_7); 
48A0:  BCF    xD3.7
48A2:  BTFSC  F83.5
48A4:  BSF    xD3.7
....................    NewInStates[8] = input_state(IN_8); 
48A6:  BCF    xD4.0
48A8:  BTFSC  F83.6
48AA:  BSF    xD4.0
....................  
....................    for (i = 0; i < 9; i++) { 
48AC:  CLRF   xEE
48AE:  MOVF   xEE,W
48B0:  SUBLW  08
48B2:  BTFSS  FD8.0
48B4:  BRA    4B32
....................       // If the input has changed before 
....................       if (InStatesChanged[i] == TRUE) { 
48B6:  MOVFF  1EE,1F2
48BA:  MOVLW  01
48BC:  MOVWF  xF4
48BE:  MOVLW  D5
48C0:  MOVWF  xF3
48C2:  MOVLB  0
48C4:  RCALL  458E
48C6:  MOVLW  00
48C8:  BTFSC  01.0
48CA:  MOVLW  01
48CC:  ANDLW  01
48CE:  SUBLW  01
48D0:  BTFSS  FD8.2
48D2:  BRA    4A72
....................           
....................         // If the input has changed for more than ~1/3 second 
....................         if ((TickGet() - InStatesChangedTime[i]) > 3) { 
48D4:  CALL   0FE8
48D8:  MOVFF  02,1F0
48DC:  MOVFF  01,1EF
48E0:  BCF    FD8.0
48E2:  MOVLB  1
48E4:  RLCF   xEE,W
48E6:  CLRF   03
48E8:  ADDLW  D7
48EA:  MOVWF  FE9
48EC:  MOVLW  01
48EE:  ADDWFC 03,W
48F0:  MOVWF  FEA
48F2:  MOVFF  FEC,03
48F6:  MOVF   FED,F
48F8:  MOVF   FEF,W
48FA:  SUBWF  xEF,F
48FC:  MOVF   03,W
48FE:  SUBWFB xF0,F
4900:  BNZ   490A
4902:  MOVF   xEF,W
4904:  SUBLW  03
4906:  BTFSC  FD8.0
4908:  BRA    4A6E
....................            
....................           // If the input state now is changed from stored input state 
....................           if ((InStates[i] == FALSE && NewInStates[i] == TRUE) || 
....................                   (InStates[i] == TRUE && NewInStates[i] == FALSE)) { 
490A:  MOVFF  1EE,1F2
490E:  MOVLW  01
4910:  MOVWF  xF4
4912:  MOVLW  D1
4914:  MOVWF  xF3
4916:  MOVLB  0
4918:  RCALL  458E
491A:  MOVLW  00
491C:  BTFSC  01.0
491E:  MOVLW  01
4920:  ANDLW  01
4922:  BNZ   4942
4924:  MOVFF  1EE,1F2
4928:  MOVLW  01
492A:  MOVLB  1
492C:  MOVWF  xF4
492E:  MOVLW  D3
4930:  MOVWF  xF3
4932:  MOVLB  0
4934:  RCALL  458E
4936:  MOVLW  00
4938:  BTFSC  01.0
493A:  MOVLW  01
493C:  ANDLW  01
493E:  SUBLW  01
4940:  BZ    497E
4942:  MOVFF  1EE,1F2
4946:  MOVLW  01
4948:  MOVLB  1
494A:  MOVWF  xF4
494C:  MOVLW  D1
494E:  MOVWF  xF3
4950:  MOVLB  0
4952:  RCALL  458E
4954:  MOVLW  00
4956:  BTFSC  01.0
4958:  MOVLW  01
495A:  ANDLW  01
495C:  SUBLW  01
495E:  BTFSS  FD8.2
4960:  BRA    4A56
4962:  MOVFF  1EE,1F2
4966:  MOVLW  01
4968:  MOVLB  1
496A:  MOVWF  xF4
496C:  MOVLW  D3
496E:  MOVWF  xF3
4970:  MOVLB  0
4972:  RCALL  458E
4974:  MOVLW  00
4976:  BTFSC  01.0
4978:  MOVLW  01
497A:  ANDLW  01
497C:  BNZ   4A56
....................              // The input state change is confirmed 
....................              InStates[i] = NewInStates[i]; 
497E:  MOVFF  1EE,1F2
4982:  MOVLW  01
4984:  MOVLB  1
4986:  MOVWF  xF4
4988:  MOVLW  D3
498A:  MOVWF  xF3
498C:  MOVLB  0
498E:  RCALL  458E
4990:  MOVFF  1EE,20F
4994:  MOVLB  2
4996:  CLRF   x10
4998:  BTFSC  01.0
499A:  INCF   x10,F
499C:  MOVLW  01
499E:  MOVWF  x12
49A0:  MOVLW  D1
49A2:  MOVWF  x11
49A4:  MOVLB  0
49A6:  CALL   0E20
....................               
....................               
....................              if (i == 0) { // this is reset input button 
49AA:  MOVLB  1
49AC:  MOVF   xEE,F
49AE:  BNZ   49DE
....................                 // Reset btn is pressed 
....................                 if (NewInStates[i] == FALSE) { 
49B0:  MOVFF  1EE,1F2
49B4:  MOVLW  01
49B6:  MOVWF  xF4
49B8:  MOVLW  D3
49BA:  MOVWF  xF3
49BC:  MOVLB  0
49BE:  RCALL  458E
49C0:  MOVLW  00
49C2:  BTFSC  01.0
49C4:  MOVLW  01
49C6:  ANDLW  01
49C8:  BNZ   49D8
....................                    ResetPressedTime = TickGet(); 
49CA:  CALL   0FE8
49CE:  MOVFF  02,1EC
49D2:  MOVFF  01,1EB
.................... #ifdef USE_PORTD_LCD 
....................                    printf(lcd_putc, "\f%s", "Reset-Pressed"); 
.................... #endif 
....................                 }                 
....................                 else { // Reset btn is released 
49D6:  BRA    49DA
....................                    OnResetBtnReleased(); 
49D8:  BRA    45C0
....................                 }                 
....................              } 
....................              else { // these are normal inputs for controling relays 
49DA:  BRA    4A3E
49DC:  MOVLB  1
....................                if (MY_INPUT_TYPE_BYTES[i - 1] == INPUT_BUTTON) { 
49DE:  MOVLW  01
49E0:  SUBWF  xEE,W
49E2:  CLRF   03
49E4:  ADDLW  1A
49E6:  MOVWF  FE9
49E8:  MOVLW  00
49EA:  ADDWFC 03,W
49EC:  MOVWF  FEA
49EE:  MOVF   FEF,W
49F0:  SUBLW  02
49F2:  BNZ   4A28
....................                   if (NewInStates[i] == FALSE) { // released button 
49F4:  MOVFF  1EE,1F2
49F8:  MOVLW  01
49FA:  MOVWF  xF4
49FC:  MOVLW  D3
49FE:  MOVWF  xF3
4A00:  MOVLB  0
4A02:  RCALL  458E
4A04:  MOVLW  00
4A06:  BTFSC  01.0
4A08:  MOVLW  01
4A0A:  ANDLW  01
4A0C:  BNZ   4A24
....................                      ControlDecisions[i] = TRUE; 
4A0E:  MOVFF  1EE,20F
4A12:  MOVLW  01
4A14:  MOVLB  2
4A16:  MOVWF  x10
4A18:  MOVWF  x12
4A1A:  MOVLW  E9
4A1C:  MOVWF  x11
4A1E:  MOVLB  0
4A20:  CALL   0E20
....................                   } 
....................                } 
....................                else { 
4A24:  BRA    4A3E
4A26:  MOVLB  1
....................                   ControlDecisions[i] = TRUE; 
4A28:  MOVFF  1EE,20F
4A2C:  MOVLW  01
4A2E:  MOVLB  2
4A30:  MOVWF  x10
4A32:  MOVWF  x12
4A34:  MOVLW  E9
4A36:  MOVWF  x11
4A38:  MOVLB  0
4A3A:  CALL   0E20
....................                } 
....................              } 
....................               
....................              InStatesChanged[i] = FALSE;  
4A3E:  MOVFF  1EE,20F
4A42:  MOVLB  2
4A44:  CLRF   x10
4A46:  MOVLW  01
4A48:  MOVWF  x12
4A4A:  MOVLW  D5
4A4C:  MOVWF  x11
4A4E:  MOVLB  0
4A50:  CALL   0E20
....................           } 
....................           else { 
4A54:  BRA    4A6C
....................              InStatesChanged[i] = FALSE; 
4A56:  MOVFF  1EE,20F
4A5A:  MOVLB  2
4A5C:  CLRF   x10
4A5E:  MOVLW  01
4A60:  MOVWF  x12
4A62:  MOVLW  D5
4A64:  MOVWF  x11
4A66:  MOVLB  0
4A68:  CALL   0E20
4A6C:  MOVLB  1
....................           } 
....................         } 
....................       } 
....................       // If new input state is changed from stored input state 
....................       else if ((InStates[i] == FALSE && NewInStates[i] == TRUE) || 
4A6E:  BRA    4B2E
4A70:  MOVLB  0
....................          (InStates[i] == TRUE && NewInStates[i] == FALSE)) { 
4A72:  MOVFF  1EE,1F2
4A76:  MOVLW  01
4A78:  MOVLB  1
4A7A:  MOVWF  xF4
4A7C:  MOVLW  D1
4A7E:  MOVWF  xF3
4A80:  MOVLB  0
4A82:  RCALL  458E
4A84:  MOVLW  00
4A86:  BTFSC  01.0
4A88:  MOVLW  01
4A8A:  ANDLW  01
4A8C:  BNZ   4AAC
4A8E:  MOVFF  1EE,1F2
4A92:  MOVLW  01
4A94:  MOVLB  1
4A96:  MOVWF  xF4
4A98:  MOVLW  D3
4A9A:  MOVWF  xF3
4A9C:  MOVLB  0
4A9E:  RCALL  458E
4AA0:  MOVLW  00
4AA2:  BTFSC  01.0
4AA4:  MOVLW  01
4AA6:  ANDLW  01
4AA8:  SUBLW  01
4AAA:  BZ    4AE6
4AAC:  MOVFF  1EE,1F2
4AB0:  MOVLW  01
4AB2:  MOVLB  1
4AB4:  MOVWF  xF4
4AB6:  MOVLW  D1
4AB8:  MOVWF  xF3
4ABA:  MOVLB  0
4ABC:  RCALL  458E
4ABE:  MOVLW  00
4AC0:  BTFSC  01.0
4AC2:  MOVLW  01
4AC4:  ANDLW  01
4AC6:  SUBLW  01
4AC8:  BNZ   4B2C
4ACA:  MOVFF  1EE,1F2
4ACE:  MOVLW  01
4AD0:  MOVLB  1
4AD2:  MOVWF  xF4
4AD4:  MOVLW  D3
4AD6:  MOVWF  xF3
4AD8:  MOVLB  0
4ADA:  RCALL  458E
4ADC:  MOVLW  00
4ADE:  BTFSC  01.0
4AE0:  MOVLW  01
4AE2:  ANDLW  01
4AE4:  BNZ   4B2C
....................          #ifdef USE_PORTD_LCD 
....................             printf(lcd_putc, "\fIN_%d%d%d", i + 1, InStates[i], NewInStates[i]); 
....................          #endif 
....................          InStatesChanged[i] = TRUE; 
4AE6:  MOVFF  1EE,20F
4AEA:  MOVLW  01
4AEC:  MOVLB  2
4AEE:  MOVWF  x10
4AF0:  MOVWF  x12
4AF2:  MOVLW  D5
4AF4:  MOVWF  x11
4AF6:  MOVLB  0
4AF8:  CALL   0E20
....................          InStatesChangedTime[i] = TickGet(); 
4AFC:  BCF    FD8.0
4AFE:  MOVLB  1
4B00:  RLCF   xEE,W
4B02:  CLRF   03
4B04:  ADDLW  D7
4B06:  MOVWF  01
4B08:  MOVLW  01
4B0A:  ADDWFC 03,F
4B0C:  MOVFF  01,1EF
4B10:  MOVFF  03,1F0
4B14:  MOVLB  0
4B16:  CALL   0FE8
4B1A:  MOVFF  1F0,FEA
4B1E:  MOVFF  1EF,FE9
4B22:  MOVFF  02,FEC
4B26:  MOVF   FED,F
4B28:  MOVFF  01,FEF
4B2C:  MOVLB  1
....................       } 
....................    } 
4B2E:  INCF   xEE,F
4B30:  BRA    48AE
....................  
....................    if (ControlDecisions[1] == TRUE) { 
4B32:  BTFSS  xE9.1
4B34:  BRA    4B44
....................       InChangedHandle(OUT_1, 1); 
4B36:  MOVLW  21
4B38:  MOVWF  xEF
4B3A:  MOVLW  01
4B3C:  MOVWF  xF0
4B3E:  MOVLB  0
4B40:  RCALL  4802
4B42:  MOVLB  1
....................    } 
....................    if (ControlDecisions[2] == TRUE) { 
4B44:  BTFSS  xE9.2
4B46:  BRA    4B56
....................       InChangedHandle(OUT_2, 2); 
4B48:  MOVLW  20
4B4A:  MOVWF  xEF
4B4C:  MOVLW  02
4B4E:  MOVWF  xF0
4B50:  MOVLB  0
4B52:  RCALL  4802
4B54:  MOVLB  1
....................    }       
....................    if (ControlDecisions[3] == TRUE) { 
4B56:  BTFSS  xE9.3
4B58:  BRA    4B68
....................       InChangedHandle(OUT_3, 3); 
4B5A:  MOVLW  05
4B5C:  MOVWF  xEF
4B5E:  MOVLW  03
4B60:  MOVWF  xF0
4B62:  MOVLB  0
4B64:  RCALL  4802
4B66:  MOVLB  1
....................    } 
....................    if (ControlDecisions[4] == TRUE) { 
4B68:  BTFSS  xE9.4
4B6A:  BRA    4B78
....................       InChangedHandle(OUT_4, 4); 
4B6C:  MOVLW  04
4B6E:  MOVWF  xEF
4B70:  MOVWF  xF0
4B72:  MOVLB  0
4B74:  RCALL  4802
4B76:  MOVLB  1
....................    } 
....................    /* 
....................    if (ControlDecisions[5] == TRUE) { 
....................       InChangedHandle(OUT_5, 5); 
....................    } 
....................    if (ControlDecisions[6] == TRUE) { 
....................       InChangedHandle(OUT_6, 6); 
....................    } 
....................    if (ControlDecisions[7] == TRUE) { 
....................       InChangedHandle(OUT_7, 7); 
....................    } 
....................    if (ControlDecisions[8] == TRUE) { 
....................       InChangedHandle(OUT_8, 8); 
....................    } 
....................    */ 
.................... } 
4B78:  MOVLB  0
4B7A:  GOTO   6BC4 (RETURN)
....................  
....................  
....................  
.................... void MyMacInit() { 
....................    MY_MAC_BYTE1 = MY_DEFAULT_MAC_BYTE1; 
*
0CF0:  CLRF   47
....................    MY_MAC_BYTE2 = MY_DEFAULT_MAC_BYTE2; 
0CF2:  MOVLW  04
0CF4:  MOVWF  48
....................    MY_MAC_BYTE3 = MyEEPRom.Macs[0]; 
0CF6:  MOVFF  37,49
....................    MY_MAC_BYTE4 = MyEEPRom.Macs[1]; 
0CFA:  MOVFF  38,4A
....................    MY_MAC_BYTE5 = MyEEPRom.Macs[2]; 
0CFE:  MOVFF  39,4B
....................    MY_MAC_BYTE6 = MyEEPRom.Macs[3]; 
0D02:  MOVFF  3A,4C
.................... } 
0D06:  GOTO   0DD2 (RETURN)
....................  
.................... void MyIpInit() { 
....................    int8 i; 
....................    for (i = 0; i < 4; i++) { 
0D0A:  MOVLB  1
0D0C:  CLRF   xEE
0D0E:  MOVF   xEE,W
0D10:  SUBLW  03
0D12:  BNC   0D46
....................       MY_SRV_IP_BYTES[i] = MyEEPRom.SrvIps[i]; 
0D14:  CLRF   03
0D16:  MOVF   xEE,W
0D18:  ADDLW  22
0D1A:  MOVWF  01
0D1C:  MOVLW  00
0D1E:  ADDWFC 03,F
0D20:  MOVFF  03,1F0
0D24:  CLRF   03
0D26:  MOVF   xEE,W
0D28:  ADDLW  27
0D2A:  MOVWF  FE9
0D2C:  MOVLW  00
0D2E:  ADDWFC 03,W
0D30:  MOVWF  FEA
0D32:  MOVFF  FEF,1F1
0D36:  MOVFF  1F0,FEA
0D3A:  MOVFF  01,FE9
0D3E:  MOVFF  1F1,FEF
....................    } 
0D42:  INCF   xEE,F
0D44:  BRA    0D0E
....................     
....................    //Direccion IP 
....................    MY_IP_BYTE1 = MyEEPRom.Ips[0]; 
0D46:  MOVFF  2B,43
....................    MY_IP_BYTE2 = MyEEPRom.Ips[1]; 
0D4A:  MOVFF  2C,44
....................    MY_IP_BYTE3 = MyEEPRom.Ips[2]; 
0D4E:  MOVFF  2D,45
....................    MY_IP_BYTE4 = MyEEPRom.Ips[3];   
0D52:  MOVFF  2E,46
....................  
....................    //Puerta de Enlace 
....................    MY_GATE_BYTE1 = MyEEPRom.Gates[0]; 
0D56:  MOVFF  33,51
....................    MY_GATE_BYTE2 = MyEEPRom.Gates[1]; 
0D5A:  MOVFF  34,52
....................    MY_GATE_BYTE3 = MyEEPRom.Gates[2]; 
0D5E:  MOVFF  35,53
....................    MY_GATE_BYTE4 = MyEEPRom.Gates[3]; 
0D62:  MOVFF  36,54
....................  
....................    //Mascara de Subred 
....................    MY_MASK_BYTE1 = MyEEPRom.Masks[0]; 
0D66:  MOVFF  2F,4D
....................    MY_MASK_BYTE2 = MyEEPRom.Masks[1]; 
0D6A:  MOVFF  30,4E
....................    MY_MASK_BYTE3 = MyEEPRom.Masks[2]; 
0D6E:  MOVFF  31,4F
....................    MY_MASK_BYTE4 = MyEEPRom.Masks[3]; 
0D72:  MOVFF  32,50
.................... } 
0D76:  MOVLB  0
0D78:  GOTO   0DD4 (RETURN)
....................  
.................... void MyInputTypesInit() { 
....................    int8 i; 
....................    for (i = 0; i < 8; i++) { 
0D7C:  MOVLB  1
0D7E:  CLRF   xEE
0D80:  MOVF   xEE,W
0D82:  SUBLW  07
0D84:  BNC   0DB8
....................       MY_INPUT_TYPE_BYTES[i] = MyEEPRom.InputTypes[i]; 
0D86:  CLRF   03
0D88:  MOVF   xEE,W
0D8A:  ADDLW  1A
0D8C:  MOVWF  01
0D8E:  MOVLW  00
0D90:  ADDWFC 03,F
0D92:  MOVFF  03,1F0
0D96:  CLRF   03
0D98:  MOVF   xEE,W
0D9A:  ADDLW  3B
0D9C:  MOVWF  FE9
0D9E:  MOVLW  00
0DA0:  ADDWFC 03,W
0DA2:  MOVWF  FEA
0DA4:  MOVFF  FEF,1F1
0DA8:  MOVFF  1F0,FEA
0DAC:  MOVFF  01,FE9
0DB0:  MOVFF  1F1,FEF
....................    } 
0DB4:  INCF   xEE,F
0DB6:  BRA    0D80
.................... } 
0DB8:  MOVLB  0
0DBA:  GOTO   0DD6 (RETURN)
....................  
.................... void ConfigInit() { 
....................    EEPReadAll(); 
0DBE:  BRA    08D4
....................  
....................    if (MyEEPRom.Flag != TRUE) { 
0DC0:  DECFSZ 26,W
0DC2:  BRA    0DC6
0DC4:  BRA    0DD0
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\f%s", "Use Default"); 
.................... #endif 
....................       MacReset(); 
0DC6:  BRA    0A42
....................       ConfigReset(); 
0DC8:  RCALL  0A50
....................       EEPWriteMac(); 
0DCA:  RCALL  0AB0
....................       EEPWriteConfig(); 
0DCC:  RCALL  0CE2
....................    } 
....................    else { 
0DCE:  BRA    0DD0
.................... #ifdef USE_PORTD_LCD 
....................       printf(lcd_putc, "\f%s", "Use EEPRom"); 
.................... #endif 
....................    } 
....................    MyMacInit(); 
0DD0:  BRA    0CF0
....................    MyIpInit(); 
0DD2:  BRA    0D0A
....................    MyInputTypesInit(); 
0DD4:  BRA    0D7C
.................... } 
0DD6:  GOTO   6B46 (RETURN)
....................  
.................... void OutputHigh(int8 pin, BOOLEAN p16fRunning) { 
....................    if (p16fRunning == FALSE) {  
*
0E62:  MOVLB  1
0E64:  MOVF   xF1,F
0E66:  BNZ   0E8A
....................       // power cut, hold system start 
....................       delay_ms(2500); 
0E68:  MOVLW  0A
0E6A:  MOVWF  xF2
0E6C:  CLRF   19
0E6E:  BTFSC  FF2.7
0E70:  BSF    19.7
0E72:  BCF    FF2.7
0E74:  MOVLW  FA
0E76:  MOVLB  2
0E78:  MOVWF  xA9
0E7A:  MOVLB  0
0E7C:  CALL   00E6
0E80:  BTFSC  19.7
0E82:  BSF    FF2.7
0E84:  MOVLB  1
0E86:  DECFSZ xF2,F
0E88:  BRA    0E6C
....................    }    
....................    output_high(pin); 
0E8A:  MOVFF  1F0,20F
0E8E:  MOVLW  01
0E90:  MOVLB  2
0E92:  MOVWF  x10
0E94:  MOVLW  0F
0E96:  MOVWF  x12
0E98:  MOVLW  89
0E9A:  MOVWF  x11
0E9C:  MOVLB  0
0E9E:  RCALL  0E20
0EA0:  MOVFF  1F0,20F
0EA4:  MOVLB  2
0EA6:  CLRF   x10
0EA8:  MOVLW  0F
0EAA:  MOVWF  x12
0EAC:  MOVLW  92
0EAE:  MOVWF  x11
0EB0:  MOVLB  0
0EB2:  RCALL  0E20
.................... } 
0EB4:  RETLW  00
....................  
.................... void IOsConfig() { 
....................     
....................    input(IN_1); 
*
0DDA:  BSF    F95.7
....................    input(IN_2); 
0DDC:  BSF    F93.0
....................    input(IN_3); 
0DDE:  BSF    F93.1
....................    input(IN_4); 
0DE0:  BSF    F93.2
....................    input(IN_5);   
0DE2:  BSF    F94.4
....................    input(IN_6); 
0DE4:  BSF    F94.5
....................    input(IN_7); 
0DE6:  BSF    F95.5
....................    input(IN_8); 
0DE8:  BSF    F95.6
....................    input(IN_RESET); 
0DEA:  BSF    F93.3
....................    input(IN_16F_RUNNING); 
0DEC:  BSF    F95.1
....................  
....................    output_low(OUT_1); 
0DEE:  BCF    F96.1
0DF0:  BCF    F8D.1
....................    output_low(OUT_2); 
0DF2:  BCF    F96.0
0DF4:  BCF    F8D.0
....................    output_low(OUT_3); 
0DF6:  BCF    F92.5
0DF8:  BCF    F89.5
....................    output_low(OUT_4); 
0DFA:  BCF    F92.4
0DFC:  BCF    F89.4
....................    output_low(OUT_5); 
0DFE:  BCF    F94.2
0E00:  BCF    F8B.2
....................    output_low(OUT_6); 
0E02:  BCF    F94.1
0E04:  BCF    F8B.1
....................    output_low(OUT_7); 
0E06:  BCF    F94.0
0E08:  BCF    F8B.0
....................    output_low(OUT_8); 
0E0A:  BCF    F96.2
0E0C:  BCF    F8D.2
....................    output_low(OUT_IAM_RUNNING);  
0E0E:  BCF    F95.0
0E10:  BCF    F8C.0
....................    output_low(OUT_TCP_STATE);  
0E12:  BCF    F93.4
0E14:  BCF    F8A.4
.................... } 
0E16:  GOTO   6B4A (RETURN)
....................  
.................... void OutputsRestore(void) { 
*
0EB6:  MOVLB  1
0EB8:  BCF    xEE.0
....................    // If p16f is running, it mean this pic is reset because of WDT 
....................    // Esle the reason of reseting is power cut 
....................    BOOLEAN p16fRunning = FALSE; //input_state(IN_16F_RUNNING); 
....................    if (p16fRunning == FALSE) { 
0EBA:  BTFSC  xEE.0
0EBC:  BRA    0EDC
....................       output_high(OUT_IAM_RUNNING); 
0EBE:  BCF    F95.0
0EC0:  BSF    F8C.0
0EC2:  CLRF   19
0EC4:  BTFSC  FF2.7
0EC6:  BSF    19.7
0EC8:  BCF    FF2.7
....................       delay_ms(100); 
0ECA:  MOVLW  64
0ECC:  MOVLB  2
0ECE:  MOVWF  xA9
0ED0:  MOVLB  0
0ED2:  CALL   00E6
0ED6:  BTFSC  19.7
0ED8:  BSF    FF2.7
0EDA:  MOVLB  1
....................    } 
....................    // Restore ouput states 
....................    if (read_eeprom(29) == TRUE) { 
0EDC:  MOVFF  FF2,1EF
0EE0:  BCF    FF2.7
0EE2:  MOVLW  1D
0EE4:  MOVWF  FA9
0EE6:  BCF    FA6.6
0EE8:  BCF    FA6.7
0EEA:  BSF    FA6.0
0EEC:  MOVF   FA8,W
0EEE:  BTFSC  xEF.7
0EF0:  BSF    FF2.7
0EF2:  SUBLW  01
0EF4:  BNZ   0F0C
....................       OutputHigh(OUT_1, p16fRunning); 
0EF6:  MOVLW  00
0EF8:  BTFSC  xEE.0
0EFA:  MOVLW  01
0EFC:  MOVWF  xEF
0EFE:  MOVLW  21
0F00:  MOVWF  xF0
0F02:  MOVFF  1EF,1F1
0F06:  MOVLB  0
0F08:  RCALL  0E62
0F0A:  MOVLB  1
....................    } 
....................    // 
....................    if (read_eeprom(30) == TRUE) { 
0F0C:  MOVFF  FF2,1EF
0F10:  BCF    FF2.7
0F12:  MOVLW  1E
0F14:  MOVWF  FA9
0F16:  BCF    FA6.6
0F18:  BCF    FA6.7
0F1A:  BSF    FA6.0
0F1C:  MOVF   FA8,W
0F1E:  BTFSC  xEF.7
0F20:  BSF    FF2.7
0F22:  SUBLW  01
0F24:  BNZ   0F3C
....................       OutputHigh(OUT_2, p16fRunning); 
0F26:  MOVLW  00
0F28:  BTFSC  xEE.0
0F2A:  MOVLW  01
0F2C:  MOVWF  xEF
0F2E:  MOVLW  20
0F30:  MOVWF  xF0
0F32:  MOVFF  1EF,1F1
0F36:  MOVLB  0
0F38:  RCALL  0E62
0F3A:  MOVLB  1
....................    } 
....................    // 
....................    if (read_eeprom(31) == TRUE) { 
0F3C:  MOVFF  FF2,1EF
0F40:  BCF    FF2.7
0F42:  MOVLW  1F
0F44:  MOVWF  FA9
0F46:  BCF    FA6.6
0F48:  BCF    FA6.7
0F4A:  BSF    FA6.0
0F4C:  MOVF   FA8,W
0F4E:  BTFSC  xEF.7
0F50:  BSF    FF2.7
0F52:  SUBLW  01
0F54:  BNZ   0F6C
....................       OutputHigh(OUT_3, p16fRunning); 
0F56:  MOVLW  00
0F58:  BTFSC  xEE.0
0F5A:  MOVLW  01
0F5C:  MOVWF  xEF
0F5E:  MOVLW  05
0F60:  MOVWF  xF0
0F62:  MOVFF  1EF,1F1
0F66:  MOVLB  0
0F68:  RCALL  0E62
0F6A:  MOVLB  1
....................    } 
....................    // 
....................    if (read_eeprom(32) == TRUE) { 
0F6C:  MOVFF  FF2,1EF
0F70:  BCF    FF2.7
0F72:  MOVLW  20
0F74:  MOVWF  FA9
0F76:  BCF    FA6.6
0F78:  BCF    FA6.7
0F7A:  BSF    FA6.0
0F7C:  MOVF   FA8,W
0F7E:  BTFSC  xEF.7
0F80:  BSF    FF2.7
0F82:  SUBLW  01
0F84:  BNZ   0F9C
....................       OutputHigh(OUT_4, p16fRunning); 
0F86:  MOVLW  00
0F88:  BTFSC  xEE.0
0F8A:  MOVLW  01
0F8C:  MOVWF  xEF
0F8E:  MOVLW  04
0F90:  MOVWF  xF0
0F92:  MOVFF  1EF,1F1
0F96:  MOVLB  0
0F98:  RCALL  0E62
0F9A:  MOVLB  1
....................    } 
....................     
....................    /* 
....................    // 
....................    if (read_eeprom(33) == TRUE) { 
....................       OutputHigh(OUT_5, p16fRunning); 
....................    } 
....................    // 
....................    if (read_eeprom(34) == TRUE) { 
....................       OutputHigh(OUT_6, p16fRunning); 
....................    } 
....................    // 
....................    if (read_eeprom(35) == TRUE) { 
....................       OutputHigh(OUT_7, p16fRunning); 
....................    } 
....................    // 
....................    if (read_eeprom(36) == TRUE) { 
....................       OutputHigh(OUT_8, p16fRunning); 
....................    } 
....................    */ 
....................     
....................    if (p16fRunning == TRUE) { 
0F9C:  BTFSS  xEE.0
0F9E:  BRA    0FA4
....................       output_high(OUT_IAM_RUNNING); 
0FA0:  BCF    F95.0
0FA2:  BSF    F8C.0
....................    } 
.................... } 
0FA4:  MOVLB  0
0FA6:  GOTO   6B78 (RETURN)
....................  
.................... #byte UCFG = 0xF6F  
.................... #bit UTRDIS = UCFG.3 
....................  
.................... void ResetEnc28J60(void) { 
....................    // Check to reset ENC28J60            
....................    output_low(PIN_ENC_MAC_RST); 
*
0888:  BCF    F95.2
088A:  BCF    F8C.2
....................    delay_ms(100);    
088C:  MOVLW  64
088E:  MOVLB  2
0890:  MOVWF  xA9
0892:  MOVLB  0
0894:  RCALL  00E6
....................    StackInit();    
0896:  RCALL  0854
....................    TCPClientInit(); 
0898:  RCALL  0864
.................... #ifdef USE_PORTD_LCD 
....................    printf(lcd_putc, "\f%s", "ENCRestarted"); 
.................... #endif 
.................... } 
089A:  RETLW  00
....................  
.................... // 
.................... #define T1InterruptPerS   12 
.................... int8 T1InterruptCounter; 
.................... #INT_TIMER1 
.................... void timer1_isr(void) { 
....................    // Will only do the following code if TIMER1 has interrupted 
....................  
....................    T1InterruptCounter++; 
089C:  MOVLB  1
089E:  INCF   xED,F
....................  
....................    /* 
....................    It is 1 seconds from reseting the Timer1 counter. 
....................    The loop of while(TRUE) inside main() is not working. Perhaps PIC gets stuck in a method and cannot come out. 
....................    Hmm, try to reset ENC. In many cases, the loop works again. 
....................    */ 
....................    if (T1InterruptCounter == T1InterruptPerS) {   
08A0:  MOVF   xED,W
08A2:  SUBLW  0C
08A4:  BNZ   08B0
.................... #ifdef USE_PORTD_LCD 
....................      printf(lcd_putc, "\f%s", "Crashed!ResetENC"); 
.................... #endif 
....................      ResetEnc28J60(); 
08A6:  MOVLB  0
08A8:  RCALL  0888
....................      clear_interrupt(INT_TIMER1); 
08AA:  BCF    F9E.0
....................    } 
....................  
....................    /* 
....................    It is 2 seconds from reseting the Timer1 counter. 
....................    The loop of while(TRUE) inside main() is not working any more. Perhaps PIC gets stuck in a method and cannot come out. 
....................    Hmm, there is no solution to make it work again unless using WDT to reset. 
....................    */ 
....................    else if (T1InterruptCounter == (T1InterruptPerS * 2)) { 
08AC:  BRA    08CA
08AE:  MOVLB  1
08B0:  MOVF   xED,W
08B2:  SUBLW  18
08B4:  BNZ   08CC
.................... #ifdef USE_PORTD_LCD 
....................      printf(lcd_putc, "\f%s", "Crashed!ResetPIC"); 
.................... #endif 
....................      clear_interrupt(INT_TIMER1); 
08B6:  BCF    F9E.0
....................      output_low(OUT_IAM_RUNNING); 
08B8:  BCF    F95.0
08BA:  BCF    F8C.0
....................      delay_ms(10); 
08BC:  MOVLW  0A
08BE:  MOVLB  2
08C0:  MOVWF  xA9
08C2:  MOVLB  0
08C4:  RCALL  00E6
....................      setup_wdt(WDT_ON);      
08C6:  BSF    FD1.0
....................      restart_wdt(); 
08C8:  CLRWDT
08CA:  MOVLB  1
....................    } 
.................... } 
....................  
08CC:  BCF    F9E.0
08CE:  MOVLB  0
08D0:  GOTO   006C
.................... void Timer1Init(void) { 
....................     setup_timer_1 ( T1_INTERNAL | T1_DIV_BY_4 ); // Internal clock and prescaler 8 
*
105C:  MOVLW  A5
105E:  MOVWF  FCD
....................     set_timer1(0);                               // Preload value 
1060:  CLRF   FCF
1062:  CLRF   FCE
....................     clear_interrupt(INT_TIMER1);                 // Clear Timer1 interrupt flag bit 
1064:  BCF    F9E.0
....................     enable_interrupts(INT_TIMER1);               // Enable Timer1 interrupt 
1066:  BSF    F9D.0
....................     enable_interrupts(GLOBAL); 
1068:  MOVLW  C0
106A:  IORWF  FF2,F
.................... } 
106C:  GOTO   6B80 (RETURN)
....................  
.................... void main(void) { 
*
6A4C:  CLRF   FF8
6A4E:  BCF    FD0.7
6A50:  BSF    07.7
6A52:  CLRF   FEA
6A54:  CLRF   FE9
6A56:  CLRF   x7C
6A58:  CLRF   x7B
6A5A:  CLRF   x7D
6A5C:  CLRF   x7E
6A5E:  CLRF   x86
6A60:  CLRF   x85
6A62:  MOVLW  04
6A64:  MOVWF  x89
6A66:  CLRF   x88
6A68:  MOVLW  FE
6A6A:  MOVLB  1
6A6C:  MOVWF  xC9
6A6E:  CLRF   xCE
6A70:  CLRF   xD0
6A72:  CLRF   xCF
6A74:  MOVF   FC1,W
6A76:  ANDLW  C0
6A78:  IORLW  0F
6A7A:  MOVWF  FC1
6A7C:  MOVLW  07
6A7E:  MOVWF  FB4
6A80:  MOVLB  0
6A82:  CLRF   x74
6A84:  CLRF   x75
6A86:  CLRF   x87
6A88:  BCF    x83.1
6A8A:  MOVLB  1
6A8C:  CLRF   x40
6A8E:  CLRF   x41
6A90:  CLRF   x42
6A92:  CLRF   x43
6A94:  CLRF   x44
6A96:  CLRF   x45
6A98:  CLRF   x46
6A9A:  CLRF   x47
6A9C:  CLRF   x48
6A9E:  CLRF   x49
6AA0:  CLRF   x55
6AA2:  CLRF   x56
6AA4:  CLRF   x57
6AA6:  CLRF   x58
6AA8:  CLRF   x59
6AAA:  CLRF   x5A
6AAC:  CLRF   x5B
6AAE:  CLRF   x5C
6AB0:  CLRF   x5D
6AB2:  CLRF   x5E
6AB4:  CLRF   x5F
6AB6:  CLRF   x60
6AB8:  CLRF   x61
6ABA:  CLRF   x62
6ABC:  CLRF   x63
6ABE:  CLRF   x64
6AC0:  CLRF   x65
6AC2:  CLRF   x66
6AC4:  CLRF   x67
6AC6:  CLRF   x68
6AC8:  CLRF   x69
6ACA:  CLRF   x6A
6ACC:  CLRF   x6B
6ACE:  CLRF   x6C
6AD0:  CLRF   x6D
6AD2:  CLRF   x6E
6AD4:  CLRF   x6F
6AD6:  CLRF   x70
6AD8:  CLRF   x71
6ADA:  CLRF   x72
6ADC:  CLRF   x73
6ADE:  CLRF   x74
6AE0:  CLRF   x75
6AE2:  CLRF   x76
6AE4:  CLRF   x77
6AE6:  CLRF   x78
6AE8:  CLRF   x79
6AEA:  CLRF   x7A
6AEC:  CLRF   x7B
6AEE:  CLRF   x7C
6AF0:  CLRF   x7D
6AF2:  CLRF   x7E
6AF4:  CLRF   x7F
6AF6:  CLRF   x80
6AF8:  CLRF   x81
6AFA:  CLRF   x82
6AFC:  CLRF   x83
6AFE:  CLRF   x84
6B00:  CLRF   x85
6B02:  CLRF   x86
6B04:  CLRF   x87
6B06:  CLRF   x88
6B08:  CLRF   x89
6B0A:  CLRF   x8A
6B0C:  CLRF   x8B
6B0E:  CLRF   x8C
6B10:  CLRF   x8D
6B12:  CLRF   x8E
6B14:  CLRF   x8F
6B16:  CLRF   x90
6B18:  CLRF   x91
6B1A:  CLRF   x92
6B1C:  CLRF   x93
6B1E:  CLRF   x94
6B20:  CLRF   x95
6B22:  CLRF   x96
6B24:  CLRF   x97
6B26:  CLRF   x98
6B28:  CLRF   x99
6B2A:  CLRF   x9A
6B2C:  CLRF   xCA
6B2E:  CLRF   xCB
6B30:  CLRF   xCC
6B32:  CLRF   xCD
....................    UTRDIS = 1;  
6B34:  BSF    F6F.3
....................    setup_adc(ADC_OFF); 
6B36:  BCF    FC2.0
....................    setup_adc_ports(NO_ANALOGS);   
6B38:  MOVF   FC1,W
6B3A:  ANDLW  C0
6B3C:  IORLW  0F
6B3E:  MOVWF  FC1
....................    ConfigInit(); 
6B40:  MOVLB  0
6B42:  GOTO   0DBE
....................    IOsConfig(); 
6B46:  GOTO   0DDA
....................    delay_ms(500); 
6B4A:  MOVLW  02
6B4C:  MOVLB  1
6B4E:  MOVWF  xEE
6B50:  CLRF   19
6B52:  BTFSC  FF2.7
6B54:  BSF    19.7
6B56:  BCF    FF2.7
6B58:  MOVLW  FA
6B5A:  MOVLB  2
6B5C:  MOVWF  xA9
6B5E:  MOVLB  0
6B60:  CALL   00E6
6B64:  BTFSC  19.7
6B66:  BSF    FF2.7
6B68:  MOVLB  1
6B6A:  DECFSZ xEE,F
6B6C:  BRA    6B50
....................    TCPLedOff(); 
6B6E:  MOVLB  0
6B70:  CALL   0E1A
....................    OutputsRestore(); 
6B74:  GOTO   0EB6
....................    InputsScanInit();    
6B78:  GOTO   1002
....................     
.................... // The LCD must be initialized before MAC, IP and Stack    
.................... #ifdef USE_PORTD_LCD 
....................    lcd_init(); 
.................... #endif 
....................  
.................... #ifdef USE_PORTD_LCD 
....................    printf(lcd_putc, "\f%s", "IONOFF-P8"); 
....................    //printf(lcd_putc, "\nIN_RESET %d", input_state(IN_RESET)); 
....................    //printf(lcd_putc, "\n%u.%u.%u.%u", MY_IP_BYTE1, MY_IP_BYTE2, MY_IP_BYTE3, MY_IP_BYTE4); 
....................    printf(lcd_putc, "\n%u.%u.%u.%u", MY_SRV_IP_BYTES[0], MY_SRV_IP_BYTES[1], MY_SRV_IP_BYTES[2], MY_SRV_IP_BYTES[3]); 
....................    //printf(lcd_putc, "\n%u.%u.%u.%u", MY_GATE_BYTE1, MY_GATE_BYTE2, MY_GATE_BYTE3, MY_GATE_BYTE4); 
....................     
.................... #endif 
....................     
....................    Timer1Init(); 
6B7C:  GOTO   105C
6B80:  CLRF   19
6B82:  BTFSC  FF2.7
6B84:  BSF    19.7
6B86:  BCF    FF2.7
....................    StackInit();    
6B88:  CALL   0854
6B8C:  BTFSC  19.7
6B8E:  BSF    FF2.7
....................    TCPClientInit(); 
6B90:  CALL   0864
....................    delay_ms(500); 
6B94:  MOVLW  02
6B96:  MOVLB  1
6B98:  MOVWF  xEE
6B9A:  CLRF   19
6B9C:  BTFSC  FF2.7
6B9E:  BSF    19.7
6BA0:  BCF    FF2.7
6BA2:  MOVLW  FA
6BA4:  MOVLB  2
6BA6:  MOVWF  xA9
6BA8:  MOVLB  0
6BAA:  CALL   00E6
6BAE:  BTFSC  19.7
6BB0:  BSF    FF2.7
6BB2:  MOVLB  1
6BB4:  DECFSZ xEE,F
6BB6:  BRA    6B9A
....................    while (TRUE) { 
....................       // Reset the timer1 counter 
....................       T1InterruptCounter = 0; 
6BB8:  CLRF   xED
....................       StackTask(); 
6BBA:  MOVLB  0
6BBC:  GOTO   43BE
....................       InsListen(); 
6BC0:  GOTO   4850
....................       TCPClientTask(); 
6BC4:  GOTO   6084
....................        
....................       if (IsTCPClientBusy == FALSE && EncTransactionCount > 12) {          
6BC8:  BTFSC  x83.4
6BCA:  BRA    6BEC
6BCC:  MOVLB  1
6BCE:  MOVF   xA7,W
6BD0:  SUBLW  0C
6BD2:  BTFSS  FD8.0
6BD4:  BRA    6BDA
6BD6:  MOVLB  0
6BD8:  BRA    6BEC
6BDA:  CLRF   19
6BDC:  BTFSC  FF2.7
6BDE:  BSF    19.7
6BE0:  BCF    FF2.7
....................          ResetEnc28J60(); 
6BE2:  MOVLB  0
6BE4:  CALL   0888
6BE8:  BTFSC  19.7
6BEA:  BSF    FF2.7
....................       } 
....................    } 
6BEC:  MOVLB  1
6BEE:  BRA    6BB8
.................... } 
....................  
....................  
6BF0:  SLEEP 

Configuration Fuses:
   Word  1: 8C24   PLL5 CPUDIV1 USBDIV HS NOFCMEN IESO
   Word  2: 0E19   NOPUT NOBROWNOUT BORV20 NOVREGEN NOWDT WDT128
   Word  3: 8100   CCP2C1 NOPBADEN NOLPT1OSC MCLR
   Word  4: 00A0   NOSTVREN NOLVP ICPRT NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
